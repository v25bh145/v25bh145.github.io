{"meta":{"title":"V25bh145的小家儿~","subtitle":"","description":"记录学习编程的过程","author":"v25bh145","url":"https://v25bh145.github.io","root":"/"},"pages":[],"posts":[{"title":"Question-P1908","slug":"Question-P1908","date":"2019-11-26T10:36:39.000Z","updated":"2019-11-26T11:31:27.050Z","comments":true,"path":"2019/11/26/Question-P1908/","link":"","permalink":"https://v25bh145.github.io/2019/11/26/Question-P1908/","excerpt":"","text":"P1908题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10^9109 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 6 5 4 2 6 3 1输出 11说明/提示对于25%的数据，n \\leq 2500n≤2500 对于50%的数据，n \\leq 4 \\times 10^4n≤4×104 。 对于所有数据，n \\leq 5 \\times 10^5n≤5×105 请使用较快的输入输出 题外话啊对了，忘了说廖，建立这个博客就是为了记录学编程的过程呢 大概是初二(初三？？ 反正我也不知道我跳的是初二还是初三hhh)开始学的C扒 然后高一试着搞了搞noip，高二喜提省二第一就放弃廖TAT 菜是原罪啊 现在大一廖，也不知道怎么脑子抽了报志愿就报了计算机专业hhh 终于决定痛改前非，去搞一搞ACM 总之就是你们面前这个写博客的蒟蒻又双叒叕开始学编程了QAQ 应该在博客里打算记一下这些东西： 算法题中过程出大问题的地方 Question 应该会按照算法分好类 一些奇♂妙的编程方法 Algorithm 一些编程科目的小笔记 Note 应该不多这个 嘛应该会记得很杂很杂…..尽量分个小类吧hhh 不啰嗦了hh 解嘛首先看到这道题，分析一波数据要求theta(nlgn) 然后首先考虑遍历数组，发现暴力做法就是遍历两遍数组： 暴力解法for(int i = 1; i &lt;= n; i++) for(int j = i + 1; j &lt;= n; j++&gt;) if(a[i] &gt; a[j]) count++;嗯就是这么暴力,自己求一遍逆，用计算机打出我的暴力思路hhh 然后发现题目标签有分治法，这道题可以用分治法来做 先拆分，一般都拆成二分一列数组的逆序数 = 中间靠左数组的逆序数 + 中间靠右数组的逆序数 + 两个子数组之间产生的逆序数 然后递归求解两边的逆序数，发现：原子问题： 两个数字的逆序数 最后要合并问题 这里我为难廖，怎么合并呢？也就是说，怎么求两个子数组之间产生的逆序数呢？ 先考虑暴力做法，跟上方的代码差不多，左边遍历一遍，然后嵌套里面，里面右边遍历一遍 有什么优化嘛？什么被重复计算了？ 我发现了：假设5&gt;2，5在2前面，如果有7&gt;5，7在2的前面，那么一定有7&gt;2 这里自然而然想到了排序，也就假设左右合并的数组已经排好序(升序)了 发现只用遍历一遍就能出结果 计数好右边的数字的数目 遍历整个排好升序的数组 如果遍历到右边的数字，计数– 如果遍历到左边的数字，结果 += 计数 如此得合并的时间复杂度为 排序的复杂度+一个单n 分治法1这里搞了一个结构体，用来暂存传入Merge()中的数组以及下标，并且排好序 //分治法的合并 int Merge(int l, int r) { for(int i = l; i &lt;= r; i++) { snot2[i].num = snot[i]; snot2[i].p = i; } VQuickSort(l, r); int count = 0, result = 0; for(int i = l; i &lt;= r; i++) { if(snot2[i].p &gt; ( l + r ) / 2) count++; if(snot2[i].p &lt;= ( l + r ) / 2) result += count; snot2[i].num = 0; snot2[i].p = 0; } return result; } //分治法的拆分和递归 int Rev(int l, int r) { if(l + 1 == r) { if(snot[l] &gt;= snot[r]) return 1; else return 0; } else if (l &lt; r) { int mid = ( l + r ) / 2; int leftValue = Rev(l, mid); int rightValue = Rev(mid + 1, r); int midValue = Merge(l, r); return leftValue + rightValue + midValue; } else return 0; }正确性：由循环不变式确定，正确 时间复杂度( T(1) = theta(1) )： T(n) = 2T(n / 2) + nlgn = theta(nlg(n)lg(n)) 嗯还是超了，事实证明只过了前50% 很明显问题出在Merge()上，每次都排一次序很麻烦 然后 这 个 时 候 我终于意识到了 这玩意跟归并排序好像啊！ 归并排序也有排序啊，也有分治啊 归并排序的Merge()部分，数组是由Partition部分排过序的 那么这个题也在Partition部分排个序也就行廖 分治法2其实这个题就是分治法加上一个返回值啊…… long long int Merge(int left, int right) { int mid = (left + right) / 2; int leftLength = right - mid; long long int result = 0; int k,p; k = mid; p = right; for(int i = 1; i &lt;= right - left + 1; i++) { if(k &lt; left) { mia[i] = snot[p]; p--; leftLength--; } else if(p &lt; mid + 1) { mia[i] = snot[k]; k--; } else if(snot[k] &lt;= snot[p]) { mia[i] = snot[p]; p--; leftLength--; } else if(snot[k] &gt; snot[p]) { mia[i] = snot[k]; k--; result += leftLength; } } for(int i = right - left + 1; i &gt;= 1; i--) { snot[left + right - left + 1 - i] = mia[i]; mia[i] = 0; } return result; } long long int Rev(int left, int right) { if(left &lt; right) { if(left + 1 == right) { if(snot[left] &gt; snot[right]) { swap(snot[left], snot[right]); return 1; } else return 0; } int mid = (left + right) / 2; long long int leftValue = Rev(left, mid); long long int rightValue = Rev(mid + 1, right); long long int midValue = Merge(left, right); return leftValue + rightValue + midValue; } return 0; }嗯，AC了，是我愚钝，把这道普及+的题看♂了QAQ 以后分治的时候可别再犯这种 过程重复计算使时间空间复杂度提高 的蠢错误了啊QAQ 欧系卖To be continued","categories":[],"tags":[{"name":"分治法","slug":"分治法","permalink":"https://v25bh145.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"}]},{"title":"我的第一个博客","slug":"我的第一个博客","date":"2019-11-26T09:28:19.000Z","updated":"2019-11-26T09:36:20.273Z","comments":true,"path":"2019/11/26/我的第一个博客/","link":"","permalink":"https://v25bh145.github.io/2019/11/26/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"首先，不管你是谁，总之欢迎来到我的博客鸭~第一个博客文章，我就记一下.md的相关知识扒 学自菜鸟教程 https://www.runoob.com/markdown/md-tutorial.html 一. 标题标题一共六种鸭，一级到六级 一级标题二级标题三级标题四级标题五级标题六级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题 ------- 二级标题 =======二. 段落的格式关于换行的话，有两种方式： 在一行尾部空出两个以上空格 多空一行 这两种方式有差别的亚子 段落的字体可以自己设置鸭 有这些： 星号星号可以插入在文本之间呢 斜体字~粗♂体字粗♂斜♂体 *斜体字~* **粗♂体字** ***粗♂斜♂体*** 下划线下划线只能在段首段位使用的斜体字~粗♂体字 _斜体字~_ __粗♂体字__ 分割线↓这个就是个分割线辣~~↓ *** * * * ***** - - - ------- 删除线删除线一一一(调皮) ~~删除线~~ 下划线这个 &lt;u&gt;下划线&lt;/u&gt; 脚注 脚注貌似无法使用emmmmm 三. 列表有序的和无序的： 第一项 第二项 第三项 * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 qaq qaq qaq 1. qaq 2. qaq 3. qaq 然后还能嵌套,像酱紫 qaq qaq qaq qaq qaq qaq qaq qaq qaq qaq (混乱) 四. 区块区块引用就是加上一个&gt;符号和一个空格 我是一个区块引用 巧了，我也是诶 我不仅有一级引用 我还有二级引用 甚至还有三级 甚至还能做列表 还能嵌套 列表 区块引用 &gt; 我是一个区块引用 &gt; 巧了，我也是诶 &gt; 我不仅有一级引用 &gt; &gt; 我还有二级引用 &gt; &gt; &gt; 甚至还有三级 &gt; &gt; &gt; * 甚至还能做列表 &gt; &gt; &gt; + 还能嵌套 &gt; &gt; 1. 列表 &gt; &gt; &gt; &gt; 区块引用五. 代码scanf()函数~printf()函数~static void main(String[] args) `scanf()`函数~ `printf()`函数~ `static void main(String[] args` 空四格或者一个Tab就是代码区块辣 ----&gt;像这样(这怎么描述啊喂)六. 链接比如酱紫: 滚去问度娘啊！ 滚去问[度娘](http://www.baidu.com/)啊！https://v25bh145.github.io/ &lt;https://v25bh145.github.io/&gt;还有高级(搞♂基)的链接 变量式的： 滚去问度娘啊啊啊 baidu滚去问[我的主页]啊啊啊 主页 七. 图片![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) alt 属性文本 :就是图片的替代文字 可选标题 :title属性的文字 我这里用了这个上传图片网站哇 ![example.png](https://i.loli.net/2019/11/26/eSxz8W2A6rFpMyK.png)当然是可以使用变量的啦 [example][1] [1]: &quot;链接&quot;八. 表格 表头 &lt;-学姐头没了(滑稽) 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 |表头||&lt;-学姐头没了(滑稽)| | ---- | ---- | ---- | | 单元格儿 | 单元格儿 | 单元格儿 | | 单元格儿 | 单元格儿 | 单元格儿 |表头底下的横线还可以设置表格格式： :—- 居左对齐 —-: 居右对齐 :—-: 居中对齐 ⑨. 另外一些gao♂ji特性一些高级技巧： 支持HTML元素也就是说可以不用学markdown直接开学html哈哈哈 *转义* \\*转义\\* 内嵌数学公式以$$开始，$$结束,格式为TeX或者LaTeX","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://v25bh145.github.io/tags/markdown/"}]}]}