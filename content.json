[{"title":"Question-P1631","date":"2019-12-04T08:12:07.000Z","path":"2019/12/04/Question-P1631/","text":"P1631题目描述有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^{2}$个和，求这$N^{2}$个和中最小的N个。 输入格式第一行一个正整数N； 第二行N个整数$A_{i}$, 满足$A_{i}$ &lt;= $A_{i+1}$且 $A_{i}$ ≤$10^{9}$; 第三行N个整数$B_{i}$, 满足$B_{i}$ &lt;= $B_{i+1}$且 $B_{i}$ ≤$10^{9}$. 【数据规模】对于50%的数据中，满足1&lt;=N&lt;=1000； 对于100%的数据中，满足1&lt;=N&lt;=100000。 输出格式输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。 输入输出样例输入 #1 3 2 6 6 1 4 8输出 #1 3 6 7 听音乐~ 解这个题真的不难，但是非常的具有代表性QAQ 下面这个题用这个题的模板做，改改value的计算方式就AC了…… 链接：P2085 所以还不多康康这种题？！！ introa和b是以升序排布的嘛 (这一点我一开始居然没有看出来！QAQ我个瞎子) 然后求的是 a + b 的前几个最小值 从数据范围看出来要的是O(nlgn) 暴力暴力做法，那就是申个二维数组挨个算 不仅从时间上(O($n^{2}$))超了，空间也超了 在第n个小的求和之外所花费的时间和空间全部多余了 研究如何使得多余的计算被避免掉，那就需要从暴力做法还没有讨论到的特殊性质出发辣 暴力做法二维数组的性质那我们先打个表出来 横行是a数组，纵行是b数组 a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 很明显，最小的数字应该从左上往右下取得 还有一个性质： 如果要取(i,j)，必须要保证(i,j-1)与(i-1,j)被取得 因为(i,j-1)与(i-1,j)都比(i,j)要小 反映到图上，由于这是一条可以递归的性质，图要求这个节点的左上所构成的矩形全部被取到 然后还有个最基础的性质，(1,1)一定会被取到 那么就可以从(1,1)开始，先打印(1,1) 判断出(1,2)与(2,1)都符合比较的规则 然后比较(1,2)与(2,1) 按照图来，打印(2,1) 判断(3,1)符合规则，(2,2)由于(1,2)还没有被取到，不符合规则 比较(3,1)与(1,2) …… 注意到前面的比较被淘汰的仍然参与下一次比较 每一次比较只选出最小的值 想到了什么？？堆！ 接下来还有两个问题需要讨论： 如何判断是否符合规则 如何比较堆的值(&gt; &lt; =) 1. 如何判断是否符合规则即是判断二维数组左上角的矩形中有没有没被选择上的数字 考虑到如果(i,j)被选择到了，那么(i,j)左上角的矩形都被选择到了 所以要看(i + 1, j + 1)左上方是否有空，就是看其左方的数字的左上方是否有空，上方的数字的左上方是否有空，也就是看左方的数字是否为空，上方的数字是否为空 这不是让你递归啊=-= 就是把(i + 1,j + 1)的判断转移到了(i,j+1)与(i+1,j)上 以左边为例 判断左边是否为空，第一想到的就是设置一个矩阵……超空间了 然后依据最小的性质，可以比较左边和刚刚输出的数字，如果小就是已经输出过了 –如果左边的数字和刚刚输出的数字相等呢？那我们可以做一个规定，默认堆排序的时候在 值大小 的优先级之下比较谁更靠左 这样也解决了问题2. 代码#include &lt;iostream&gt; using namespace std; int a[105000], b[105000], n, length = 0; struct Node { int value; int left; int right; }heap[105000]; void SwapHeap(int p1, int p2) { swap(heap[p1].left, heap[p2].left); swap(heap[p1].right, heap[p2].right); swap(heap[p1].value, heap[p2].value); } void HeapifyFromDownToUp(int k) { if(k &gt; 1) { int parent = k / 2; if(heap[parent].value &gt; heap[k].value) { SwapHeap(parent, k); HeapifyFromDownToUp(parent); } else if(heap[parent].value == heap[k].value &amp;&amp; heap[parent].right &gt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(parent, k) ; HeapifyFromDownToUp(parent); } } } void HeapifyFromUpToDown(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1; int lChild = k * 2; int minChild; if(rChild &gt; length) minChild = lChild; else { if(heap[rChild].value &lt; heap[lChild].value) minChild = rChild; else if(heap[rChild].value &gt; heap[lChild].value) minChild = lChild; else if(heap[rChild].value == heap[lChild].value) { minChild = heap[lChild].right &lt;= heap[rChild].right ? lChild : rChild; } } if(heap[minChild].value &lt; heap[k].value) { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } else if(heap[minChild].value == heap[k].value &amp;&amp; heap[minChild].right &lt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } } } void Put(int le, int r) { length++; heap[length].left = le; heap[length].right = r; heap[length].value = a[le] + b[r]; HeapifyFromDownToUp(length); } Node Push() { Node temp; temp.left = heap[1].left; temp.right = heap[1].right; temp.value = heap[1].value; SwapHeap(1, length); length--; HeapifyFromUpToDown(1); return temp; } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; Put(1, 1); for(int i = 1; i &lt;= n; i++) { Node temp = Push(); cout&lt;&lt;temp.value&lt;&lt;&quot; &quot;; int r = temp.right; int le = temp.left; //这里有一个边界条件鸭 if(r - 1 == 0 || a[le + 1] + b[r - 1] &lt;= a[le] + b[r]) //这个小于等于就是默认规定辣 Put(le + 1, r); if(le - 1 == 0 || a[le - 1] + b[r + 1] &lt; a[le] + b[r]) Put(le, r + 1); } return 0; }我居然把函数名搞错了还居然花了我一个下午调试 解2还可以这样想呢~ 等我先把表格搬过来，嘿咻~ a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 把每一行当做优先队列，将第一列的值存入堆，输出最小值时把对应的行的下一列的值放入堆 也就是把表格横着扫一遍~ 当然这是其他dalao的思路，我搬过来而已QAQ 这样想更简单了 没有什么默认规则了，代码就舒服多了QAQ #include &lt;iostream&gt; using namespace std; int a[105000], b[105000], length = 0, n; struct Node { int value; int p1; int p2; }heap[500000]; void HeapifyUTD(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1, lChild = k * 2, minChild; if(lChild == length) minChild = lChild; else minChild = heap[lChild].value &lt; heap[rChild].value ? lChild : rChild; if(heap[k].value &gt; heap[minChild].value) { swap(heap[k], heap[minChild]); HeapifyUTD(minChild); } } } Node Get() { Node tmp; tmp.p1 = heap[1].p1; tmp.p2 = heap[1].p2; tmp.value = heap[1].value; swap(heap[1], heap[length]); length--; HeapifyUTD(1); return tmp; } void HeapifyDTU(int k) { int parent = k / 2; if(parent &gt; 0) if(heap[k].value &lt; heap[parent].value) { swap(heap[k], heap[parent]); HeapifyDTU(parent); } } void Put(int p1, int p2) { length++; heap[length].p1 = p1; heap[length].p2 = p2; heap[length].value = a[p1] + b[p2]; HeapifyDTU(length); } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; for(int i = 1; i &lt;= n; i++) Put(i, 1); for(int i = 1; i &lt;= n; i++) { Node tmp = Get(); cout&lt;&lt;tmp.value&lt;&lt;&quot; &quot;; Put(tmp.p1, tmp.p2 + 1); } return 0; } 归纳： 遇见可以用 表格/暴力 做 超空间/超时间 的题,不妨先按着 表格/暴力做法 推几个数据找性质,然后根据性质选择性地从 表格/暴力做法 中筛选 需要的元素和需要的步骤 最后提一嘴 P2085 中的数组是[x][n]呢","content":"<h1 id=\"P1631\"><a href=\"#P1631\" class=\"headerlink\" title=\"P1631\"></a>P1631</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^{2}$个和，求这$N^{2}$个和中最小的N个。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>第一行一个正整数N；</p>\n<p>第二行N个整数$A_{i}$, 满足$A_{i}$ &lt;= $A_{i+1}$且 $A_{i}$ ≤$10^{9}$;</p>\n<p>第三行N个整数$B_{i}$, 满足$B_{i}$ &lt;= $B_{i+1}$且 $B_{i}$ ≤$10^{9}$.</p>\n<h2 id=\"【数据规模】\"><a href=\"#【数据规模】\" class=\"headerlink\" title=\"【数据规模】\"></a>【数据规模】</h2><p>对于50%的数据中，满足1&lt;=N&lt;=1000；</p>\n<p>对于100%的数据中，满足1&lt;=N&lt;=100000。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。</p>\n<h2 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2><p>输入 #1</p>\n<pre><code>3\n2 6 6\n1 4 8</code></pre><p>输出 #1</p>\n<pre><code>3 6 7</code></pre><hr>\n<p>听音乐~</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=36024572&auto=0&height=66\"></iframe>\n\n<hr>\n<h1 id=\"解\"><a href=\"#解\" class=\"headerlink\" title=\"解\"></a>解</h1><p>这个题真的不难，但是非常的具有代表性QAQ</p>\n<p>下面这个题用这个题的模板做，改改value的计算方式就AC了……</p>\n<p>链接：<a href=\"https://www.luogu.com.cn/problem/P2085\" target=\"_blank\" rel=\"noopener\">P2085</a></p>\n<p>所以还不多康康这种题？！！</p>\n<hr>\n<h2 id=\"intro\"><a href=\"#intro\" class=\"headerlink\" title=\"intro\"></a>intro</h2><p>a和b是以升序排布的嘛 <del>(这一点我一开始居然没有看出来！QAQ我个瞎子)</del></p>\n<p>然后求的是 a + b 的前几个最小值</p>\n<p>从数据范围看出来要的是<code>O(nlgn)</code></p>\n<hr>\n<h3 id=\"暴力\"><a href=\"#暴力\" class=\"headerlink\" title=\"暴力\"></a>暴力</h3><p>暴力做法，那就是申个二维数组挨个算</p>\n<p>不仅从时间上(O($n^{2}$))超了，空间也超了</p>\n<p>在第n个小的求和之外所花费的时间和空间全部多余了</p>\n<p>研究如何使得多余的计算被避免掉，那就需要从暴力做法还没有讨论到的特殊性质出发辣</p>\n<hr>\n<h3 id=\"暴力做法二维数组的性质\"><a href=\"#暴力做法二维数组的性质\" class=\"headerlink\" title=\"暴力做法二维数组的性质\"></a>暴力做法二维数组的性质</h3><p>那我们先打个表出来</p>\n<p>横行是a数组，纵行是b数组</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">a\\b</th>\n<th align=\"center\">1</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">7</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\">10</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">9</td>\n<td align=\"center\">11</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n<td align=\"center\">11</td>\n<td align=\"center\">13</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">9</td>\n<td align=\"center\">10</td>\n<td align=\"center\">11</td>\n<td align=\"center\">13</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"center\">9</td>\n<td align=\"center\">11</td>\n<td align=\"center\">12</td>\n<td align=\"center\">13</td>\n<td align=\"center\">15</td>\n<td align=\"center\">17</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"center\">10</td>\n<td align=\"center\">12</td>\n<td align=\"center\">14</td>\n<td align=\"center\">15</td>\n<td align=\"center\">17</td>\n<td align=\"center\">19</td>\n</tr>\n</tbody></table>\n<p>很明显，<code>最小的数字应该从左上往右下取得</code></p>\n<p>还有一个性质：</p>\n<p><code>如果要取(i,j)，必须要保证(i,j-1)与(i-1,j)被取得</code></p>\n<p>因为(i,j-1)与(i-1,j)都比(i,j)要小</p>\n<p>反映到图上，由于这是一条可以递归的性质，<code>图要求这个节点的左上所构成的矩形全部被取到</code></p>\n<p>然后还有个最基础的性质，<code>(1,1)一定会被取到</code></p>\n<hr>\n<blockquote>\n<p>那么就可以从(1,1)开始，先打印(1,1)</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>判断出(1,2)与(2,1)都符合比较的规则</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>然后比较(1,2)与(2,1)  </p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>按照图来，打印(2,1)</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>判断(3,1)符合规则，(2,2)由于(1,2)还没有被取到，不符合规则</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>比较(3,1)与(1,2)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>……</p>\n</blockquote>\n<p>注意到前面的比较被淘汰的仍然参与下一次比较</p>\n<p>每一次比较只选出最小的值</p>\n<p>想到了什么？？堆！</p>\n<p>接下来还有两个问题需要讨论：</p>\n<ol>\n<li>如何判断是否符合规则</li>\n<li>如何比较堆的值(&gt; &lt; =)</li>\n</ol>\n<hr>\n<h3 id=\"1-如何判断是否符合规则\"><a href=\"#1-如何判断是否符合规则\" class=\"headerlink\" title=\"1. 如何判断是否符合规则\"></a>1. 如何判断是否符合规则</h3><p>即是判断二维数组左上角的矩形中有没有没被选择上的数字</p>\n<p>考虑到如果(i,j)被选择到了，那么(i,j)左上角的矩形都被选择到了</p>\n<p><code>所以要看(i + 1, j  + 1)左上方是否有空，就是看其左方的数字的左上方是否有空，上方的数字的左上方是否有空，也就是看左方的数字是否为空，上方的数字是否为空</code></p>\n<p>这不是让你递归啊=-=</p>\n<p>就是把(i + 1,j + 1)的判断转移到了(i,j+1)与(i+1,j)上</p>\n<p>以左边为例</p>\n<p>判断左边是否为空，第一想到的就是设置一个矩阵……超空间了</p>\n<p>然后依据最小的性质，可以比较左边和刚刚输出的数字，如果小就是已经输出过了</p>\n<hr>\n<h2 id=\"–如果左边的数字和刚刚输出的数字相等呢？\"><a href=\"#–如果左边的数字和刚刚输出的数字相等呢？\" class=\"headerlink\" title=\"–如果左边的数字和刚刚输出的数字相等呢？\"></a>–如果左边的数字和刚刚输出的数字相等呢？</h2><p>那我们可以做一个规定，默认堆排序的时候在 值大小 的优先级之下比较谁更靠左</p>\n<p>这样也解决了问题2.</p>\n<hr>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint a[105000], b[105000], n, length = 0;\nstruct Node\n{\n    int value;\n    int left;\n    int right;\n}heap[105000];\nvoid SwapHeap(int p1, int p2)\n{\n    swap(heap[p1].left, heap[p2].left);\n    swap(heap[p1].right, heap[p2].right);\n    swap(heap[p1].value, heap[p2].value);\n}\nvoid HeapifyFromDownToUp(int k)\n{\n    if(k &gt; 1)\n    {\n        int parent = k / 2;\n        if(heap[parent].value &gt; heap[k].value)\n        {\n            SwapHeap(parent, k);\n            HeapifyFromDownToUp(parent);\n        }\n        else if(heap[parent].value == heap[k].value &amp;&amp; heap[parent].right &gt; heap[k].right)\n        //在value大小的优先级之下比较right\n        {\n            SwapHeap(parent, k)    ;\n            HeapifyFromDownToUp(parent);\n        }\n    }\n}\nvoid HeapifyFromUpToDown(int k)\n{\n    if(k &lt;= length / 2)\n    {\n        int rChild = k * 2 + 1;\n        int lChild = k * 2;\n        int minChild;\n        if(rChild &gt; length)\n            minChild = lChild;\n        else\n        {\n            if(heap[rChild].value &lt; heap[lChild].value)\n                minChild = rChild;\n            else if(heap[rChild].value &gt; heap[lChild].value)\n                minChild = lChild;\n            else if(heap[rChild].value == heap[lChild].value)\n            {\n                minChild = heap[lChild].right &lt;= heap[rChild].right ? lChild : rChild;\n            }\n        }\n\n        if(heap[minChild].value &lt; heap[k].value)\n        {\n            SwapHeap(minChild, k);\n            HeapifyFromUpToDown(minChild);\n        }\n        else if(heap[minChild].value == heap[k].value &amp;&amp; heap[minChild].right &lt; heap[k].right)\n        //在value大小的优先级之下比较right\n        {\n            SwapHeap(minChild, k);    \n            HeapifyFromUpToDown(minChild);\n        }\n    }\n}\nvoid Put(int le, int r)\n{\n    length++;\n    heap[length].left = le;\n    heap[length].right = r;\n    heap[length].value = a[le] + b[r];\n    HeapifyFromDownToUp(length);\n}\n\nNode Push()\n{\n    Node temp;\n    temp.left = heap[1].left;\n    temp.right = heap[1].right;\n    temp.value = heap[1].value;\n\n    SwapHeap(1, length);\n    length--;\n    HeapifyFromUpToDown(1);    \n    return temp;\n}\nint  main()\n{\n    cin&gt;&gt;n;\n    for(int i = 1; i &lt;= n; i++)\n        cin&gt;&gt;a[i];\n    for(int i = 1; i &lt;= n; i++)\n        cin&gt;&gt;b[i];\n\n    Put(1, 1);\n    for(int i = 1; i &lt;= n; i++)\n    {\n        Node temp = Push();\n        cout&lt;&lt;temp.value&lt;&lt;&quot; &quot;;\n        int r = temp.right;\n        int le = temp.left;\n        //这里有一个边界条件鸭\n        if(r - 1 == 0 || a[le + 1] + b[r - 1] &lt;= a[le] + b[r])\n        //这个小于等于就是默认规定辣\n            Put(le + 1, r);\n        if(le - 1 == 0 || a[le - 1] + b[r + 1] &lt; a[le] + b[r])\n            Put(le, r + 1);\n    }\n    return 0;\n}</code></pre><p><del>我居然把函数名搞错了还居然花了我一个下午调试</del></p>\n<hr>\n<h1 id=\"解2\"><a href=\"#解2\" class=\"headerlink\" title=\"解2\"></a>解2</h1><p>还可以这样想呢~</p>\n<p>等我先把表格搬过来，嘿咻~</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">a\\b</th>\n<th align=\"center\">1</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">7</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">8</td>\n<td align=\"center\">10</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">9</td>\n<td align=\"center\">11</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">7</td>\n<td align=\"center\">8</td>\n<td align=\"center\">9</td>\n<td align=\"center\">11</td>\n<td align=\"center\">13</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"center\">7</td>\n<td align=\"center\">9</td>\n<td align=\"center\">10</td>\n<td align=\"center\">11</td>\n<td align=\"center\">13</td>\n<td align=\"center\">15</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"center\">9</td>\n<td align=\"center\">11</td>\n<td align=\"center\">12</td>\n<td align=\"center\">13</td>\n<td align=\"center\">15</td>\n<td align=\"center\">17</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"center\">10</td>\n<td align=\"center\">12</td>\n<td align=\"center\">14</td>\n<td align=\"center\">15</td>\n<td align=\"center\">17</td>\n<td align=\"center\">19</td>\n</tr>\n</tbody></table>\n<p>把每一行当做优先队列，将第一列的值存入堆，输出最小值时把对应的行的下一列的值放入堆</p>\n<p>也就是把表格横着扫一遍~</p>\n<p>当然这是其他dalao的思路，我搬过来而已QAQ</p>\n<p>这样想更简单了</p>\n<hr>\n<p>没有什么默认规则了，代码就舒服多了QAQ</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint a[105000], b[105000], length = 0, n;\nstruct Node\n{\n    int value;\n    int p1;\n    int p2;\n}heap[500000];\nvoid HeapifyUTD(int k)\n{\n    if(k &lt;= length / 2)\n    {\n        int rChild = k * 2 + 1, lChild = k * 2, minChild;\n        if(lChild == length)\n            minChild = lChild;\n        else\n            minChild = heap[lChild].value &lt; heap[rChild].value ? lChild : rChild;\n        if(heap[k].value &gt; heap[minChild].value)\n        {\n            swap(heap[k], heap[minChild]);\n            HeapifyUTD(minChild);\n        }\n    }\n}\nNode Get()\n{\n    Node tmp;\n    tmp.p1 = heap[1].p1;\n    tmp.p2 = heap[1].p2;\n    tmp.value = heap[1].value;\n    swap(heap[1], heap[length]);\n    length--;\n    HeapifyUTD(1);\n    return tmp;\n}\nvoid HeapifyDTU(int k)\n{\n    int parent = k / 2;\n    if(parent &gt; 0)\n        if(heap[k].value &lt; heap[parent].value)\n        {\n            swap(heap[k], heap[parent]);\n            HeapifyDTU(parent);\n        }\n}\nvoid Put(int p1, int p2)\n{\n    length++;\n    heap[length].p1 = p1;\n    heap[length].p2 = p2;\n    heap[length].value = a[p1] + b[p2];\n    HeapifyDTU(length);\n}\nint main()\n{\n    cin&gt;&gt;n;\n    for(int i = 1; i &lt;= n; i++)\n        cin&gt;&gt;a[i];\n    for(int i = 1; i &lt;= n; i++)\n        cin&gt;&gt;b[i];\n\n    for(int i = 1; i &lt;= n; i++)\n        Put(i, 1);\n    for(int i = 1; i &lt;= n; i++)\n    {\n        Node tmp = Get();\n        cout&lt;&lt;tmp.value&lt;&lt;&quot; &quot;;\n        Put(tmp.p1, tmp.p2 + 1);\n    }\n    return 0;\n}</code></pre><hr>\n<ul>\n<li>归纳：<blockquote>\n<p>遇见可以用 表格/暴力 做 超空间/超时间 的题,<br>不妨先按着 表格/暴力做法 推几个数据找性质,<br>然后根据性质选择性地从 表格/暴力做法 中筛选 需要的元素和需要的步骤</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<p>最后提一嘴</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P2085\" target=\"_blank\" rel=\"noopener\">P2085</a> 中的数组是[x][n]呢</p>\n","categories":[],"tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P2278","date":"2019-11-30T14:06:45.000Z","path":"2019/11/30/Question-P2278/","text":"P2278题目描述写一个程序来模拟操作系统的进程调度。假设该系统只有一个CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。 如果一个进程到达的时候CPU是空闲的，则它会一直占用CPU直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用CPU，而老的只有等待。 如果一个进程到达时，CPU正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。 一旦CPU空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。 输入格式输入包含若干行，每一行有四个自然数（均不超过10^8），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过15000个。 输出格式按照进程结束的时间输出每个进程的进程号和结束时间。 输入输出样例输入 #11 1 5 3 2 10 5 1 3 12 7 2 4 20 2 3 5 21 9 4 6 22 2 4 7 23 5 2 8 24 2 4 输出 #11 6 3 19 5 30 6 32 8 34 4 35 7 40 2 42 听音乐~ 白2的歌就是好听鸭~ 先扯一点废话没想到这么快就又摆上优先队列了哈哈哈哈哈真是巧合呢 (我居然又一次一次过了提高+/省选-的题) ↑你飘了↑ 解其实一开始我是没想优先队列的 你想嘛，优先级最大的， 最！~ 好的用堆 (不愧是我) (我真的受堆毒害不浅啊！) 好的好的，第一个想到的问题是怎么处理堆 即： 堆排序的规则 什么时候该添加节点 什么时候该拉取节点 如何处理时间 堆排序的规则题目说了，应该选取优先度最高的，同优先度相比时间最早的 所以总体来说就是一个最大堆廖 什么时候该添加节点呢？嗯..好问题 (自吹自擂？？！) 应该在有新的进程到达的时候添加 那么该怎么判断是否进程到达呢？ 设置一个循环，每循环一次到达一个进程 什么时候该拉取节点应该在这个进程处理完毕的时候拉取吧 进程在给的时间范围内已经被处理掉，就拉取一次进程 如果按照第一个问题走，这个过程应该是递归/递推的 如何处理时间嗯..这是一个意义深远的问题，至今我们也不知道会不会有穿越时间的能力存在 (↑胡扯↑你就给我皮↑) 这里的答案就是不要把时间看成连续抽象的，把时间分段，当需要处理事件时就拉取一次时间 问出这些问题，想必你已经对过程有了个大体的认识扒 过程↓2： 依次输入每个进程的参数(四个，优先度，编号，开始时间，持续时间)↓1： 如果堆非空 计算上次输入到这次输入的时间差 如果时间差 &gt; 正在执行的进程的持续时间(即这个进程是否执行完毕) (剩余的)时间差 = 时间差 - 正在执行的进程的持续时间 拉取优先度最大的节点，维护堆的性质 继续执行1: 如果堆非空(即是否还在执行进程) 正在执行的进程的持续时间 - (剩余的)时间差 将此输入入堆，维护堆的性质 存下这次输入进程的参数，传递给下次循环 继续进行2: 算法这里使用了结构体 #include &lt;iostream&gt; #define MAXSIZE 15500 using namespace std; int length = 0; struct A { int prior; int num; int stTime; int lastTime; }maxHeap[MAXSIZE]; void SwapHeap(int p1, int p2) { swap(maxHeap[p1].lastTime, maxHeap[p2].lastTime); swap(maxHeap[p1].num, maxHeap[p2].num); swap(maxHeap[p1].prior, maxHeap[p2].prior); swap(maxHeap[p1].stTime, maxHeap[p2].stTime); } void HeapifyFromUpToDown(int position) { if(position &lt;= length / 2) { int lChild = position * 2; int rChild = position * 2 + 1; int maxChild; if(rChild &gt; length) maxChild = lChild; else if(maxHeap[lChild].prior == maxHeap[rChild].prior) { if(maxHeap[lChild].stTime &lt;= maxHeap[rChild].stTime) maxChild = lChild; else maxChild = rChild; } else maxChild = maxHeap[lChild].prior &gt; maxHeap[rChild].prior ? lChild : rChild; if(maxHeap[maxChild].prior == maxHeap[position].prior) { if(maxHeap[maxChild].stTime &lt;= maxHeap[position].stTime) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } else if(maxHeap[maxChild].prior &gt; maxHeap[position].prior) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } } void HeapifyFromDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent].prior == maxHeap[position].prior) { if(maxHeap[parent].stTime &gt;= maxHeap[position].stTime) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } else if(maxHeap[parent].prior &lt; maxHeap[position].prior) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } } void PushMaxHeap() { SwapHeap(1, length); length--; HeapifyFromUpToDown(1); } void PutMaxHeap(int prior, int num, int stTime, int lastTime) { length++; maxHeap[length].prior = prior; maxHeap[length].num = num; maxHeap[length].stTime = stTime; maxHeap[length].lastTime = lastTime; HeapifyFromDownToUp(length); } int main() { int prior, num, stTime, durTime, timePass; int lastPrior, lastNum, lastStTime, lastDurTime; while(cin&gt;&gt;num&gt;&gt;stTime&gt;&gt;durTime&gt;&gt;prior) { if(length != 0) { timePass = stTime - lastStTime; while( length != 0 &amp;&amp; timePass &gt;= maxHeap[1].lastTime ) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; timePass = timePass - maxHeap[1].lastTime; cout&lt;&lt;stTime - timePass&lt;&lt;endl; PushMaxHeap(); } if(length != 0) maxHeap[1].lastTime = maxHeap[1].lastTime - timePass; } PutMaxHeap(prior, num, stTime, durTime); lastNum = num; lastPrior = prior; lastStTime = stTime; lastDurTime = durTime; } int time = lastStTime; if(length != 0) { while(length != 0) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; cout&lt;&lt;time + maxHeap[1].lastTime&lt;&lt;endl; time = time + maxHeap[1].lastTime; PushMaxHeap(); } } return 0; } 复杂度分析全是条件句分析好难啊 我还是根据结果论分析吧 时间就约等于1s吧，数据量应该是满的，15000 查一下表得知，是O(nlgn) 下表记住廖： 复杂度 下限 上限 O(logN) 10^20 很大 O(N^1/2) 10^12 10^14 O(N) 10^6 10^7 O(NlogN) 10^5 10^6 O(N^2) 1000 2500 O(N^3) 100 500 O(N^4) 50 50 O(2^N) 20 20 O(N!) 9 10","content":"<h1 id=\"P2278\"><a href=\"#P2278\" class=\"headerlink\" title=\"P2278\"></a>P2278</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>写一个程序来模拟操作系统的进程调度。假设该系统只有一个CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。</p>\n<p>如果一个进程到达的时候CPU是空闲的，则它会一直占用CPU直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用CPU，而老的只有等待。</p>\n<p>如果一个进程到达时，CPU正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。</p>\n<p>一旦CPU空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>输入包含若干行，每一行有四个自然数（均不超过10^8），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过15000个。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>按照进程结束的时间输出每个进程的进程号和结束时间。</p>\n<h2 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2><h3 id=\"输入-1\"><a href=\"#输入-1\" class=\"headerlink\" title=\"输入 #1\"></a>输入 #1</h3><pre><code>1 1 5 3 \n2 10 5 1 \n3 12 7 2 \n4 20 2 3 \n5 21 9 4 \n6 22 2 4 \n7 23 5 2 \n8 24 2 4 </code></pre><h3 id=\"输出-1\"><a href=\"#输出-1\" class=\"headerlink\" title=\"输出 #1\"></a>输出 #1</h3><pre><code>1 6\n3 19\n5 30\n6 32\n8 34\n4 35\n7 40\n2 42</code></pre><hr>\n<h2 id=\"听音乐\"><a href=\"#听音乐\" class=\"headerlink\" title=\"听音乐~\"></a>听音乐~</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=27594400&auto=0&height=66\"></iframe>\n\n<p>白2的歌就是好听鸭~</p>\n<hr>\n<h2 id=\"先扯一点废话\"><a href=\"#先扯一点废话\" class=\"headerlink\" title=\"先扯一点废话\"></a>先扯一点废话</h2><p>没想到这么快就又摆上优先队列了哈哈哈哈哈真是巧合呢</p>\n<p><del>(我居然又一次一次过了提高+/省选-的题)</del></p>\n<p><del>↑你飘了↑</del></p>\n<hr>\n<h2 id=\"解\"><a href=\"#解\" class=\"headerlink\" title=\"解\"></a>解</h2><p>其实一开始我是没想优先队列的</p>\n<p>你想嘛，优先级最大的， <strong><em>最！~</em></strong></p>\n<p>好的用堆 <del>(不愧是我)</del></p>\n<p><del>(我真的受堆毒害不浅啊！)</del></p>\n<p>好的好的，第一个想到的问题是怎么处理堆</p>\n<p>即：</p>\n<ul>\n<li>堆排序的规则</li>\n<li>什么时候该添加节点</li>\n<li>什么时候该拉取节点</li>\n<li>如何处理时间</li>\n</ul>\n<hr>\n<h3 id=\"堆排序的规则\"><a href=\"#堆排序的规则\" class=\"headerlink\" title=\"堆排序的规则\"></a>堆排序的规则</h3><p>题目说了，应该选取优先度最高的，同优先度相比时间最早的</p>\n<p>所以总体来说就是一个最大堆廖</p>\n<hr>\n<h3 id=\"什么时候该添加节点呢？\"><a href=\"#什么时候该添加节点呢？\" class=\"headerlink\" title=\"什么时候该添加节点呢？\"></a>什么时候该添加节点呢？</h3><p>嗯..好问题 <del>(自吹自擂？？！)</del></p>\n<p>应该在有新的进程到达的时候添加</p>\n<p>那么该怎么判断是否进程到达呢？</p>\n<p><code>设置一个循环，每循环一次到达一个进程</code></p>\n<hr>\n<h3 id=\"什么时候该拉取节点\"><a href=\"#什么时候该拉取节点\" class=\"headerlink\" title=\"什么时候该拉取节点\"></a>什么时候该拉取节点</h3><p>应该在这个进程处理完毕的时候拉取吧</p>\n<p><code>进程在给的时间范围内已经被处理掉，就拉取一次进程</code></p>\n<p>如果按照第一个问题走，这个过程应该是<strong>递归/递推</strong>的</p>\n<hr>\n<h3 id=\"如何处理时间\"><a href=\"#如何处理时间\" class=\"headerlink\" title=\"如何处理时间\"></a>如何处理时间</h3><p><del>嗯..这是一个意义深远的问题，至今我们也不知道会不会有穿越时间的能力存在</del></p>\n<p><del>(↑胡扯↑你就给我皮↑)</del></p>\n<p>这里的答案就是不要把时间看成连续抽象的，把时间分段，<strong>当需要处理事件时就拉取一次时间</strong></p>\n<hr>\n<p>问出这些问题，想必你已经对过程有了个大体的认识扒</p>\n<hr>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><p>↓2：</p>\n<ul>\n<li>依次输入每个进程的参数(四个，优先度，编号，开始时间，持续时间)<br>↓1：<ul>\n<li>如果堆非空<ul>\n<li>计算上次输入到这次输入的时间差</li>\n<li>如果时间差 &gt; 正在执行的进程的持续时间<br>(即这个进程是否执行完毕)<ul>\n<li>(剩余的)时间差 = 时间差 - 正在执行的进程的持续时间</li>\n<li>拉取优先度最大的节点，维护堆的性质</li>\n<li>继续执行1:</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果堆非空<br>(即是否还在执行进程)<ul>\n<li>正在执行的进程的持续时间 - (剩余的)时间差</li>\n</ul>\n</li>\n<li>将此输入入堆，维护堆的性质</li>\n<li>存下这次输入进程的参数，传递给下次循环</li>\n<li>继续进行2:</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>这里使用了结构体</p>\n<pre><code>#include &lt;iostream&gt;\n#define MAXSIZE 15500\nusing namespace std;\nint length = 0;\nstruct    A\n{\n    int prior;\n    int num;\n    int stTime;\n    int lastTime;\n}maxHeap[MAXSIZE];\nvoid SwapHeap(int p1, int p2)\n{\n    swap(maxHeap[p1].lastTime, maxHeap[p2].lastTime);\n    swap(maxHeap[p1].num, maxHeap[p2].num);\n    swap(maxHeap[p1].prior, maxHeap[p2].prior);\n    swap(maxHeap[p1].stTime, maxHeap[p2].stTime);\n}\nvoid HeapifyFromUpToDown(int position)\n{\n\n    if(position &lt;= length / 2)\n    {    \n        int lChild = position * 2;\n        int rChild = position * 2 + 1;\n        int maxChild;\n        if(rChild &gt; length)\n            maxChild = lChild;\n        else if(maxHeap[lChild].prior == maxHeap[rChild].prior)\n        {\n            if(maxHeap[lChild].stTime &lt;= maxHeap[rChild].stTime)\n                maxChild = lChild;\n            else\n                maxChild = rChild;\n        }\n        else\n            maxChild = maxHeap[lChild].prior &gt; maxHeap[rChild].prior ? lChild : rChild;\n\n        if(maxHeap[maxChild].prior == maxHeap[position].prior)\n        {\n            if(maxHeap[maxChild].stTime &lt;= maxHeap[position].stTime)\n            {\n                SwapHeap(maxChild, position);\n                HeapifyFromUpToDown(maxChild);\n            }\n        }\n        else if(maxHeap[maxChild].prior &gt; maxHeap[position].prior)\n        {\n            SwapHeap(maxChild, position);\n            HeapifyFromUpToDown(maxChild);\n        }\n    }\n}\nvoid HeapifyFromDownToUp(int position)\n{\n    int parent = position / 2;\n    if(parent &gt; 0)\n    {\n        if(maxHeap[parent].prior == maxHeap[position].prior)\n        {\n            if(maxHeap[parent].stTime &gt;= maxHeap[position].stTime)\n            {\n                SwapHeap(parent, position);\n                HeapifyFromDownToUp(parent);\n            }\n        }\n        else if(maxHeap[parent].prior &lt; maxHeap[position].prior)\n        {\n            SwapHeap(parent, position);\n            HeapifyFromDownToUp(parent);        \n        }\n    }\n}\nvoid PushMaxHeap()\n{\n    SwapHeap(1, length);\n    length--;\n\n    HeapifyFromUpToDown(1);\n}\nvoid PutMaxHeap(int prior, int num, int stTime, int lastTime)\n{\n    length++;\n    maxHeap[length].prior = prior;\n    maxHeap[length].num = num;\n    maxHeap[length].stTime = stTime;\n    maxHeap[length].lastTime = lastTime;\n\n    HeapifyFromDownToUp(length);\n}\nint main()\n{\n    int prior, num, stTime, durTime, timePass;\n    int lastPrior, lastNum, lastStTime, lastDurTime;\n    while(cin&gt;&gt;num&gt;&gt;stTime&gt;&gt;durTime&gt;&gt;prior)\n    {\n\n        if(length != 0) \n        {\n            timePass = stTime - lastStTime;\n            while( length != 0 &amp;&amp; timePass &gt;= maxHeap[1].lastTime )\n            {\n                cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;;\n                timePass = timePass - maxHeap[1].lastTime;\n                cout&lt;&lt;stTime - timePass&lt;&lt;endl;\n\n                PushMaxHeap();\n            }\n            if(length != 0)\n                maxHeap[1].lastTime = maxHeap[1].lastTime - timePass;\n        }\n        PutMaxHeap(prior, num, stTime, durTime);\n\n        lastNum = num; lastPrior = prior; lastStTime = stTime; lastDurTime = durTime;\n    }\n\n    int time = lastStTime;        \n    if(length != 0) \n    {\n        while(length != 0)\n        {\n            cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;;\n            cout&lt;&lt;time + maxHeap[1].lastTime&lt;&lt;endl;\n            time = time + maxHeap[1].lastTime;\n            PushMaxHeap();\n        }\n    }\n    return 0;\n}</code></pre><hr>\n<h2 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h2><p>全是条件句分析好难啊</p>\n<p><del>我还是根据结果论分析吧</del></p>\n<p><img src=\"https://i.loli.net/2019/11/30/5odBckbuE83tYZw.png\" alt=\"3_5_949VK9M@H_ZF5_5VR57.png\"></p>\n<p>时间就约等于1s吧，数据量应该是满的，15000</p>\n<p>查一下表得知，是O(nlgn)</p>\n<hr>\n<h2 id=\"下表记住廖：\"><a href=\"#下表记住廖：\" class=\"headerlink\" title=\"下表记住廖：\"></a>下表记住廖：</h2><table>\n<thead>\n<tr>\n<th align=\"center\">复杂度</th>\n<th align=\"center\">下限</th>\n<th align=\"center\">上限</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">O(logN)</td>\n<td align=\"center\">10^20</td>\n<td align=\"center\">很大</td>\n</tr>\n<tr>\n<td align=\"center\">O(N^1/2)</td>\n<td align=\"center\">10^12</td>\n<td align=\"center\">10^14</td>\n</tr>\n<tr>\n<td align=\"center\">O(N)</td>\n<td align=\"center\">10^6</td>\n<td align=\"center\">10^7</td>\n</tr>\n<tr>\n<td align=\"center\">O(NlogN)</td>\n<td align=\"center\">10^5</td>\n<td align=\"center\">10^6</td>\n</tr>\n<tr>\n<td align=\"center\">O(N^2)</td>\n<td align=\"center\">1000</td>\n<td align=\"center\">2500</td>\n</tr>\n<tr>\n<td align=\"center\">O(N^3)</td>\n<td align=\"center\">100</td>\n<td align=\"center\">500</td>\n</tr>\n<tr>\n<td align=\"center\">O(N^4)</td>\n<td align=\"center\">50</td>\n<td align=\"center\">50</td>\n</tr>\n<tr>\n<td align=\"center\">O(2^N)</td>\n<td align=\"center\">20</td>\n<td align=\"center\">20</td>\n</tr>\n<tr>\n<td align=\"center\">O(N!)</td>\n<td align=\"center\">9</td>\n<td align=\"center\">10</td>\n</tr>\n</tbody></table>\n","categories":[],"tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模拟","slug":"模拟","permalink":"https://v25bh145.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"Question-P1801","date":"2019-11-30T10:25:11.000Z","path":"2019/11/30/Question-P1801/","text":"P1801题目描述Black Box是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量i。最开始的时候Black Box是空的．而i等于0。这个Black Box要处理一串命令。 命令只有两种： ADD(x):把x元素放进BlackBox; GET:i加1，然后输出Blackhox中第i小的数。 记住：第i小的数，就是Black Box里的数的按从小到大的顺序排序后的第i个元素。例如： 我们来演示一下一个有11个命令的命令串。（如下图所示） 现在要求找出对于给定的命令串的最好的处理方法。ADD和GET命令分别最多200000个。现在用两个整数数组来表示命令串： 1.A(1)，A(2)，…A(M)：一串将要被放进Black Box的元素。每个数都是绝对值不超过2000000000的整数，M$200000。例如上面的例子就是A=(3，1，一4，2，8，-1000，2)。 2.u(1)，u(2)，…u(N)：表示第u(j)个元素被放进了Black Box里后就出现一个GET命令。例如上面的例子中u=(l，2，6，6)。输入数据不用判错。 输入格式第一行，两个整数，M，N。 第二行，M个整数，表示A(l) ……A(M)。 第三行，N个整数，表示u(l) …u(N)。 输出格式输出Black Box根据命令串所得出的输出串，一个数字一行。 输入输出样例输入 #1 7 4 3 1 -4 2 8 -1000 2 1 2 6 6输出 #1 3 3 1 2说明/提示对于30%的数据，M≤10000; 对于50%的数据，M≤100000： 对于100%的数据，M≤200000。 听音乐 解康康这道题辣，给出了m的数据范围在200000之内分析下时间复杂度应该是要求 O(mlgm) 题目的意思大概就是 需要给出在加入第i个元素的排序序列时需要序列第j个小的值 j是自增的 而i是任意给定的自增数列 (题目没说我差点就想再来个排序了) 然后题把加入和查询单独两列列开了，用最简单的模拟显然是不阔以加入一个检测一个的 所以先把add和get操作存进数组里，后续再一并处理： for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; }之后的处理也大概能写个框架出来 headGet = 1; for(int i = 1;i &lt;= m; i++) { //Mark.1 //对putOp[i]进行处理 while(getOp[headGet] == i) { //Mark.2 //对getOp[headGet]进行处理 cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } }这里需要注意一下while,题目实例就给出了get重复的i值 我才不是因为一开始写的if等到写完了算法回去再测试的时候菜发现的呢 (菜) 好了，那我们来填补一下里面的操作扒 Mark.1:这里如果想要实现的话，最暴力的操作就是插入排序，把putOp[i]插入到数组中 同时使得数组的升序不变性保持不变 时间复杂度：theta($m^{2}$) 明显超了 嗯就先这么来吧，暴力解get Mark.2:如果按照上文的插入排序，这里就十分简单辣 直接返回a[i]就可以辣 来康暴力代码：仅仅展示了一些暴力插入排序 为了博客效果写了份暴力代码还不快夸我 void InsertArray(int k) { length++; array[length] = k; if(length != 1) { for(int i = length - 1; i &gt;= 1; i--) { if(array[i + 1] &lt; array[i]) swap(array[i + 1], array[i]); else break; } } } int main() { for(int i = 1;i &lt;= m; i++) { InsertArray(putOp[i]); while(getOp[headGet] == i) { tmp = array[headGet]; cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; }果然暴力插♂入只有30分嘛 好的继续，现在我们需要优化程序廖 插入排序的优化Mark.1这里的插入消耗时间显然过长，一定需要在这里优化 来一波分析，如果需要theta(mlgm) 外部的循环已经配了一层m了，所以里面的要求只能是最多lgm 然后需要的是第i大的数…第i大…第 很容易想到堆的性质鸭！！ 所以我们先建一个最小堆 这样在这里的操作复杂度就是O(lgm)廖 接下来甩锅给Mark.2同学 Mark.2这里需要获取第headGet小的值 能做的就是类似堆排序一样的东东，不断从堆顶拔头发取数字，然后交换最后一个让最后一个顺下去，取headGet遍 恭喜我得出来这个玩意儿：O($m^{2}$lgm) 怎么来的？考虑最坏情况为在put(m)处连续get(m)次，也就是堆排序辣 这个算法使得Mark.2更暴力辣，Mark.2号同学肯定不服气了，把锅儿一巴掌呼回了Nark.1 堆的优化需要优化Mark.2，这时我们把眼光看向瑟瑟发抖的Mark.1 我们可以在Mark.1上加入一些时间来简化Mark.2的时间 怎么做呢？ 好戏来了这里考虑到Mark.2在获取第headGet大的数据时多执行了headGet - 1次 有什么办法直接获取到第headGet大的数字呢？ 我们可以让第headGet大的数字直接位于堆首，把比headGet小的数字扔进弃牌区里 在Mark.2读取完第headGet大的数据后，headGet++，然后把第headGet大的数据也扔进弃牌区里 这时回到Mark.1，我们在加入数据的时候需要在先跟弃牌区里的数字比较一下，然后挑出最大的放到最小堆里 诶，这里这个弃牌区怎么实现呢？ 首先考虑到弃牌区必须要有序 元素依次加入的同时维护有序性 所以我们自然想到了我们的老朋友–插入排序！ 别急，还没完！ 然后再次考虑到我们需要获取最大的元素 再想想刚刚的暴力插入排序转变的过程 终于发现了嘛？ 其实可以将弃牌区用最大堆实现！ 所以总体，复述一下操作： 执行putOp时 将其放入最大堆，维护最大堆性质 从最大堆挑出最大的元素，维护最大堆性质 将挑出的元素放入最小堆，维护最小堆性质 执行getOp时 从最小堆挑出最小的元素，维护最小堆性质 输出它 将挑出的元素放入最大堆，维护最大堆性质 最终的双堆数据结构代码：从输入到处理到输出都写上了 堆的维护好好康康鸭，两种维护方式(自顶向下，自叶向上)都要用上 #include &lt;iostream&gt; #define MAXSIZE 200500 using namespace std; int n,m; int maxLength = 0, minLength = 0; int minHeap[MAXSIZE], maxHeap[MAXSIZE],getOp[MAXSIZE],putOp[MAXSIZE]; void MinHeapifyUpToDown(int k) //up to down { if(k &lt;= minLength / 2) { int lChild = k * 2; int rChild = k * 2 + 1; int minChild; if(rChild &gt; minLength) minChild = lChild; else minChild = minHeap[lChild] &lt; minHeap[rChild] ? lChild : rChild; if(minHeap[k] &gt; minHeap[minChild]) { swap(minHeap[k], minHeap[minChild]); MinHeapifyUpToDown(minChild); } } } void MinHeapifyDownToUp(int k) //down to up { if(k / 2 &gt; 0) { int parent = k / 2; if(minHeap[parent] &gt; minHeap[k]) { swap(minHeap[parent], minHeap[k]); MinHeapifyDownToUp(parent); } } } void PutMinHeap(int k) { minLength++; minHeap[minLength] = k; MinHeapifyDownToUp(minLength); } int GetMinHeap() { int result = minHeap[1]; swap(minHeap[1], minHeap[minLength]); minLength--; MinHeapifyUpToDown(1); return result; } void MaxHeapifyDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent] &lt; maxHeap[position]) { swap(maxHeap[parent], maxHeap[position]); MaxHeapifyDownToUp(parent); } } } void MaxHeapifyUpToDown(int position) { if(position &lt;= maxLength / 2) { int maxChild; int lChild = position * 2; int rChild = position * 2 + 1; if(rChild &gt; maxLength) maxChild = lChild; else maxChild = maxHeap[lChild] &gt; maxHeap[rChild] ? lChild : rChild; if(maxHeap[position] &lt; maxHeap[maxChild]) { swap(maxHeap[position], maxHeap[maxChild]); MaxHeapifyUpToDown(maxChild); } } } void PutMaxHeap(int k) { maxLength++; maxHeap[maxLength] = k; MaxHeapifyDownToUp(maxLength); } int GetMaxHeap() { int result = maxHeap[1]; swap(maxHeap[1], maxHeap[maxLength]); maxLength--; MaxHeapifyUpToDown(1); return result; } int main() { cin&gt;&gt;m&gt;&gt;n; int tmp,headGet; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; } headGet = 1; for(int i = 1;i &lt;= m; i++) { PutMaxHeap(putOp[i]); tmp = GetMaxHeap(); PutMinHeap(tmp); while(getOp[headGet] == i) { tmp = GetMinHeap(); PutMaxHeap(tmp); cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; } 感想：这道题我居然一次做出来了诶，果然堆对我的毒害不浅哈哈哈哈 所以大概什么时候使用堆呢？ 插入排序的优化 “最”出现的时候 优先队列(早日遇上过来水水写写)","content":"<h1 id=\"P1801\"><a href=\"#P1801\" class=\"headerlink\" title=\"P1801\"></a>P1801</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>Black Box是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量i。最开始的时候Black Box是空的．而i等于0。这个Black Box要处理一串命令。</p>\n<p>命令只有两种：</p>\n<p>ADD(x):把x元素放进BlackBox;</p>\n<p>GET:i加1，然后输出Blackhox中第i小的数。</p>\n<p>记住：第i小的数，就是Black Box里的数的按从小到大的顺序排序后的第i个元素。例如：</p>\n<a id=\"more\"></a>\n\n<p>我们来演示一下一个有11个命令的命令串。（如下图所示）</p>\n<p><img src=\"https://i.loli.net/2019/11/30/Z8QUNdYG1tRomaA.jpg\" alt=\"P1801.png\"></p>\n<p>现在要求找出对于给定的命令串的最好的处理方法。ADD和GET命令分别最多200000个。现在用两个整数数组来表示命令串：</p>\n<p>1.A(1)，A(2)，…A(M)：一串将要被放进Black Box的元素。每个数都是绝对值不超过2000000000的整数，M$200000。例如上面的例子就是A=(3，1，一4，2，8，-1000，2)。</p>\n<p>2.u(1)，u(2)，…u(N)：表示第u(j)个元素被放进了Black Box里后就出现一个GET命令。例如上面的例子中u=(l，2，6，6)。输入数据不用判错。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>第一行，两个整数，M，N。</p>\n<p>第二行，M个整数，表示A(l)</p>\n<p>……A(M)。</p>\n<p>第三行，N个整数，表示u(l)</p>\n<p>…u(N)。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>输出Black Box根据命令串所得出的输出串，一个数字一行。</p>\n<h2 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2><p>输入 #1</p>\n<pre><code>7 4\n3 1 -4 2 8 -1000 2\n1 2 6 6</code></pre><p>输出 #1</p>\n<pre><code>3\n3\n1\n2</code></pre><h2 id=\"说明-提示\"><a href=\"#说明-提示\" class=\"headerlink\" title=\"说明/提示\"></a>说明/提示</h2><p>对于30%的数据，M≤10000;</p>\n<p>对于50%的数据，M≤100000：</p>\n<p>对于100%的数据，M≤200000。</p>\n<hr>\n<h2 id=\"听音乐\"><a href=\"#听音乐\" class=\"headerlink\" title=\"听音乐\"></a>听音乐</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=30482680&auto=0&height=66\"></iframe>\n\n<hr>\n<h1 id=\"解\"><a href=\"#解\" class=\"headerlink\" title=\"解\"></a>解</h1><p>康康这道题辣，给出了m的数据范围在200000之内<br>分析下时间复杂度应该是要求 <code>O(mlgm)</code></p>\n<p>题目的意思大概就是</p>\n<ol>\n<li><p>需要给出在加入第i个元素的排序序列时需要序列第j个小的值</p>\n</li>\n<li><p>j是自增的</p>\n</li>\n<li><p>而i是任意给定的自增数列 <del>(题目没说我差点就想再来个排序了)</del></p>\n</li>\n</ol>\n<p>然后题把加入和查询单独两列列开了，用最简单的模拟显然是不阔以加入一个检测一个的</p>\n<p>所以先把add和get操作存进数组里，后续再一并处理：</p>\n<pre><code>for(int i = 1; i &lt;= m; i++)\n{\n    cin&gt;&gt;tmp;\n    putOp[i] = tmp;\n}\nfor(int i = 1; i &lt;= n; i++)\n{\n    cin&gt;&gt;tmp;\n    getOp[i] = tmp;\n}</code></pre><p>之后的处理也大概能写个框架出来</p>\n<pre><code>headGet = 1;\nfor(int i = 1;i &lt;= m; i++)\n{\n    //Mark.1\n    //对putOp[i]进行处理\n    while(getOp[headGet] == i)\n    {\n        //Mark.2\n        //对getOp[headGet]进行处理\n        cout&lt;&lt;tmp&lt;&lt;endl;\n        headGet++;\n    }\n}</code></pre><p>这里需要注意一下while,题目实例就给出了get重复的i值</p>\n<p><del>我才不是因为一开始写的if等到写完了算法回去再测试的时候菜发现的呢</del> <del>(菜)</del></p>\n<p>好了，那我们来填补一下里面的操作扒</p>\n<hr>\n<h3 id=\"Mark-1\"><a href=\"#Mark-1\" class=\"headerlink\" title=\"Mark.1:\"></a>Mark.1:</h3><p>这里如果想要实现的话，最暴力的操作就是插入排序，把putOp[i]插入到数组中</p>\n<p>同时使得数组的升序不变性保持不变</p>\n<p>时间复杂度：theta($m^{2}$)</p>\n<p>明显超了</p>\n<p>嗯就先这么来吧，暴力解get</p>\n<h3 id=\"Mark-2\"><a href=\"#Mark-2\" class=\"headerlink\" title=\"Mark.2:\"></a>Mark.2:</h3><p>如果按照上文的插入排序，这里就十分简单辣</p>\n<p>直接返回a[i]就可以辣</p>\n<h2 id=\"来康暴力代码：\"><a href=\"#来康暴力代码：\" class=\"headerlink\" title=\"来康暴力代码：\"></a>来康暴力代码：</h2><p>仅仅展示了一些暴力插入排序</p>\n<p><del>为了博客效果写了份暴力代码还不快夸我</del></p>\n<pre><code>void InsertArray(int k)\n{\n    length++;\n    array[length] = k;\n    if(length != 1) \n    {\n        for(int i = length - 1; i &gt;= 1; i--)\n        {\n            if(array[i + 1] &lt; array[i])\n                swap(array[i + 1], array[i]);\n            else\n                break;\n        }\n    }\n}\n\nint main()\n{\n    for(int i = 1;i &lt;= m; i++)\n    {\n        InsertArray(putOp[i]);\n        while(getOp[headGet] == i)\n        {\n            tmp = array[headGet];\n            cout&lt;&lt;tmp&lt;&lt;endl;\n            headGet++;\n        }\n    }\n    return 0;\n}</code></pre><p><del>果然暴力插<strong><em>♂</em></strong>入只有30分嘛</del></p>\n<p>好的继续，现在我们需要优化程序廖</p>\n<hr>\n<h2 id=\"插入排序的优化\"><a href=\"#插入排序的优化\" class=\"headerlink\" title=\"插入排序的优化\"></a>插入排序的优化</h2><h2 id=\"Mark-1-1\"><a href=\"#Mark-1-1\" class=\"headerlink\" title=\"Mark.1\"></a>Mark.1</h2><p>这里的插入消耗时间显然过长，一定需要在这里优化</p>\n<p>来一波分析，如果需要theta(mlgm)</p>\n<p>外部的循环已经配了一层m了，所以里面的要求只能是最多lgm</p>\n<p>然后需要的是第i大的数…第i大…第</p>\n<p><strong>很容易想到堆的性质鸭！！</strong></p>\n<p>所以我们先建一个最小堆</p>\n<p>这样在这里的操作复杂度就是O(lgm)廖</p>\n<p><del>接下来甩锅给Mark.2同学</del></p>\n<h2 id=\"Mark-2-1\"><a href=\"#Mark-2-1\" class=\"headerlink\" title=\"Mark.2\"></a>Mark.2</h2><p>这里需要获取第headGet小的值</p>\n<p>能做的就是类似堆排序一样的东东，不断从堆顶<del>拔头发</del>取数字，然后交换最后一个让最后一个顺下去，取headGet遍</p>\n<p>恭喜我得出来这个玩意儿：O($m^{2}$lgm)</p>\n<p>怎么来的？考虑最坏情况为在put(m)处连续get(m)次，也就是堆排序辣</p>\n<p>这个算法使得Mark.2更暴力辣，Mark.2号同学肯定不服气了，把锅儿一巴掌呼回了Nark.1</p>\n<hr>\n<h2 id=\"堆的优化\"><a href=\"#堆的优化\" class=\"headerlink\" title=\"堆的优化\"></a>堆的优化</h2><p>需要优化Mark.2，这时我们把眼光看向瑟瑟发抖的Mark.1</p>\n<p>我们可以在Mark.1上加入一些时间来简化Mark.2的时间</p>\n<p>怎么做呢？</p>\n<h2 id=\"好戏来了\"><a href=\"#好戏来了\" class=\"headerlink\" title=\"好戏来了\"></a><strong><em>好戏来了</em></strong></h2><p>这里考虑到Mark.2在获取第headGet大的数据时多执行了headGet - 1次</p>\n<p>有什么办法直接获取到第headGet大的数字呢？</p>\n<p>我们可以让第headGet大的数字直接位于堆首，把比headGet小的数字扔进<code>弃牌区</code>里</p>\n<p>在Mark.2读取完第headGet大的数据后，headGet++，然后把第headGet大的数据也扔进<code>弃牌区</code>里</p>\n<p>这时回到Mark.1，我们在加入数据的时候需要在先跟<code>弃牌区</code>里的数字比较一下，然后挑出最大的放到最小堆里</p>\n<p><strong><em>诶，这里这个<code>弃牌区</code>怎么实现呢？</em></strong></p>\n<p>首先考虑到<code>弃牌区</code>必须要有序</p>\n<p>元素依次加入的同时维护有序性</p>\n<p>所以我们自然想到了我们的老朋友–<code>插入排序</code>！</p>\n<p>别急，还没完！</p>\n<p>然后再次考虑到我们需要获取<strong>最大的</strong>元素</p>\n<p>再想想刚刚的暴力插入排序转变的过程</p>\n<p>终于发现了嘛？ 其实可以将<code>弃牌区</code>用<code>最大堆</code>实现！</p>\n<p>所以总体，复述一下操作：</p>\n<ul>\n<li>执行putOp时  <ol>\n<li>将其放入最大堆，维护最大堆性质</li>\n<li>从最大堆挑出最大的元素，维护最大堆性质</li>\n<li>将挑出的元素放入最小堆，维护最小堆性质</li>\n</ol>\n</li>\n<li>执行getOp时<ol>\n<li>从最小堆挑出最小的元素，维护最小堆性质</li>\n<li>输出它</li>\n<li>将挑出的元素放入最大堆，维护最大堆性质</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"最终的双堆数据结构代码：\"><a href=\"#最终的双堆数据结构代码：\" class=\"headerlink\" title=\"最终的双堆数据结构代码：\"></a>最终的双堆数据结构代码：</h2><p>从输入到处理到输出都写上了</p>\n<p>堆的维护好好康康鸭，两种维护方式(自顶向下，自叶向上)都要用上</p>\n<pre><code>#include &lt;iostream&gt;\n#define MAXSIZE 200500\nusing namespace std;\nint n,m;\nint maxLength = 0, minLength = 0;\nint minHeap[MAXSIZE], maxHeap[MAXSIZE],getOp[MAXSIZE],putOp[MAXSIZE];\n\nvoid MinHeapifyUpToDown(int k)\n//up to down\n{\n    if(k &lt;= minLength / 2)\n    {\n        int lChild = k * 2;\n        int rChild = k * 2 + 1;\n        int minChild;\n        if(rChild &gt; minLength)\n            minChild = lChild;\n        else\n            minChild = minHeap[lChild] &lt; minHeap[rChild] ? lChild : rChild;\n        if(minHeap[k] &gt; minHeap[minChild])\n        {\n            swap(minHeap[k], minHeap[minChild]);\n            MinHeapifyUpToDown(minChild);\n        }\n    }\n}\nvoid MinHeapifyDownToUp(int k)\n//down to up\n{\n    if(k / 2 &gt; 0)\n    {\n        int parent = k / 2;\n        if(minHeap[parent] &gt; minHeap[k])\n        {\n            swap(minHeap[parent], minHeap[k]);\n            MinHeapifyDownToUp(parent);\n        }\n    }\n}\nvoid PutMinHeap(int k)\n{\n    minLength++;\n\n    minHeap[minLength] = k;\n    MinHeapifyDownToUp(minLength);\n}\nint GetMinHeap()\n{\n    int result = minHeap[1];\n    swap(minHeap[1], minHeap[minLength]);\n    minLength--;\n\n\n    MinHeapifyUpToDown(1);\n    return result;\n}\n\nvoid MaxHeapifyDownToUp(int position)\n{\n    int parent = position / 2;\n    if(parent &gt; 0)\n    {\n        if(maxHeap[parent] &lt; maxHeap[position])\n        {\n            swap(maxHeap[parent], maxHeap[position]);\n            MaxHeapifyDownToUp(parent);\n        }\n    }\n}\nvoid MaxHeapifyUpToDown(int position)\n{\n    if(position &lt;= maxLength / 2)\n    {\n        int maxChild;\n        int lChild = position * 2;\n        int rChild = position * 2 + 1;\n        if(rChild &gt; maxLength)\n            maxChild = lChild;\n        else\n            maxChild = maxHeap[lChild] &gt; maxHeap[rChild] ? lChild : rChild;\n        if(maxHeap[position] &lt; maxHeap[maxChild])\n        {\n            swap(maxHeap[position], maxHeap[maxChild]);\n            MaxHeapifyUpToDown(maxChild);\n        }\n    }\n}\nvoid PutMaxHeap(int k)\n{\n    maxLength++;\n\n    maxHeap[maxLength] = k;\n    MaxHeapifyDownToUp(maxLength);\n}\nint GetMaxHeap()\n{\n    int result = maxHeap[1];\n    swap(maxHeap[1], maxHeap[maxLength]);\n    maxLength--;\n    MaxHeapifyUpToDown(1);\n    return result;\n}\n\n\nint main()\n{\n    cin&gt;&gt;m&gt;&gt;n;\n    int tmp,headGet;\n    for(int i = 1; i &lt;= m; i++)\n    {\n        cin&gt;&gt;tmp;\n        putOp[i] = tmp;\n    }\n    for(int i = 1; i &lt;= n; i++)\n    {\n        cin&gt;&gt;tmp;\n        getOp[i] = tmp;\n    }\n    headGet = 1;\n    for(int i = 1;i &lt;= m; i++)\n    {\n        PutMaxHeap(putOp[i]);\n        tmp = GetMaxHeap();\n        PutMinHeap(tmp);\n        while(getOp[headGet] == i)\n        {\n            tmp = GetMinHeap();\n            PutMaxHeap(tmp);\n            cout&lt;&lt;tmp&lt;&lt;endl;\n            headGet++;\n        }\n    }\n    return 0;\n}</code></pre><hr>\n<h2 id=\"感想：\"><a href=\"#感想：\" class=\"headerlink\" title=\"感想：\"></a>感想：</h2><p>这道题我居然一次做出来了诶，果然堆对我的毒害不浅哈哈哈哈</p>\n<p>所以大概什么时候使用堆呢？</p>\n<ul>\n<li>插入排序的优化</li>\n<li>“最”出现的时候</li>\n<li>优先队列(早日遇上过来<del>水水</del>写写)</li>\n</ul>\n","categories":[],"tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P1908","date":"2019-11-26T10:36:39.000Z","path":"2019/11/26/Question-P1908/","text":"P1908题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10^9109 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 6 5 4 2 6 3 1输出 11说明/提示对于25%的数据，n \\leq 2500n≤2500 对于50%的数据，n \\leq 4 \\times 10^4n≤4×104 。 对于所有数据，n \\leq 5 \\times 10^5n≤5×105 请使用较快的输入输出 题外话听音乐~ 啊对了，忘了说廖，建立这个博客就是为了记录学编程的过程呢 大概是初二(初三？？ 反正我也不知道我跳的是初二还是初三hhh)开始学的C扒 然后高一试着搞了搞noip，高二喜提省二第一就放弃廖TAT 菜是原罪啊 现在大一廖，也不知道怎么脑子抽了报志愿就报了计算机专业hhh 终于决定痛改前非，去搞一搞ACM 总之就是你们面前这个写博客的蒟蒻又双叒叕开始学编程了QAQ 应该在博客里打算记一下这些东西： 算法题中过程出大问题的地方 Question 应该会按照算法分好类 一些奇♂妙的编程方法 Algorithm 一些编程科目的小笔记 Note 应该不多这个 嘛应该会记得很杂很杂…..尽量分个小类吧hhh 不啰嗦了hh 解嘛首先看到这道题，分析一波数据要求theta(nlgn) 然后首先考虑遍历数组，发现暴力做法就是遍历两遍数组： 暴力解法for(int i = 1; i &lt;= n; i++) for(int j = i + 1; j &lt;= n; j++&gt;) if(a[i] &gt; a[j]) count++;嗯就是这么暴力,自己求一遍逆，用计算机打出我的暴力思路hhh 然后发现题目标签有分治法，这道题可以用分治法来做 先拆分，一般都拆成二分一列数组的逆序数 = 中间靠左数组的逆序数 + 中间靠右数组的逆序数 + 两个子数组之间产生的逆序数 然后递归求解两边的逆序数，发现：原子问题： 两个数字的逆序数 最后要合并问题 这里我为难廖，怎么合并呢？也就是说，怎么求两个子数组之间产生的逆序数呢？ 先考虑暴力做法，跟上方的代码差不多，左边遍历一遍，然后嵌套里面，里面右边遍历一遍 有什么优化嘛？什么被重复计算了？ 我发现了：假设5&gt;2，5在2前面，如果有7&gt;5，7在2的前面，那么一定有7&gt;2 这里自然而然想到了排序，也就假设左右合并的数组已经排好序(升序)了 发现只用遍历一遍就能出结果 计数好右边的数字的数目 遍历整个排好升序的数组 如果遍历到右边的数字，计数– 如果遍历到左边的数字，结果 += 计数 如此得合并的时间复杂度为 排序的复杂度+一个单n 分治法1这里搞了一个结构体，用来暂存传入Merge()中的数组以及下标，并且排好序 //分治法的合并 int Merge(int l, int r) { for(int i = l; i &lt;= r; i++) { snot2[i].num = snot[i]; snot2[i].p = i; } VQuickSort(l, r); int count = 0, result = 0; for(int i = l; i &lt;= r; i++) { if(snot2[i].p &gt; ( l + r ) / 2) count++; if(snot2[i].p &lt;= ( l + r ) / 2) result += count; snot2[i].num = 0; snot2[i].p = 0; } return result; } //分治法的拆分和递归 int Rev(int l, int r) { if(l + 1 == r) { if(snot[l] &gt;= snot[r]) return 1; else return 0; } else if (l &lt; r) { int mid = ( l + r ) / 2; int leftValue = Rev(l, mid); int rightValue = Rev(mid + 1, r); int midValue = Merge(l, r); return leftValue + rightValue + midValue; } else return 0; }正确性：由循环不变式确定，正确 时间复杂度( T(1) = theta(1) )： T(n) = 2T(n / 2) + nlgn = theta(nlg(n)lg(n)) 嗯还是超了，事实证明只过了前50% 很明显问题出在Merge()上，每次都排一次序很麻烦 然后 这 个 时 候 我终于意识到了 这玩意跟归并排序好像啊！ 归并排序也有排序啊，也有分治啊 归并排序的Merge()部分，数组是由Partition部分排过序的 那么这个题也在Partition部分排个序也就行廖 分治法2其实这个题就是分治法加上一个返回值啊…… long long int Merge(int left, int right) { int mid = (left + right) / 2; int leftLength = right - mid; long long int result = 0; int k,p; k = mid; p = right; for(int i = 1; i &lt;= right - left + 1; i++) { if(k &lt; left) { mia[i] = snot[p]; p--; leftLength--; } else if(p &lt; mid + 1) { mia[i] = snot[k]; k--; } else if(snot[k] &lt;= snot[p]) { mia[i] = snot[p]; p--; leftLength--; } else if(snot[k] &gt; snot[p]) { mia[i] = snot[k]; k--; result += leftLength; } } for(int i = right - left + 1; i &gt;= 1; i--) { snot[left + right - left + 1 - i] = mia[i]; mia[i] = 0; } return result; } long long int Rev(int left, int right) { if(left &lt; right) { if(left + 1 == right) { if(snot[left] &gt; snot[right]) { swap(snot[left], snot[right]); return 1; } else return 0; } int mid = (left + right) / 2; long long int leftValue = Rev(left, mid); long long int rightValue = Rev(mid + 1, right); long long int midValue = Merge(left, right); return leftValue + rightValue + midValue; } return 0; }嗯，AC了，是我愚钝，把这道普及+的题看♂了QAQ 以后分治的时候可别再犯这种 过程重复计算使时间空间复杂度提高 的蠢错误了啊QAQ 欧系卖To be continued","content":"<h1 id=\"P1908\"><a href=\"#P1908\" class=\"headerlink\" title=\"P1908\"></a>P1908</h1><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。</p>\n<a id=\"more\"></a>\n\n<p>Update:数据已加强。</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>第一行，一个数n，表示序列中有n个数。</p>\n<p>第二行n个数，表示给定的序列。序列中每个数字不超过10^910<br>9</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>给定序列中逆序对的数目。</p>\n<h2 id=\"输入输出样例\"><a href=\"#输入输出样例\" class=\"headerlink\" title=\"输入输出样例\"></a>输入输出样例</h2><p>输入 #1  </p>\n<pre><code>6\n5 4 2 6 3 1</code></pre><p>输出</p>\n<pre><code>11</code></pre><h2 id=\"说明-提示\"><a href=\"#说明-提示\" class=\"headerlink\" title=\"说明/提示\"></a>说明/提示</h2><p>对于25%的数据，n \\leq 2500n≤2500</p>\n<p>对于50%的数据，n \\leq 4 \\times 10^4n≤4×10<br>4<br> 。</p>\n<p>对于所有数据，n \\leq 5 \\times 10^5n≤5×10<br>5</p>\n<p>请使用较快的输入输出</p>\n<hr>\n<h1 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h1><h2 id=\"听音乐\"><a href=\"#听音乐\" class=\"headerlink\" title=\"听音乐~\"></a>听音乐~</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=26121276&auto=0&height=66\"></iframe>\n\n<p>啊对了，忘了说廖，建立这个博客就是为了记录学编程的过程呢</p>\n<p>大概是初二(初三？？ 反正我也不知道我跳的是初二还是初三hhh)开始学的C扒</p>\n<p>然后高一试着搞了搞noip，高二喜提省二第一就放弃廖TAT</p>\n<p><strong>菜是原罪啊</strong></p>\n<p>现在大一廖，也不知道怎么脑子抽了报志愿就报了计算机专业hhh</p>\n<p>终于决定痛改前非，去搞一搞ACM</p>\n<p>总之就是你们面前这个写博客的蒟蒻又双叒叕开始学编程了QAQ</p>\n<p>应该在博客里打算记一下这些东西：    </p>\n<ul>\n<li>算法题中过程出大问题的地方 Question<ul>\n<li>应该会按照算法分好类</li>\n</ul>\n</li>\n<li>一些奇♂妙的编程方法 Algorithm</li>\n<li>一些编程科目的小笔记 Note<ul>\n<li>应该不多这个</li>\n</ul>\n</li>\n</ul>\n<p>嘛应该会记得很杂很杂…..尽量分个小类吧hhh</p>\n<p>不啰嗦了hh</p>\n<hr>\n<h1 id=\"解\"><a href=\"#解\" class=\"headerlink\" title=\"解\"></a>解</h1><p>嘛首先看到这道题，分析一波数据要求<code>theta(nlgn)</code></p>\n<p>然后首先考虑遍历数组，发现暴力做法就是遍历两遍数组： </p>\n<hr>\n<h2 id=\"暴力解法\"><a href=\"#暴力解法\" class=\"headerlink\" title=\"暴力解法\"></a><em>暴力解法</em></h2><pre><code>for(int i = 1; i &lt;= n; i++)\n    for(int j = i + 1; j &lt;= n; j++&gt;)\n        if(a[i] &gt; a[j])\n            count++;</code></pre><p>嗯就是这么暴力,自己求一遍逆，用计算机打出我的暴力思路hhh</p>\n<p>然后发现<del>题目标签有分治法</del>，这道题可以用分治法来做</p>\n<ul>\n<li><p>先拆分，一般都拆成二分<br><code>一列数组的逆序数 = 中间靠左数组的逆序数 + 中间靠右数组的逆序数 + 两个子数组之间产生的逆序数</code></p>\n</li>\n<li><p>然后递归求解两边的逆序数，发现：<br><code>原子问题： 两个数字的逆序数</code></p>\n</li>\n<li><p>最后要合并问题</p>\n</li>\n</ul>\n<p>这里我为难廖，怎么合并呢？也就是说，怎么求两个子数组之间产生的逆序数呢？</p>\n<p>先考虑暴力做法，跟上方的代码差不多，左边遍历一遍，然后嵌套里面，里面右边遍历一遍</p>\n<p>有什么优化嘛？什么被重复计算了？</p>\n<p>我发现了：<em>假设5&gt;2，5在2前面，如果有7&gt;5，7在2的前面，那么一定有7&gt;2</em></p>\n<p>这里自然而然想到了排序，也就假设左右合并的数组已经排好序(升序)了</p>\n<p>发现只用遍历一遍就能出结果</p>\n<ol>\n<li>计数好右边的数字的数目</li>\n<li>遍历整个排好升序的数组</li>\n<li><ul>\n<li>如果遍历到右边的数字，计数–</li>\n<li>如果遍历到左边的数字，结果 += 计数</li>\n</ul>\n</li>\n</ol>\n<p>如此得合并的时间复杂度为 <em>排序的复杂度+一个单n</em></p>\n<hr>\n<h2 id=\"分治法1\"><a href=\"#分治法1\" class=\"headerlink\" title=\"分治法1\"></a><em>分治法1</em></h2><p>这里搞了一个结构体，用来暂存传入Merge()中的数组以及下标，并且排好序</p>\n<pre><code>//分治法的合并\nint Merge(int l, int r)\n{\n    for(int i = l; i &lt;= r; i++)\n    {\n        snot2[i].num = snot[i];\n        snot2[i].p = i;\n    }\n\n\n    VQuickSort(l, r);\n\n    int count = 0, result = 0;\n\n    for(int i = l; i &lt;= r; i++)\n    {\n        if(snot2[i].p &gt; ( l + r ) / 2)\n            count++;\n        if(snot2[i].p &lt;= ( l + r ) / 2)\n            result += count;\n\n        snot2[i].num = 0;\n        snot2[i].p = 0;\n    }\n    return result;\n}\n\n//分治法的拆分和递归\nint Rev(int l, int r)\n{\n    if(l + 1 == r)\n    {\n        if(snot[l] &gt;= snot[r])\n            return 1;\n        else\n            return 0;\n    }\n    else if (l &lt; r)\n    {\n        int mid = ( l + r ) / 2;\n        int leftValue = Rev(l, mid);\n        int rightValue = Rev(mid + 1, r);\n        int midValue = Merge(l, r);\n        return leftValue + rightValue + midValue;\n    }\n    else\n        return 0;\n}</code></pre><p>正确性：由循环不变式确定，正确</p>\n<p>时间复杂度( <strong>T(1) = theta(1)</strong> )：</p>\n<p><code>T(n) = 2T(n / 2) + nlgn = theta(nlg(n)lg(n))</code></p>\n<p>嗯还是超了，事实证明只过了前50%</p>\n<p>很明显问题出在Merge()上，每次都排一次序很麻烦</p>\n<p>然后 <strong>这</strong> <strong>个</strong> <strong>时</strong> <strong>候</strong></p>\n<p>我终于意识到了</p>\n<p>这玩意跟归并排序好像啊！</p>\n<p>归并排序也有排序啊，也有分治啊</p>\n<p>归并排序的Merge()部分，数组是由Partition部分排过序的</p>\n<p>那么这个题也在Partition部分排个序也就行廖</p>\n<hr>\n<h2 id=\"分治法2\"><a href=\"#分治法2\" class=\"headerlink\" title=\"分治法2\"></a><em>分治法2</em></h2><p>其实这个题就是分治法加上一个返回值啊……</p>\n<pre><code>long long int Merge(int left, int right)\n{\n    int mid = (left + right) / 2;\n    int leftLength = right - mid;\n    long long int result = 0;\n\n    int k,p;\n    k = mid;\n    p = right;\n\n    for(int i = 1; i &lt;= right - left + 1; i++)\n    {\n        if(k &lt; left)\n        {\n            mia[i] = snot[p];\n            p--;\n            leftLength--;\n        }\n        else if(p &lt; mid + 1)\n        {\n            mia[i] = snot[k];\n            k--;\n        }\n        else if(snot[k] &lt;= snot[p])\n        {\n            mia[i] = snot[p];\n            p--;\n            leftLength--;\n        }\n        else if(snot[k] &gt; snot[p])\n        {\n            mia[i] = snot[k];\n            k--;\n            result += leftLength;\n        }\n    }\n    for(int i = right - left + 1; i &gt;= 1; i--)\n    {\n        snot[left + right - left + 1 - i] = mia[i];\n        mia[i] = 0;\n    }\n\n\n    return result;\n}\n\nlong long int Rev(int left, int right)\n{\n    if(left &lt; right)\n    {\n        if(left + 1 == right)\n        {\n            if(snot[left] &gt; snot[right])\n            {\n                swap(snot[left], snot[right]);\n                return 1;\n            }\n            else\n                return 0;\n        }\n\n        int mid = (left + right) / 2;\n        long long int leftValue = Rev(left, mid);\n        long long int rightValue = Rev(mid + 1, right);\n        long long int midValue = Merge(left, right);\n        return leftValue + rightValue + midValue;\n    }\n    return 0;\n}</code></pre><p>嗯，AC了，是我愚钝，把这道普及+的题看♂了QAQ</p>\n<p>以后分治的时候可别再犯这种 <strong>过程重复计算使时间空间复杂度提高</strong> 的蠢错误了啊QAQ</p>\n<p>欧系卖<br>To be continued</p>\n","categories":[],"tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"分治法","slug":"分治法","permalink":"https://v25bh145.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"我的第一个博客","date":"2019-11-26T09:28:19.000Z","path":"2019/11/26/我的第一个博客/","text":"首先，不管你是谁，总之欢迎来到我的博客鸭~ 听音乐~ 第一个博客文章，我就记一下.md的相关知识扒 学自菜鸟教程 https://www.runoob.com/markdown/md-tutorial.html 一. 标题标题一共六种鸭，一级到六级 一级标题二级标题三级标题四级标题五级标题六级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题 ------- 二级标题 =======二. 段落的格式关于换行的话，有两种方式： 在一行尾部空出两个以上空格 多空一行 这两种方式有差别的亚子 段落的字体可以自己设置鸭 有这些： 星号星号可以插入在文本之间呢 斜体字~粗♂体字粗♂斜♂体 *斜体字~* **粗♂体字** ***粗♂斜♂体*** 下划线下划线只能在段首段位使用的斜体字~粗♂体字 _斜体字~_ __粗♂体字__ 分割线↓这个就是个分割线辣~~↓ *** * * * ***** - - - ------- 删除线删除线一一一(调皮) ~~删除线~~ 下划线这个 &lt;u&gt;下划线&lt;/u&gt; 脚注 脚注貌似无法使用emmmmm 三. 列表有序的和无序的： 第一项 第二项 第三项 * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 qaq qaq qaq 1. qaq 2. qaq 3. qaq 然后还能嵌套,像酱紫 qaq qaq qaq qaq qaq qaq qaq qaq qaq qaq (混乱) 四. 区块区块引用就是加上一个&gt;符号和一个空格 我是一个区块引用 巧了，我也是诶 我不仅有一级引用 我还有二级引用 甚至还有三级 甚至还能做列表 还能嵌套 列表 区块引用 &gt; 我是一个区块引用 &gt; 巧了，我也是诶 &gt; 我不仅有一级引用 &gt; &gt; 我还有二级引用 &gt; &gt; &gt; 甚至还有三级 &gt; &gt; &gt; * 甚至还能做列表 &gt; &gt; &gt; + 还能嵌套 &gt; &gt; 1. 列表 &gt; &gt; &gt; &gt; 区块引用五. 代码scanf()函数~printf()函数~static void main(String[] args) `scanf()`函数~ `printf()`函数~ `static void main(String[] args` 空四格或者一个Tab就是代码区块辣 ----&gt;像这样(这怎么描述啊喂)六. 链接比如酱紫: 滚去问度娘啊！ 滚去问[度娘](http://www.baidu.com/)啊！https://v25bh145.github.io/ &lt;https://v25bh145.github.io/&gt;还有高级(搞♂基)的链接 变量式的： 滚去问度娘啊啊啊 baidu滚去问[我的主页]啊啊啊 主页 七. 图片![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) alt 属性文本 :就是图片的替代文字 可选标题 :title属性的文字 我这里用了这个上传图片网站哇 ![example.png](https://i.loli.net/2019/11/26/eSxz8W2A6rFpMyK.png)当然是可以使用变量的啦 [example][1] [1]: &quot;链接&quot;八. 表格 表头 &lt;-学姐头没了(滑稽) 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 |表头||&lt;-学姐头没了(滑稽)| | ---- | ---- | ---- | | 单元格儿 | 单元格儿 | 单元格儿 | | 单元格儿 | 单元格儿 | 单元格儿 |表头底下的横线还可以设置表格格式： :—- 居左对齐 —-: 居右对齐 :—-: 居中对齐 ⑨. 另外一些gao♂ji特性一些高级技巧： 支持HTML元素也就是说可以不用学markdown直接开学html哈哈哈 *转义* \\*转义\\* 内嵌数学公式以$$开始，$$结束,格式为TeX或者LaTeX","content":"<h2 id=\"首先，不管你是谁，总之欢迎来到我的博客鸭\"><a href=\"#首先，不管你是谁，总之欢迎来到我的博客鸭\" class=\"headerlink\" title=\"首先，不管你是谁，总之欢迎来到我的博客鸭~\"></a>首先，不管你是谁，总之欢迎来到我的博客鸭~</h2><a id=\"more\"></a>\n\n<p><strong>听音乐~</strong></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=527778&auto=0&height=66\"></iframe>\n\n<p>第一个博客文章，我就记一下.md的相关知识扒  </p>\n<p>学自菜鸟教程 </p>\n<blockquote>\n<p><a href=\"https://www.runoob.com/markdown/md-tutorial.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/markdown/md-tutorial.html</a></p>\n</blockquote>\n<h1 id=\"一-标题\"><a href=\"#一-标题\" class=\"headerlink\" title=\"一. 标题\"></a>一. 标题</h1><p>标题一共六种鸭，一级到六级     </p>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><pre><code># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n一级标题\n-------\n二级标题\n=======</code></pre><h1 id=\"二-段落的格式\"><a href=\"#二-段落的格式\" class=\"headerlink\" title=\"二. 段落的格式\"></a>二. 段落的格式</h1><p>关于换行的话，有两种方式：  </p>\n<ol>\n<li>在一行尾部空出两个以上空格</li>\n<li>多空一行</li>\n</ol>\n<p>这两种方式有差别的亚子</p>\n<p>段落的字体可以自己设置鸭</p>\n<p>有这些：  </p>\n<ol>\n<li>星号<br>星号可以<strong>插入在文本之间</strong>呢  </li>\n</ol>\n<p><em>斜体字~</em><br><strong>粗♂体字</strong><br><strong><em>粗♂斜♂体</em></strong>   </p>\n<pre><code>*斜体字~*   \n**粗♂体字**\n***粗♂斜♂体***   </code></pre><ol start=\"2\">\n<li><p>下划线<br>下划线只能在段首段位使用的<br><em>斜体字~</em><br><strong>粗♂体字</strong>  </p>\n<pre><code>_斜体字~_  \n__粗♂体字__</code></pre></li>\n<li><p>分割线<br>↓这个就是个分割线辣~~↓  </p>\n</li>\n</ol>\n<hr>\n<pre><code>***\n* * *\n*****\n- - -\n-------</code></pre><ol start=\"4\">\n<li>删除线<br><del>删除线</del><br><del>一一一</del>(调皮)  </li>\n</ol>\n<pre><code>~~删除线~~</code></pre><ol start=\"5\">\n<li><p>下划线<br><u>这个</u></p>\n<pre><code>&lt;u&gt;下划线&lt;/u&gt;</code></pre></li>\n<li><p>脚注<br> 脚注貌似无法使用emmmmm</p>\n</li>\n</ol>\n<h1 id=\"三-列表\"><a href=\"#三-列表\" class=\"headerlink\" title=\"三. 列表\"></a>三. 列表</h1><p>有序的和无序的：</p>\n<ul>\n<li><p>第一项</p>\n</li>\n<li><p>第二项</p>\n</li>\n<li><p>第三项  </p>\n<pre><code>* 第一项\n* 第二项\n* 第三项  \n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项</code></pre></li>\n</ul>\n<ol>\n<li><p>qaq</p>\n</li>\n<li><p>qaq</p>\n</li>\n<li><p>qaq</p>\n<pre><code>1. qaq\n2. qaq\n3. qaq</code></pre></li>\n</ol>\n<p>然后还能嵌套,像酱紫</p>\n<ol>\n<li>qaq</li>\n</ol>\n<ul>\n<li>qaq<ul>\n<li>qaq</li>\n</ul>\n<ul>\n<li>qaq<ul>\n<li>qaq<ul>\n<li>qaq<ul>\n<li>qaq</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ol start=\"2\">\n<li>qaq</li>\n</ol>\n<ul>\n<li>qaq</li>\n</ul>\n<ol start=\"4\">\n<li><p>qaq</p>\n<p> (混乱)</p>\n<h1 id=\"四-区块\"><a href=\"#四-区块\" class=\"headerlink\" title=\"四. 区块\"></a>四. 区块</h1><p>区块引用就是加上一个&gt;符号和一个空格</p>\n<blockquote>\n<p>我是一个区块引用  </p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>巧了，我也是诶</p>\n</blockquote>\n<blockquote>\n<p>我不仅有一级引用</p>\n<blockquote>\n<p>我还有二级引用</p>\n<blockquote>\n<p>甚至还有三级  </p>\n<ul>\n<li>甚至还能做列表<ul>\n<li>还能嵌套</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ol>\n<li>列表<blockquote>\n<blockquote>\n<p>区块引用</p>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n</blockquote>\n<pre><code>&gt; 我是一个区块引用  \n\n&gt; 巧了，我也是诶\n\n&gt; 我不仅有一级引用\n&gt; &gt; 我还有二级引用\n&gt; &gt; &gt; 甚至还有三级  \n&gt; &gt; &gt; * 甚至还能做列表\n&gt; &gt; &gt;   + 还能嵌套\n\n&gt; &gt; 1. 列表\n&gt; &gt; &gt; &gt; 区块引用</code></pre><h1 id=\"五-代码\"><a href=\"#五-代码\" class=\"headerlink\" title=\"五. 代码\"></a>五. 代码</h1><p><code>scanf()</code>函数~<br><code>printf()</code>函数~<br><code>static void main(String[] args)</code></p>\n<pre><code>`scanf()`函数~  \n`printf()`函数~  \n`static void main(String[] args`  </code></pre><p>空四格或者一个Tab就是代码区块辣</p>\n<pre><code>----&gt;像这样(这怎么描述啊喂)</code></pre><h1 id=\"六-链接\"><a href=\"#六-链接\" class=\"headerlink\" title=\"六. 链接\"></a>六. 链接</h1><p>比如酱紫:</p>\n<p>滚去问<a href=\"http://www.baidu.com/\" target=\"_blank\" rel=\"noopener\">度娘</a>啊！</p>\n<pre><code>滚去问[度娘](http://www.baidu.com/)啊！</code></pre><p><a href=\"https://v25bh145.github.io/\">https://v25bh145.github.io/</a></p>\n<pre><code>&lt;https://v25bh145.github.io/&gt;</code></pre><p>还有高级(<del>搞♂基</del>)的链接  </p>\n<p>变量式的：</p>\n<p>滚去问度娘啊啊啊 <a href=\"http://www.baidu.com/\" target=\"_blank\" rel=\"noopener\">baidu</a><br>滚去问[我的主页]啊啊啊 <a href=\"https://v25bh145.github.io\">主页</a>  </p>\n<h1 id=\"七-图片\"><a href=\"#七-图片\" class=\"headerlink\" title=\"七. 图片\"></a>七. 图片</h1><pre><code>![alt 属性文本](图片地址)\n![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><ul>\n<li><em>alt 属性文本</em> :就是图片的替代文字</li>\n<li><em>可选标题</em> :title属性的文字</li>\n</ul>\n<p>我这里用了<a href=\"https://sm.ms/\" target=\"_blank\" rel=\"noopener\">这个上传图片网站</a>哇</p>\n<p><img src=\"https://i.loli.net/2019/11/26/eSxz8W2A6rFpMyK.png\" alt=\"example.png\"></p>\n<pre><code>![example.png](https://i.loli.net/2019/11/26/eSxz8W2A6rFpMyK.png)</code></pre><p>当然是可以使用变量的啦    </p>\n<pre><code>[example][1]  \n[1]: &quot;链接&quot;</code></pre><h1 id=\"八-表格\"><a href=\"#八-表格\" class=\"headerlink\" title=\"八. 表格\"></a>八. 表格</h1><table>\n<thead>\n<tr>\n<th>表头</th>\n<th></th>\n<th>&lt;-学姐头没了(滑稽)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单元格儿</td>\n<td>单元格儿</td>\n<td>单元格儿</td>\n</tr>\n<tr>\n<td>单元格儿</td>\n<td>单元格儿</td>\n<td>单元格儿</td>\n</tr>\n</tbody></table>\n<pre><code>|表头||&lt;-学姐头没了(滑稽)|\n| ---- | ---- | ---- |\n| 单元格儿 | 单元格儿 | 单元格儿 |\n| 单元格儿 | 单元格儿 | 单元格儿 |</code></pre><p>表头底下的横线还可以设置表格格式：</p>\n<ul>\n<li>:—- 居左对齐</li>\n<li>—-: 居右对齐</li>\n<li>:—-: 居中对齐</li>\n</ul>\n<h1 id=\"⑨-另外一些gao♂ji特性\"><a href=\"#⑨-另外一些gao♂ji特性\" class=\"headerlink\" title=\"⑨. 另外一些gao♂ji特性\"></a>⑨. 另外一些gao♂ji特性</h1><p>一些高级技巧：</p>\n<ol>\n<li><p>支持HTML元素<br><del>也就是说可以不用学markdown直接开学html哈哈哈</del></p>\n</li>\n<li><p>*转义*  </p>\n<pre><code>\\*转义\\*</code></pre></li>\n<li><p>内嵌数学公式<br>以$$开始，$$结束,格式为<strong>TeX</strong>或者<strong>LaTeX</strong></p>\n</li>\n</ol>\n","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://v25bh145.github.io/tags/markdown/"},{"name":"随笔","slug":"随笔","permalink":"https://v25bh145.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]